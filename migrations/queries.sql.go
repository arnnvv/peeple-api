// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package migrations

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addContentLike = `-- name: AddContentLike :one
INSERT INTO likes (
    liker_user_id,
    liked_user_id,
    content_type,
    content_identifier,
    comment,
    interaction_type
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (liker_user_id, liked_user_id, content_type, content_identifier)
DO NOTHING
RETURNING id, liker_user_id, liked_user_id, content_type, content_identifier, comment, interaction_type, created_at
`

type AddContentLikeParams struct {
	LikerUserID       int32
	LikedUserID       int32
	ContentType       ContentLikeType
	ContentIdentifier string
	Comment           pgtype.Text
	InteractionType   LikeInteractionType
}

// Inserts a like for a specific content item, potentially with a comment.
// content_identifier is TEXT type in the DB.
// Prevent duplicate likes on the exact same item
func (q *Queries) AddContentLike(ctx context.Context, arg AddContentLikeParams) (Like, error) {
	row := q.db.QueryRow(ctx, addContentLike,
		arg.LikerUserID,
		arg.LikedUserID,
		arg.ContentType,
		arg.ContentIdentifier,
		arg.Comment,
		arg.InteractionType,
	)
	var i Like
	err := row.Scan(
		&i.ID,
		&i.LikerUserID,
		&i.LikedUserID,
		&i.ContentType,
		&i.ContentIdentifier,
		&i.Comment,
		&i.InteractionType,
		&i.CreatedAt,
	)
	return i, err
}

const addDislike = `-- name: AddDislike :exec
INSERT INTO dislikes (disliker_user_id, disliked_user_id)
VALUES ($1, $2)
ON CONFLICT (disliker_user_id, disliked_user_id) DO NOTHING
`

type AddDislikeParams struct {
	DislikerUserID int32
	DislikedUserID int32
}

func (q *Queries) AddDislike(ctx context.Context, arg AddDislikeParams) error {
	_, err := q.db.Exec(ctx, addDislike, arg.DislikerUserID, arg.DislikedUserID)
	return err
}

const addPhoneNumberInUsers = `-- name: AddPhoneNumberInUsers :one

INSERT INTO users (
    phone_number
) VALUES (
    $1
)
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

// $1 should be 'pending'
func (q *Queries) AddPhoneNumberInUsers(ctx context.Context, phoneNumber string) (User, error) {
	row := q.db.QueryRow(ctx, addPhoneNumberInUsers, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const addUserSubscription = `-- name: AddUserSubscription :one
INSERT INTO user_subscriptions (
    user_id, feature_type, expires_at, activated_at
) VALUES (
    $1, $2, $3, NOW()
)
RETURNING id, user_id, feature_type, activated_at, expires_at, created_at
`

type AddUserSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
	ExpiresAt   pgtype.Timestamptz
}

func (q *Queries) AddUserSubscription(ctx context.Context, arg AddUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, addUserSubscription, arg.UserID, arg.FeatureType, arg.ExpiresAt)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const cleanOTP = `-- name: CleanOTP :exec
DELETE FROM otps
WHERE expires_at < NOW()
`

func (q *Queries) CleanOTP(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanOTP)
	return err
}

const cleanOTPs = `-- name: CleanOTPs :exec
DELETE FROM otps
WHERE expires_at < NOW()
`

func (q *Queries) CleanOTPs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanOTPs)
	return err
}

const clearUserMediaURLs = `-- name: ClearUserMediaURLs :exec
UPDATE users
SET media_urls = '{}'
WHERE id = $1
`

func (q *Queries) ClearUserMediaURLs(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, clearUserMediaURLs, id)
	return err
}

const countRecentStandardLikes = `-- name: CountRecentStandardLikes :one
SELECT COUNT(*) FROM likes
WHERE liker_user_id = $1
  AND interaction_type = 'standard'
  AND created_at >= NOW() - INTERVAL '24 hours'
`

func (q *Queries) CountRecentStandardLikes(ctx context.Context, likerUserID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentStandardLikes, likerUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDateVibesPrompt = `-- name: CreateDateVibesPrompt :one
INSERT INTO date_vibes_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateDateVibesPromptParams struct {
	UserID   int32
	Question DateVibesPromptType
	Answer   string
}

func (q *Queries) CreateDateVibesPrompt(ctx context.Context, arg CreateDateVibesPromptParams) (DateVibesPrompt, error) {
	row := q.db.QueryRow(ctx, createDateVibesPrompt, arg.UserID, arg.Question, arg.Answer)
	var i DateVibesPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createGettingPersonalPrompt = `-- name: CreateGettingPersonalPrompt :one
INSERT INTO getting_personal_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateGettingPersonalPromptParams struct {
	UserID   int32
	Question GettingPersonalPromptType
	Answer   string
}

func (q *Queries) CreateGettingPersonalPrompt(ctx context.Context, arg CreateGettingPersonalPromptParams) (GettingPersonalPrompt, error) {
	row := q.db.QueryRow(ctx, createGettingPersonalPrompt, arg.UserID, arg.Question, arg.Answer)
	var i GettingPersonalPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createMyTypePrompt = `-- name: CreateMyTypePrompt :one
INSERT INTO my_type_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateMyTypePromptParams struct {
	UserID   int32
	Question MyTypePromptType
	Answer   string
}

func (q *Queries) CreateMyTypePrompt(ctx context.Context, arg CreateMyTypePromptParams) (MyTypePrompt, error) {
	row := q.db.QueryRow(ctx, createMyTypePrompt, arg.UserID, arg.Question, arg.Answer)
	var i MyTypePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createOTP = `-- name: CreateOTP :one
INSERT INTO otps (
    user_id, otp_code
) VALUES (
    $1, $2
)
RETURNING id, user_id, otp_code, expires_at
`

type CreateOTPParams struct {
	UserID  int32
	OtpCode string
}

func (q *Queries) CreateOTP(ctx context.Context, arg CreateOTPParams) (Otp, error) {
	row := q.db.QueryRow(ctx, createOTP, arg.UserID, arg.OtpCode)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OtpCode,
		&i.ExpiresAt,
	)
	return i, err
}

const createStoryTimePrompt = `-- name: CreateStoryTimePrompt :one
INSERT INTO story_time_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateStoryTimePromptParams struct {
	UserID   int32
	Question StoryTimePromptType
	Answer   string
}

func (q *Queries) CreateStoryTimePrompt(ctx context.Context, arg CreateStoryTimePromptParams) (StoryTimePrompt, error) {
	row := q.db.QueryRow(ctx, createStoryTimePrompt, arg.UserID, arg.Question, arg.Answer)
	var i StoryTimePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createUserMinimal = `-- name: CreateUserMinimal :one
INSERT INTO users (
    phone_number, gender
) VALUES (
    $1, $2
)
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type CreateUserMinimalParams struct {
	PhoneNumber string
	Gender      NullGenderEnum
}

func (q *Queries) CreateUserMinimal(ctx context.Context, arg CreateUserMinimalParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserMinimal, arg.PhoneNumber, arg.Gender)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const decrementUserConsumable = `-- name: DecrementUserConsumable :one

UPDATE user_consumables
SET quantity = quantity - 1,
    updated_at = NOW()
WHERE user_id = $1
  AND consumable_type = $2 -- e.g., 'rose'
  AND quantity > 0
RETURNING user_id, consumable_type, quantity, updated_at
`

type DecrementUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

// e.g., 'rose'
func (q *Queries) DecrementUserConsumable(ctx context.Context, arg DecrementUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, decrementUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOTPByID = `-- name: DeleteOTPByID :exec
DELETE FROM otps
WHERE id = $1
`

func (q *Queries) DeleteOTPByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOTPByID, id)
	return err
}

const deleteOTPByUser = `-- name: DeleteOTPByUser :exec
DELETE FROM otps
WHERE user_id = $1
`

func (q *Queries) DeleteOTPByUser(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteOTPByUser, userID)
	return err
}

const deleteOTPsByPhoneNumber = `-- name: DeleteOTPsByPhoneNumber :exec
DELETE FROM otps
WHERE user_id = (SELECT id FROM users WHERE phone_number = $1)
`

func (q *Queries) DeleteOTPsByPhoneNumber(ctx context.Context, phoneNumber string) error {
	_, err := q.db.Exec(ctx, deleteOTPsByPhoneNumber, phoneNumber)
	return err
}

const deleteUserDateVibesPrompts = `-- name: DeleteUserDateVibesPrompts :exec
DELETE FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserDateVibesPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserDateVibesPrompts, userID)
	return err
}

const deleteUserGettingPersonalPrompts = `-- name: DeleteUserGettingPersonalPrompts :exec
DELETE FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserGettingPersonalPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserGettingPersonalPrompts, userID)
	return err
}

const deleteUserMyTypePrompts = `-- name: DeleteUserMyTypePrompts :exec
DELETE FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserMyTypePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserMyTypePrompts, userID)
	return err
}

const deleteUserStoryTimePrompts = `-- name: DeleteUserStoryTimePrompts :exec
DELETE FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserStoryTimePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserStoryTimePrompts, userID)
	return err
}

const getActiveSubscription = `-- name: GetActiveSubscription :one
SELECT id, user_id, feature_type, activated_at, expires_at, created_at FROM user_subscriptions
WHERE user_id = $1
  AND feature_type = $2 -- e.g., 'unlimited_likes'
  AND expires_at > NOW()
LIMIT 1
`

type GetActiveSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
}

func (q *Queries) GetActiveSubscription(ctx context.Context, arg GetActiveSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, getActiveSubscription, arg.UserID, arg.FeatureType)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getHomeFeed = `-- name: GetHomeFeed :many
WITH RequestingUser AS (
    SELECT
        u.id, u.latitude, u.longitude, u.gender, u.date_of_birth, u.spotlight_active_until
    FROM users u WHERE u.id = $1
), RequestingUserFilters AS (
    SELECT
        f.user_id, f.who_you_want_to_see, f.radius_km, f.active_today, f.age_min, f.age_max
    FROM filters f WHERE f.user_id = $1
)
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.phone_number, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer, target_user.spotlight_active_until,
    haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
JOIN RequestingUser ru ON target_user.id != ru.id
JOIN RequestingUserFilters rf ON ru.id = rf.user_id
LEFT JOIN filters AS target_user_filters ON target_user.id = target_user_filters.user_id
WHERE
    target_user.latitude IS NOT NULL AND target_user.longitude IS NOT NULL
    AND (rf.radius_km IS NULL OR haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) <= rf.radius_km)
    AND target_user.gender = rf.who_you_want_to_see
    AND (target_user_filters.user_id IS NULL OR target_user_filters.who_you_want_to_see IS NULL OR target_user_filters.who_you_want_to_see = ru.gender)
    AND target_user.date_of_birth IS NOT NULL
    AND EXTRACT(YEAR FROM AGE(target_user.date_of_birth)) BETWEEN rf.age_min AND rf.age_max
    AND (NOT rf.active_today OR EXISTS (
            SELECT 1 FROM app_open_logs aol
            WHERE aol.user_id = target_user.id AND aol.opened_at >= NOW() - INTERVAL '24 hours'
        ))
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = ru.id AND d.disliked_user_id = target_user.id)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = target_user.id AND d.disliked_user_id = ru.id)
    AND NOT EXISTS (SELECT 1 FROM likes l WHERE l.liker_user_id = ru.id AND l.liked_user_id = target_user.id)
ORDER BY
    CASE WHEN target_user.spotlight_active_until > NOW() THEN 0 ELSE 1 END ASC,
    distance_km ASC,
    ABS(EXTRACT(YEAR FROM AGE(ru.date_of_birth)) - EXTRACT(YEAR FROM AGE(target_user.date_of_birth))) ASC NULLS LAST
LIMIT $2
`

type GetHomeFeedParams struct {
	ID    int32
	Limit int32
}

type GetHomeFeedRow struct {
	ID                   int32
	CreatedAt            pgtype.Timestamptz
	Name                 pgtype.Text
	LastName             pgtype.Text
	PhoneNumber          string
	DateOfBirth          pgtype.Date
	Latitude             pgtype.Float8
	Longitude            pgtype.Float8
	Gender               NullGenderEnum
	DatingIntention      NullDatingIntention
	Height               pgtype.Float8
	Hometown             pgtype.Text
	JobTitle             pgtype.Text
	Education            pgtype.Text
	ReligiousBeliefs     NullReligion
	DrinkingHabit        NullDrinkingSmokingHabits
	SmokingHabit         NullDrinkingSmokingHabits
	MediaUrls            []string
	VerificationStatus   VerificationStatus
	VerificationPic      pgtype.Text
	Role                 UserRole
	AudioPromptQuestion  NullAudioPrompt
	AudioPromptAnswer    pgtype.Text
	SpotlightActiveUntil pgtype.Timestamptz
	DistanceKm           float64
}

func (q *Queries) GetHomeFeed(ctx context.Context, arg GetHomeFeedParams) ([]GetHomeFeedRow, error) {
	rows, err := q.db.Query(ctx, getHomeFeed, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHomeFeedRow
	for rows.Next() {
		var i GetHomeFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOTPByUser = `-- name: GetOTPByUser :one
SELECT id, user_id, otp_code, expires_at FROM otps
WHERE user_id = $1
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetOTPByUser(ctx context.Context, userID int32) (Otp, error) {
	row := q.db.QueryRow(ctx, getOTPByUser, userID)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OtpCode,
		&i.ExpiresAt,
	)
	return i, err
}

const getPendingVerificationUsers = `-- name: GetPendingVerificationUsers :many
SELECT id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE verification_status = $1
`

func (q *Queries) GetPendingVerificationUsers(ctx context.Context, verificationStatus VerificationStatus) ([]User, error) {
	rows, err := q.db.Query(ctx, getPendingVerificationUsers, verificationStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAudioPrompt = `-- name: GetUserAudioPrompt :one
SELECT id, audio_prompt_question, audio_prompt_answer
FROM users
WHERE id = $1 LIMIT 1
`

type GetUserAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) GetUserAudioPrompt(ctx context.Context, id int32) (GetUserAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, getUserAudioPrompt, id)
	var i GetUserAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE phone_number = $1 LIMIT 1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phoneNumber string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const getUserConsumable = `-- name: GetUserConsumable :one
SELECT user_id, consumable_type, quantity, updated_at FROM user_consumables
WHERE user_id = $1
  AND consumable_type = $2
`

type GetUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

func (q *Queries) GetUserConsumable(ctx context.Context, arg GetUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, getUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDateVibesPrompts = `-- name: GetUserDateVibesPrompts :many
SELECT id, user_id, question, answer FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) GetUserDateVibesPrompts(ctx context.Context, userID int32) ([]DateVibesPrompt, error) {
	rows, err := q.db.Query(ctx, getUserDateVibesPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DateVibesPrompt
	for rows.Next() {
		var i DateVibesPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFilters = `-- name: GetUserFilters :one
SELECT user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at FROM filters
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserFilters(ctx context.Context, userID int32) (Filter, error) {
	row := q.db.QueryRow(ctx, getUserFilters, userID)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserGettingPersonalPrompts = `-- name: GetUserGettingPersonalPrompts :many
SELECT id, user_id, question, answer FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) GetUserGettingPersonalPrompts(ctx context.Context, userID int32) ([]GettingPersonalPrompt, error) {
	rows, err := q.db.Query(ctx, getUserGettingPersonalPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GettingPersonalPrompt
	for rows.Next() {
		var i GettingPersonalPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMyTypePrompts = `-- name: GetUserMyTypePrompts :many
SELECT id, user_id, question, answer FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) GetUserMyTypePrompts(ctx context.Context, userID int32) ([]MyTypePrompt, error) {
	rows, err := q.db.Query(ctx, getUserMyTypePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyTypePrompt
	for rows.Next() {
		var i MyTypePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryTimePrompts = `-- name: GetUserStoryTimePrompts :many
SELECT id, user_id, question, answer FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) GetUserStoryTimePrompts(ctx context.Context, userID int32) ([]StoryTimePrompt, error) {
	rows, err := q.db.Query(ctx, getUserStoryTimePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StoryTimePrompt
	for rows.Next() {
		var i StoryTimePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logAppOpen = `-- name: LogAppOpen :exec
INSERT INTO app_open_logs (user_id)
VALUES ($1)
`

func (q *Queries) LogAppOpen(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, logAppOpen, userID)
	return err
}

const updateAudioPrompt = `-- name: UpdateAudioPrompt :one
UPDATE users
SET audio_prompt_question = $1, audio_prompt_answer = $2
WHERE id = $3
RETURNING id, audio_prompt_question, audio_prompt_answer
`

type UpdateAudioPromptParams struct {
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
	ID                  int32
}

type UpdateAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) UpdateAudioPrompt(ctx context.Context, arg UpdateAudioPromptParams) (UpdateAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, updateAudioPrompt, arg.AudioPromptQuestion, arg.AudioPromptAnswer, arg.ID)
	var i UpdateAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const updateUserMediaURLs = `-- name: UpdateUserMediaURLs :exec
UPDATE users
SET media_urls = $1
WHERE id = $2
`

type UpdateUserMediaURLsParams struct {
	MediaUrls []string
	ID        int32
}

func (q *Queries) UpdateUserMediaURLs(ctx context.Context, arg UpdateUserMediaURLsParams) error {
	_, err := q.db.Exec(ctx, updateUserMediaURLs, arg.MediaUrls, arg.ID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users SET
    name = $1,
    last_name = $2,
    date_of_birth = $3,
    latitude = $4,
    longitude = $5,
    gender = $6,
    dating_intention = $7,
    height = $8,
    hometown = $9,
    job_title = $10,
    education = $11,
    religious_beliefs = $12,
    drinking_habit = $13,
    smoking_habit = $14
WHERE id = $15
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserProfileParams struct {
	Name             pgtype.Text
	LastName         pgtype.Text
	DateOfBirth      pgtype.Date
	Latitude         pgtype.Float8
	Longitude        pgtype.Float8
	Gender           NullGenderEnum
	DatingIntention  NullDatingIntention
	Height           pgtype.Float8
	Hometown         pgtype.Text
	JobTitle         pgtype.Text
	Education        pgtype.Text
	ReligiousBeliefs NullReligion
	DrinkingHabit    NullDrinkingSmokingHabits
	SmokingHabit     NullDrinkingSmokingHabits
	ID               int32
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.Name,
		arg.LastName,
		arg.DateOfBirth,
		arg.Latitude,
		arg.Longitude,
		arg.Gender,
		arg.DatingIntention,
		arg.Height,
		arg.Hometown,
		arg.JobTitle,
		arg.Education,
		arg.ReligiousBeliefs,
		arg.DrinkingHabit,
		arg.SmokingHabit,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET role = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserRoleParams struct {
	Role UserRole
	ID   int32
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserVerificationDetails = `-- name: UpdateUserVerificationDetails :one
UPDATE users
SET
    verification_pic = $1,
    verification_status = $2
WHERE id = $3
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserVerificationDetailsParams struct {
	VerificationPic    pgtype.Text
	VerificationStatus VerificationStatus
	ID                 int32
}

func (q *Queries) UpdateUserVerificationDetails(ctx context.Context, arg UpdateUserVerificationDetailsParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationDetails, arg.VerificationPic, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :one
UPDATE users
SET verification_status = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserVerificationStatusParams struct {
	VerificationStatus VerificationStatus
	ID                 int32
}

func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationStatus, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const upsertUserConsumable = `-- name: UpsertUserConsumable :one
INSERT INTO user_consumables (user_id, consumable_type, quantity)
VALUES ($1, $2, $3) -- $3 is the quantity to add
ON CONFLICT (user_id, consumable_type) DO UPDATE
SET quantity = user_consumables.quantity + EXCLUDED.quantity,
    updated_at = NOW()
RETURNING user_id, consumable_type, quantity, updated_at
`

type UpsertUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
	Quantity       int32
}

func (q *Queries) UpsertUserConsumable(ctx context.Context, arg UpsertUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, upsertUserConsumable, arg.UserID, arg.ConsumableType, arg.Quantity)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserFilters = `-- name: UpsertUserFilters :one
INSERT INTO filters (
    user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (user_id) DO UPDATE SET
    who_you_want_to_see = EXCLUDED.who_you_want_to_see,
    radius_km = EXCLUDED.radius_km,
    active_today = EXCLUDED.active_today,
    age_min = EXCLUDED.age_min,
    age_max = EXCLUDED.age_max,
    updated_at = NOW()
RETURNING user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at
`

type UpsertUserFiltersParams struct {
	UserID          int32
	WhoYouWantToSee NullGenderEnum
	RadiusKm        pgtype.Int4
	ActiveToday     bool
	AgeMin          pgtype.Int4
	AgeMax          pgtype.Int4
}

func (q *Queries) UpsertUserFilters(ctx context.Context, arg UpsertUserFiltersParams) (Filter, error) {
	row := q.db.QueryRow(ctx, upsertUserFilters,
		arg.UserID,
		arg.WhoYouWantToSee,
		arg.RadiusKm,
		arg.ActiveToday,
		arg.AgeMin,
		arg.AgeMax,
	)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package migrations

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addContentLike = `-- name: AddContentLike :one
INSERT INTO likes (
    liker_user_id,
    liked_user_id,
    content_type,
    content_identifier,
    comment,
    interaction_type
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (liker_user_id, liked_user_id, content_type, content_identifier)
DO NOTHING
RETURNING id, liker_user_id, liked_user_id, content_type, content_identifier, comment, interaction_type, created_at
`

type AddContentLikeParams struct {
	LikerUserID       int32
	LikedUserID       int32
	ContentType       ContentLikeType
	ContentIdentifier string
	Comment           pgtype.Text
	InteractionType   LikeInteractionType
}

func (q *Queries) AddContentLike(ctx context.Context, arg AddContentLikeParams) (Like, error) {
	row := q.db.QueryRow(ctx, addContentLike,
		arg.LikerUserID,
		arg.LikedUserID,
		arg.ContentType,
		arg.ContentIdentifier,
		arg.Comment,
		arg.InteractionType,
	)
	var i Like
	err := row.Scan(
		&i.ID,
		&i.LikerUserID,
		&i.LikedUserID,
		&i.ContentType,
		&i.ContentIdentifier,
		&i.Comment,
		&i.InteractionType,
		&i.CreatedAt,
	)
	return i, err
}

const addDislike = `-- name: AddDislike :exec
INSERT INTO dislikes (disliker_user_id, disliked_user_id)
VALUES ($1, $2)
ON CONFLICT (disliker_user_id, disliked_user_id) DO NOTHING
`

type AddDislikeParams struct {
	DislikerUserID int32
	DislikedUserID int32
}

func (q *Queries) AddDislike(ctx context.Context, arg AddDislikeParams) error {
	_, err := q.db.Exec(ctx, addDislike, arg.DislikerUserID, arg.DislikedUserID)
	return err
}

const addUserSubscription = `-- name: AddUserSubscription :one
INSERT INTO user_subscriptions (
    user_id, feature_type, expires_at, activated_at
) VALUES (
    $1, $2, $3, NOW()
)
RETURNING id, user_id, feature_type, activated_at, expires_at, created_at
`

type AddUserSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
	ExpiresAt   pgtype.Timestamptz
}

func (q *Queries) AddUserSubscription(ctx context.Context, arg AddUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, addUserSubscription, arg.UserID, arg.FeatureType, arg.ExpiresAt)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const checkLikeExists = `-- name: CheckLikeExists :one
SELECT EXISTS (
    SELECT 1 FROM likes
    WHERE liker_user_id = $1 AND liked_user_id = $2
)
`

type CheckLikeExistsParams struct {
	LikerUserID int32
	LikedUserID int32
}

func (q *Queries) CheckLikeExists(ctx context.Context, arg CheckLikeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLikeExists, arg.LikerUserID, arg.LikedUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkMutualLikeExists = `-- name: CheckMutualLikeExists :one
SELECT EXISTS (SELECT 1 FROM likes l1 WHERE l1.liker_user_id = $1 AND l1.liked_user_id = $2)
   AND EXISTS (SELECT 1 FROM likes l2 WHERE l2.liker_user_id = $2 AND l2.liked_user_id = $1)
`

type CheckMutualLikeExistsParams struct {
	LikerUserID int32
	LikedUserID int32
}

func (q *Queries) CheckMutualLikeExists(ctx context.Context, arg CheckMutualLikeExistsParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, checkMutualLikeExists, arg.LikerUserID, arg.LikedUserID)
	var column_1 pgtype.Bool
	err := row.Scan(&column_1)
	return column_1, err
}

const clearUserMediaURLs = `-- name: ClearUserMediaURLs :exec
UPDATE users
SET media_urls = '{}'
WHERE id = $1
`

// Removes all media URLs for a user.
func (q *Queries) ClearUserMediaURLs(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, clearUserMediaURLs, id)
	return err
}

const countRecentStandardLikes = `-- name: CountRecentStandardLikes :one
SELECT COUNT(*) FROM likes
WHERE liker_user_id = $1
  AND interaction_type = 'standard'
  AND created_at >= NOW() - INTERVAL '24 hours'
`

func (q *Queries) CountRecentStandardLikes(ctx context.Context, likerUserID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentStandardLikes, likerUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (
    sender_user_id,
    recipient_user_id,
    message_text,
    media_url,
    media_type
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, sender_user_id, recipient_user_id, message_text, media_url, media_type, sent_at, is_read
`

type CreateChatMessageParams struct {
	SenderUserID    int32
	RecipientUserID int32
	MessageText     pgtype.Text
	MediaUrl        pgtype.Text
	MediaType       pgtype.Text
}

// Chat Queries (from partner branch) --
func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.SenderUserID,
		arg.RecipientUserID,
		arg.MessageText,
		arg.MediaUrl,
		arg.MediaType,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SenderUserID,
		&i.RecipientUserID,
		&i.MessageText,
		&i.MediaUrl,
		&i.MediaType,
		&i.SentAt,
		&i.IsRead,
	)
	return i, err
}

const createDateVibesPrompt = `-- name: CreateDateVibesPrompt :one
INSERT INTO date_vibes_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateDateVibesPromptParams struct {
	UserID   int32
	Question DateVibesPromptType
	Answer   string
}

func (q *Queries) CreateDateVibesPrompt(ctx context.Context, arg CreateDateVibesPromptParams) (DateVibesPrompt, error) {
	row := q.db.QueryRow(ctx, createDateVibesPrompt, arg.UserID, arg.Question, arg.Answer)
	var i DateVibesPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createGettingPersonalPrompt = `-- name: CreateGettingPersonalPrompt :one
INSERT INTO getting_personal_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateGettingPersonalPromptParams struct {
	UserID   int32
	Question GettingPersonalPromptType
	Answer   string
}

func (q *Queries) CreateGettingPersonalPrompt(ctx context.Context, arg CreateGettingPersonalPromptParams) (GettingPersonalPrompt, error) {
	row := q.db.QueryRow(ctx, createGettingPersonalPrompt, arg.UserID, arg.Question, arg.Answer)
	var i GettingPersonalPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createMyTypePrompt = `-- name: CreateMyTypePrompt :one
INSERT INTO my_type_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateMyTypePromptParams struct {
	UserID   int32
	Question MyTypePromptType
	Answer   string
}

func (q *Queries) CreateMyTypePrompt(ctx context.Context, arg CreateMyTypePromptParams) (MyTypePrompt, error) {
	row := q.db.QueryRow(ctx, createMyTypePrompt, arg.UserID, arg.Question, arg.Answer)
	var i MyTypePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createReport = `-- name: CreateReport :one
INSERT INTO reports (
    reporter_user_id,
    reported_user_id,
    reason
) VALUES (
    $1, $2, $3
)
RETURNING id, reporter_user_id, reported_user_id, reason, created_at
`

type CreateReportParams struct {
	ReporterUserID int32
	ReportedUserID int32
	Reason         ReportReason
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (Report, error) {
	row := q.db.QueryRow(ctx, createReport, arg.ReporterUserID, arg.ReportedUserID, arg.Reason)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.ReporterUserID,
		&i.ReportedUserID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const createStoryTimePrompt = `-- name: CreateStoryTimePrompt :one
INSERT INTO story_time_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateStoryTimePromptParams struct {
	UserID   int32
	Question StoryTimePromptType
	Answer   string
}

func (q *Queries) CreateStoryTimePrompt(ctx context.Context, arg CreateStoryTimePromptParams) (StoryTimePrompt, error) {
	row := q.db.QueryRow(ctx, createStoryTimePrompt, arg.UserID, arg.Question, arg.Answer)
	var i StoryTimePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createUserWithEmail = `-- name: CreateUserWithEmail :one
INSERT INTO users (
    email
) VALUES (
    $1
)
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

// Creates a new user with only their email address initially.
func (q *Queries) CreateUserWithEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const decrementUserConsumable = `-- name: DecrementUserConsumable :one

UPDATE user_consumables
SET quantity = quantity - 1,
    updated_at = NOW()
WHERE user_id = $1
  AND consumable_type = $2 -- e.g., 'rose'
  AND quantity > 0
RETURNING user_id, consumable_type, quantity, updated_at
`

type DecrementUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

// e.g., 'rose'
func (q *Queries) DecrementUserConsumable(ctx context.Context, arg DecrementUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, decrementUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLikesBetweenUsers = `-- name: DeleteLikesBetweenUsers :exec
DELETE FROM likes
WHERE (liker_user_id = $1 AND liked_user_id = $2)
   OR (liker_user_id = $2 AND liked_user_id = $1)
`

type DeleteLikesBetweenUsersParams struct {
	LikerUserID int32
	LikedUserID int32
}

func (q *Queries) DeleteLikesBetweenUsers(ctx context.Context, arg DeleteLikesBetweenUsersParams) error {
	_, err := q.db.Exec(ctx, deleteLikesBetweenUsers, arg.LikerUserID, arg.LikedUserID)
	return err
}

const deleteUserDateVibesPrompts = `-- name: DeleteUserDateVibesPrompts :exec
DELETE FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserDateVibesPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserDateVibesPrompts, userID)
	return err
}

const deleteUserGettingPersonalPrompts = `-- name: DeleteUserGettingPersonalPrompts :exec
DELETE FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserGettingPersonalPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserGettingPersonalPrompts, userID)
	return err
}

const deleteUserMyTypePrompts = `-- name: DeleteUserMyTypePrompts :exec
DELETE FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserMyTypePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserMyTypePrompts, userID)
	return err
}

const deleteUserStoryTimePrompts = `-- name: DeleteUserStoryTimePrompts :exec
DELETE FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserStoryTimePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserStoryTimePrompts, userID)
	return err
}

const getActiveSubscription = `-- name: GetActiveSubscription :one
SELECT id, user_id, feature_type, activated_at, expires_at, created_at FROM user_subscriptions
WHERE user_id = $1
  AND feature_type = $2 -- e.g., 'unlimited_likes'
  AND expires_at > NOW()
LIMIT 1
`

type GetActiveSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
}

func (q *Queries) GetActiveSubscription(ctx context.Context, arg GetActiveSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, getActiveSubscription, arg.UserID, arg.FeatureType)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT id, sender_user_id, recipient_user_id, message_text, media_url, media_type, sent_at, is_read FROM chat_messages
WHERE (sender_user_id = $1 AND recipient_user_id = $2)
   OR (sender_user_id = $2 AND recipient_user_id = $1)
ORDER BY sent_at ASC
`

type GetConversationMessagesParams struct {
	SenderUserID    int32
	RecipientUserID int32
}

func (q *Queries) GetConversationMessages(ctx context.Context, arg GetConversationMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, arg.SenderUserID, arg.RecipientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.SenderUserID,
			&i.RecipientUserID,
			&i.MessageText,
			&i.MediaUrl,
			&i.MediaType,
			&i.SentAt,
			&i.IsRead,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHomeFeed = `-- name: GetHomeFeed :many
WITH RequestingUser AS (
    SELECT
        u.id, u.latitude, u.longitude, u.gender, u.date_of_birth, u.spotlight_active_until
    FROM users u WHERE u.id = $1
), RequestingUserFilters AS (
    SELECT
        f.user_id, f.who_you_want_to_see, f.radius_km, f.active_today, f.age_min, f.age_max
    FROM filters f WHERE f.user_id = $1
), AllPrompts AS (
    -- Combine all prompts for all users into a single structure with category
    SELECT user_id, 'storyTime' as category, question::text, answer FROM story_time_prompts
    UNION ALL
    SELECT user_id, 'myType' as category, question::text, answer FROM my_type_prompts
    UNION ALL
    SELECT user_id, 'gettingPersonal' as category, question::text, answer FROM getting_personal_prompts
    UNION ALL
    SELECT user_id, 'dateVibes' as category, question::text, answer FROM date_vibes_prompts
), AggregatedPrompts AS (
    -- Aggregate combined prompts into a JSONB array for each user
    SELECT
        user_id,
        jsonb_agg(jsonb_build_object('category', category, 'question', question, 'answer', answer)) as prompts
    FROM AllPrompts
    GROUP BY user_id
)
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.email, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer, target_user.spotlight_active_until, -- Select all columns from the users table
    -- Aggregate prompts for the target user, default to empty array if none
    COALESCE(ap.prompts, '[]'::jsonb) as prompts,
    -- Calculate distance
    haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
JOIN RequestingUser ru ON target_user.id != ru.id
JOIN RequestingUserFilters rf ON ru.id = rf.user_id
LEFT JOIN filters AS target_user_filters ON target_user.id = target_user_filters.user_id
LEFT JOIN AggregatedPrompts ap ON target_user.id = ap.user_id -- Join with aggregated prompts
WHERE
    target_user.latitude IS NOT NULL AND target_user.longitude IS NOT NULL -- Ensure target has location
    AND ru.latitude IS NOT NULL AND ru.longitude IS NOT NULL             -- Ensure requesting user has location
    AND ru.gender IS NOT NULL                                             -- Ensure requesting user has gender set
    AND rf.who_you_want_to_see IS NOT NULL                                -- Ensure filter preference is set
    AND rf.age_min IS NOT NULL AND rf.age_max IS NOT NULL                 -- Ensure age filters are set
    AND (rf.radius_km IS NULL OR haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) <= rf.radius_km)
    AND target_user.gender = rf.who_you_want_to_see -- Target gender matches filter
    AND (target_user_filters.user_id IS NULL OR target_user_filters.who_you_want_to_see IS NULL OR target_user_filters.who_you_want_to_see = ru.gender) -- Target preferences allow requesting user's gender
    AND target_user.date_of_birth IS NOT NULL
    AND EXTRACT(YEAR FROM AGE(target_user.date_of_birth)) BETWEEN rf.age_min AND rf.age_max
    AND (NOT rf.active_today OR EXISTS (
            SELECT 1 FROM app_open_logs aol
            WHERE aol.user_id = target_user.id AND aol.opened_at >= NOW() - INTERVAL '24 hours'
        ))
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = ru.id AND d.disliked_user_id = target_user.id)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = target_user.id AND d.disliked_user_id = ru.id)
    AND NOT EXISTS (SELECT 1 FROM likes l WHERE l.liker_user_id = ru.id AND l.liked_user_id = target_user.id)
ORDER BY
    CASE WHEN target_user.spotlight_active_until > NOW() THEN 0 ELSE 1 END ASC, -- Spotlight users first
    distance_km ASC,
    -- Use age difference calculation only if requesting user DOB is set
    CASE WHEN ru.date_of_birth IS NOT NULL THEN
      ABS(EXTRACT(YEAR FROM AGE(ru.date_of_birth)) - EXTRACT(YEAR FROM AGE(target_user.date_of_birth)))
    ELSE
      NULL -- Or some other default ordering if DOB is missing
    END ASC NULLS LAST
LIMIT $2
`

type GetHomeFeedParams struct {
	ID    int32
	Limit int32
}

type GetHomeFeedRow struct {
	ID                   int32
	CreatedAt            pgtype.Timestamptz
	Name                 pgtype.Text
	LastName             pgtype.Text
	Email                string
	DateOfBirth          pgtype.Date
	Latitude             pgtype.Float8
	Longitude            pgtype.Float8
	Gender               NullGenderEnum
	DatingIntention      NullDatingIntention
	Height               pgtype.Float8
	Hometown             pgtype.Text
	JobTitle             pgtype.Text
	Education            pgtype.Text
	ReligiousBeliefs     NullReligion
	DrinkingHabit        NullDrinkingSmokingHabits
	SmokingHabit         NullDrinkingSmokingHabits
	MediaUrls            []string
	VerificationStatus   VerificationStatus
	VerificationPic      pgtype.Text
	Role                 UserRole
	AudioPromptQuestion  NullAudioPrompt
	AudioPromptAnswer    pgtype.Text
	SpotlightActiveUntil pgtype.Timestamptz
	Prompts              []byte
	DistanceKm           float64
}

// Retrieves the main feed based on user filters and location.
// *** MODIFIED TO INCLUDE PROMPTS ***
func (q *Queries) GetHomeFeed(ctx context.Context, arg GetHomeFeedParams) ([]GetHomeFeedRow, error) {
	rows, err := q.db.Query(ctx, getHomeFeed, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHomeFeedRow
	for rows.Next() {
		var i GetHomeFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.Prompts,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikeDetails = `-- name: GetLikeDetails :one

SELECT
    comment,
    interaction_type
FROM likes
WHERE liker_user_id = $1 -- The user who sent the like
AND liked_user_id = $2   -- The user who received the like (current user)
LIMIT 1
`

type GetLikeDetailsParams struct {
	LikerUserID int32
	LikedUserID int32
}

type GetLikeDetailsRow struct {
	Comment         pgtype.Text
	InteractionType LikeInteractionType
}

// Then by time
func (q *Queries) GetLikeDetails(ctx context.Context, arg GetLikeDetailsParams) (GetLikeDetailsRow, error) {
	row := q.db.QueryRow(ctx, getLikeDetails, arg.LikerUserID, arg.LikedUserID)
	var i GetLikeDetailsRow
	err := row.Scan(&i.Comment, &i.InteractionType)
	return i, err
}

const getLikersForUser = `-- name: GetLikersForUser :many
SELECT
    l.liker_user_id,
    l.comment,
    l.interaction_type,
    l.created_at as liked_at,
    u.name,
    u.last_name,
    u.media_urls
FROM likes l
JOIN users u ON l.liker_user_id = u.id
WHERE l.liked_user_id = $1 -- The user receiving the likes (current user)
ORDER BY
    (l.interaction_type = 'rose') DESC, -- Roses first
    l.created_at DESC
`

type GetLikersForUserRow struct {
	LikerUserID     int32
	Comment         pgtype.Text
	InteractionType LikeInteractionType
	LikedAt         pgtype.Timestamptz
	Name            pgtype.Text
	LastName        pgtype.Text
	MediaUrls       []string
}

func (q *Queries) GetLikersForUser(ctx context.Context, likedUserID int32) ([]GetLikersForUserRow, error) {
	rows, err := q.db.Query(ctx, getLikersForUser, likedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLikersForUserRow
	for rows.Next() {
		var i GetLikersForUserRow
		if err := rows.Scan(
			&i.LikerUserID,
			&i.Comment,
			&i.InteractionType,
			&i.LikedAt,
			&i.Name,
			&i.LastName,
			&i.MediaUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesWithLastMessage = `-- name: GetMatchesWithLastMessage :many
SELECT
    target_user.id AS matched_user_id,
    target_user.name AS matched_user_name,
    target_user.last_name AS matched_user_last_name,
    target_user.media_urls AS matched_user_media_urls,
    COALESCE(last_msg.message_text, '') AS last_message_text,
    last_msg.media_type AS last_message_media_type,
    last_msg.media_url AS last_message_media_url,
    last_msg.sent_at AS last_message_sent_at,
    COALESCE(last_msg.sender_user_id, 0) AS last_message_sender_id,
    (
        SELECT COUNT(*)
        FROM chat_messages cm_unread
        WHERE cm_unread.recipient_user_id = l1.liker_user_id
          AND cm_unread.sender_user_id = l1.liked_user_id
          AND cm_unread.is_read = false
    ) AS unread_message_count
FROM
    likes l1
JOIN
    users target_user ON l1.liked_user_id = target_user.id
JOIN
    likes l2 ON l1.liked_user_id = l2.liker_user_id AND l1.liker_user_id = l2.liked_user_id
LEFT JOIN LATERAL (
    SELECT
        cm.message_text,
        cm.media_type,
        cm.media_url,
        cm.sent_at,
        cm.sender_user_id
    FROM
        chat_messages cm
    WHERE
        (cm.sender_user_id = l1.liker_user_id AND cm.recipient_user_id = l1.liked_user_id)
        OR (cm.sender_user_id = l1.liked_user_id AND cm.recipient_user_id = l1.liker_user_id)
    ORDER BY
        cm.sent_at DESC
    LIMIT 1
) last_msg ON true
WHERE
    l1.liker_user_id = $1
ORDER BY
    last_msg.sent_at DESC NULLS LAST,
    target_user.id
`

type GetMatchesWithLastMessageRow struct {
	MatchedUserID        int32
	MatchedUserName      pgtype.Text
	MatchedUserLastName  pgtype.Text
	MatchedUserMediaUrls []string
	LastMessageText      string
	LastMessageMediaType pgtype.Text
	LastMessageMediaUrl  pgtype.Text
	LastMessageSentAt    pgtype.Timestamptz
	LastMessageSenderID  int32
	UnreadMessageCount   int64
}

func (q *Queries) GetMatchesWithLastMessage(ctx context.Context, likerUserID int32) ([]GetMatchesWithLastMessageRow, error) {
	rows, err := q.db.Query(ctx, getMatchesWithLastMessage, likerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchesWithLastMessageRow
	for rows.Next() {
		var i GetMatchesWithLastMessageRow
		if err := rows.Scan(
			&i.MatchedUserID,
			&i.MatchedUserName,
			&i.MatchedUserLastName,
			&i.MatchedUserMediaUrls,
			&i.LastMessageText,
			&i.LastMessageMediaType,
			&i.LastMessageMediaUrl,
			&i.LastMessageSentAt,
			&i.LastMessageSenderID,
			&i.UnreadMessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingVerificationUsers = `-- name: GetPendingVerificationUsers :many
SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE verification_status = $1
`

// Fetches users whose verification status is 'pending'.
func (q *Queries) GetPendingVerificationUsers(ctx context.Context, verificationStatus VerificationStatus) ([]User, error) {
	rows, err := q.db.Query(ctx, getPendingVerificationUsers, verificationStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuickFeed = `-- name: GetQuickFeed :many
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.email, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer, target_user.spotlight_active_until,
    haversine($1, $2, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
WHERE
      target_user.id != $3 -- Exclude self
  AND target_user.latitude IS NOT NULL
  AND target_user.longitude IS NOT NULL
  AND target_user.gender = $4 -- Filter by the OPPOSITE gender passed as param
  AND target_user.name IS NOT NULL AND target_user.name != '' -- Basic profile check
  AND target_user.date_of_birth IS NOT NULL                  -- Basic profile check
ORDER BY
    distance_km ASC
LIMIT $5
`

type GetQuickFeedParams struct {
	Lat1   float64
	Lon1   float64
	ID     int32
	Gender NullGenderEnum
	Limit  int32
}

type GetQuickFeedRow struct {
	ID                   int32
	CreatedAt            pgtype.Timestamptz
	Name                 pgtype.Text
	LastName             pgtype.Text
	Email                string
	DateOfBirth          pgtype.Date
	Latitude             pgtype.Float8
	Longitude            pgtype.Float8
	Gender               NullGenderEnum
	DatingIntention      NullDatingIntention
	Height               pgtype.Float8
	Hometown             pgtype.Text
	JobTitle             pgtype.Text
	Education            pgtype.Text
	ReligiousBeliefs     NullReligion
	DrinkingHabit        NullDrinkingSmokingHabits
	SmokingHabit         NullDrinkingSmokingHabits
	MediaUrls            []string
	VerificationStatus   VerificationStatus
	VerificationPic      pgtype.Text
	Role                 UserRole
	AudioPromptQuestion  NullAudioPrompt
	AudioPromptAnswer    pgtype.Text
	SpotlightActiveUntil pgtype.Timestamptz
	DistanceKm           float64
}

// Param $2 is the feed batch size (e.g., 15)
// Retrieves a small feed based purely on proximity and opposite gender.
// Parameters: $1=latitude, $2=longitude (of requesting user), $3=requesting_user_id, $4=gender_to_show, $5=limit
func (q *Queries) GetQuickFeed(ctx context.Context, arg GetQuickFeedParams) ([]GetQuickFeedRow, error) {
	rows, err := q.db.Query(ctx, getQuickFeed,
		arg.Lat1,
		arg.Lon1,
		arg.ID,
		arg.Gender,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuickFeedRow
	for rows.Next() {
		var i GetQuickFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAudioPrompt = `-- name: GetUserAudioPrompt :one
SELECT id, audio_prompt_question, audio_prompt_answer
FROM users
WHERE id = $1 LIMIT 1
`

type GetUserAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) GetUserAudioPrompt(ctx context.Context, id int32) (GetUserAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, getUserAudioPrompt, id)
	var i GetUserAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE id = $1 LIMIT 1
`

// FILE: db/queries.sql (Resolved)
func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const getUserConsumable = `-- name: GetUserConsumable :one
SELECT user_id, consumable_type, quantity, updated_at FROM user_consumables
WHERE user_id = $1
  AND consumable_type = $2
`

type GetUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

func (q *Queries) GetUserConsumable(ctx context.Context, arg GetUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, getUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDateVibesPrompts = `-- name: GetUserDateVibesPrompts :many
SELECT id, user_id, question, answer FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) GetUserDateVibesPrompts(ctx context.Context, userID int32) ([]DateVibesPrompt, error) {
	rows, err := q.db.Query(ctx, getUserDateVibesPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DateVibesPrompt
	for rows.Next() {
		var i DateVibesPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFilters = `-- name: GetUserFilters :one
SELECT user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at FROM filters
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserFilters(ctx context.Context, userID int32) (Filter, error) {
	row := q.db.QueryRow(ctx, getUserFilters, userID)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserGettingPersonalPrompts = `-- name: GetUserGettingPersonalPrompts :many
SELECT id, user_id, question, answer FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) GetUserGettingPersonalPrompts(ctx context.Context, userID int32) ([]GettingPersonalPrompt, error) {
	rows, err := q.db.Query(ctx, getUserGettingPersonalPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GettingPersonalPrompt
	for rows.Next() {
		var i GettingPersonalPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMyTypePrompts = `-- name: GetUserMyTypePrompts :many
SELECT id, user_id, question, answer FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) GetUserMyTypePrompts(ctx context.Context, userID int32) ([]MyTypePrompt, error) {
	rows, err := q.db.Query(ctx, getUserMyTypePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyTypePrompt
	for rows.Next() {
		var i MyTypePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryTimePrompts = `-- name: GetUserStoryTimePrompts :many
SELECT id, user_id, question, answer FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) GetUserStoryTimePrompts(ctx context.Context, userID int32) ([]StoryTimePrompt, error) {
	rows, err := q.db.Query(ctx, getUserStoryTimePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StoryTimePrompt
	for rows.Next() {
		var i StoryTimePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logAppOpen = `-- name: LogAppOpen :exec
INSERT INTO app_open_logs (user_id)
VALUES ($1)
`

func (q *Queries) LogAppOpen(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, logAppOpen, userID)
	return err
}

const markMessagesAsReadUntil = `-- name: MarkMessagesAsReadUntil :execresult
UPDATE chat_messages
SET is_read = true
WHERE recipient_user_id = $1
  AND sender_user_id = $2
  AND id <= $3
  AND is_read = false
`

type MarkMessagesAsReadUntilParams struct {
	RecipientUserID int32
	SenderUserID    int32
	ID              int64
}

func (q *Queries) MarkMessagesAsReadUntil(ctx context.Context, arg MarkMessagesAsReadUntilParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, markMessagesAsReadUntil, arg.RecipientUserID, arg.SenderUserID, arg.ID)
}

const updateAudioPrompt = `-- name: UpdateAudioPrompt :one
UPDATE users
SET audio_prompt_question = $1, audio_prompt_answer = $2
WHERE id = $3
RETURNING id, audio_prompt_question, audio_prompt_answer
`

type UpdateAudioPromptParams struct {
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
	ID                  int32
}

type UpdateAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) UpdateAudioPrompt(ctx context.Context, arg UpdateAudioPromptParams) (UpdateAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, updateAudioPrompt, arg.AudioPromptQuestion, arg.AudioPromptAnswer, arg.ID)
	var i UpdateAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const updateUserLocationGender = `-- name: UpdateUserLocationGender :one
UPDATE users SET
    latitude = $1,
    longitude = $2,
    gender = $3
WHERE id = $4
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserLocationGenderParams struct {
	Latitude  pgtype.Float8
	Longitude pgtype.Float8
	Gender    NullGenderEnum
	ID        int32
}

// Updates only the user's latitude, longitude, and gender.
func (q *Queries) UpdateUserLocationGender(ctx context.Context, arg UpdateUserLocationGenderParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserLocationGender,
		arg.Latitude,
		arg.Longitude,
		arg.Gender,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserMediaURLs = `-- name: UpdateUserMediaURLs :exec
UPDATE users
SET media_urls = $1
WHERE id = $2
`

type UpdateUserMediaURLsParams struct {
	MediaUrls []string
	ID        int32
}

// Sets the media URLs for a user, replacing any existing ones.
func (q *Queries) UpdateUserMediaURLs(ctx context.Context, arg UpdateUserMediaURLsParams) error {
	_, err := q.db.Exec(ctx, updateUserMediaURLs, arg.MediaUrls, arg.ID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one

UPDATE users SET
    name = $1,                -- param $1
    last_name = $2,           -- param $2
    date_of_birth = $3,       -- param $3
    dating_intention = $4,    -- param $4
    height = $5,              -- param $5
    hometown = $6,            -- param $6
    job_title = $7,           -- param $7
    education = $8,           -- param $8
    religious_beliefs = $9,   -- param $9
    drinking_habit = $10,     -- param $10
    smoking_habit = $11       -- param $11
WHERE id = $12                -- param $12
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserProfileParams struct {
	Name             pgtype.Text
	LastName         pgtype.Text
	DateOfBirth      pgtype.Date
	DatingIntention  NullDatingIntention
	Height           pgtype.Float8
	Hometown         pgtype.Text
	JobTitle         pgtype.Text
	Education        pgtype.Text
	ReligiousBeliefs NullReligion
	DrinkingHabit    NullDrinkingSmokingHabits
	SmokingHabit     NullDrinkingSmokingHabits
	ID               int32
}

// $1 should be 'pending'
// Updates the main profile details, EXCLUDING location and gender.
// Parameter indexes adjusted after removing location/gender params.
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.Name,
		arg.LastName,
		arg.DateOfBirth,
		arg.DatingIntention,
		arg.Height,
		arg.Hometown,
		arg.JobTitle,
		arg.Education,
		arg.ReligiousBeliefs,
		arg.DrinkingHabit,
		arg.SmokingHabit,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET role = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserRoleParams struct {
	Role UserRole
	ID   int32
}

// Updates the user's role (e.g., to 'admin' or 'user').
func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserVerificationDetails = `-- name: UpdateUserVerificationDetails :one
UPDATE users
SET
    verification_pic = $1,
    verification_status = $2
WHERE id = $3
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserVerificationDetailsParams struct {
	VerificationPic    pgtype.Text
	VerificationStatus VerificationStatus
	ID                 int32
}

// Updates the verification picture URL and status together.
func (q *Queries) UpdateUserVerificationDetails(ctx context.Context, arg UpdateUserVerificationDetailsParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationDetails, arg.VerificationPic, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :one
UPDATE users
SET verification_status = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserVerificationStatusParams struct {
	VerificationStatus VerificationStatus
	ID                 int32
}

// Updates the verification status ('true', 'false', 'pending').
func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationStatus, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const upsertUserConsumable = `-- name: UpsertUserConsumable :one
INSERT INTO user_consumables (user_id, consumable_type, quantity)
VALUES ($1, $2, $3) -- $3 is the quantity to add
ON CONFLICT (user_id, consumable_type) DO UPDATE
SET quantity = user_consumables.quantity + EXCLUDED.quantity,
    updated_at = NOW()
RETURNING user_id, consumable_type, quantity, updated_at
`

type UpsertUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
	Quantity       int32
}

func (q *Queries) UpsertUserConsumable(ctx context.Context, arg UpsertUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, upsertUserConsumable, arg.UserID, arg.ConsumableType, arg.Quantity)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserFilters = `-- name: UpsertUserFilters :one
INSERT INTO filters (
    user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (user_id) DO UPDATE SET
    who_you_want_to_see = EXCLUDED.who_you_want_to_see,
    radius_km = EXCLUDED.radius_km,
    active_today = EXCLUDED.active_today,
    age_min = EXCLUDED.age_min,
    age_max = EXCLUDED.age_max,
    updated_at = NOW()
RETURNING user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at
`

type UpsertUserFiltersParams struct {
	UserID          int32
	WhoYouWantToSee NullGenderEnum
	RadiusKm        pgtype.Int4
	ActiveToday     bool
	AgeMin          pgtype.Int4
	AgeMax          pgtype.Int4
}

func (q *Queries) UpsertUserFilters(ctx context.Context, arg UpsertUserFiltersParams) (Filter, error) {
	row := q.db.QueryRow(ctx, upsertUserFilters,
		arg.UserID,
		arg.WhoYouWantToSee,
		arg.RadiusKm,
		arg.ActiveToday,
		arg.AgeMin,
		arg.AgeMax,
	)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package migrations

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addContentLike = `-- name: AddContentLike :one
INSERT INTO likes (
    liker_user_id,
    liked_user_id,
    content_type,
    content_identifier,
    comment,
    interaction_type
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (liker_user_id, liked_user_id, content_type, content_identifier)
DO NOTHING
RETURNING id, liker_user_id, liked_user_id, content_type, content_identifier, comment, interaction_type, created_at
`

type AddContentLikeParams struct {
	LikerUserID       int32
	LikedUserID       int32
	ContentType       ContentLikeType
	ContentIdentifier string
	Comment           pgtype.Text
	InteractionType   LikeInteractionType
}

func (q *Queries) AddContentLike(ctx context.Context, arg AddContentLikeParams) (Like, error) {
	row := q.db.QueryRow(ctx, addContentLike,
		arg.LikerUserID,
		arg.LikedUserID,
		arg.ContentType,
		arg.ContentIdentifier,
		arg.Comment,
		arg.InteractionType,
	)
	var i Like
	err := row.Scan(
		&i.ID,
		&i.LikerUserID,
		&i.LikedUserID,
		&i.ContentType,
		&i.ContentIdentifier,
		&i.Comment,
		&i.InteractionType,
		&i.CreatedAt,
	)
	return i, err
}

const addDislike = `-- name: AddDislike :exec
INSERT INTO dislikes (disliker_user_id, disliked_user_id)
VALUES ($1, $2)
ON CONFLICT (disliker_user_id, disliked_user_id) DO NOTHING
`

type AddDislikeParams struct {
	DislikerUserID int32
	DislikedUserID int32
}

func (q *Queries) AddDislike(ctx context.Context, arg AddDislikeParams) error {
	_, err := q.db.Exec(ctx, addDislike, arg.DislikerUserID, arg.DislikedUserID)
	return err
}

const addUserSubscription = `-- name: AddUserSubscription :one
INSERT INTO user_subscriptions (
    user_id, feature_type, expires_at, activated_at
) VALUES (
    $1, $2, $3, NOW()
)
RETURNING id, user_id, feature_type, activated_at, expires_at, created_at
`

type AddUserSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
	ExpiresAt   pgtype.Timestamptz
}

func (q *Queries) AddUserSubscription(ctx context.Context, arg AddUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, addUserSubscription, arg.UserID, arg.FeatureType, arg.ExpiresAt)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const clearUserMediaURLs = `-- name: ClearUserMediaURLs :exec
UPDATE users
SET media_urls = '{}'
WHERE id = $1
`

// Removes all media URLs for a user.
func (q *Queries) ClearUserMediaURLs(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, clearUserMediaURLs, id)
	return err
}

const countRecentStandardLikes = `-- name: CountRecentStandardLikes :one
SELECT COUNT(*) FROM likes
WHERE liker_user_id = $1
  AND interaction_type = 'standard'
  AND created_at >= NOW() - INTERVAL '24 hours'
`

func (q *Queries) CountRecentStandardLikes(ctx context.Context, likerUserID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentStandardLikes, likerUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDateVibesPrompt = `-- name: CreateDateVibesPrompt :one
INSERT INTO date_vibes_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateDateVibesPromptParams struct {
	UserID   int32
	Question DateVibesPromptType
	Answer   string
}

func (q *Queries) CreateDateVibesPrompt(ctx context.Context, arg CreateDateVibesPromptParams) (DateVibesPrompt, error) {
	row := q.db.QueryRow(ctx, createDateVibesPrompt, arg.UserID, arg.Question, arg.Answer)
	var i DateVibesPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createGettingPersonalPrompt = `-- name: CreateGettingPersonalPrompt :one
INSERT INTO getting_personal_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateGettingPersonalPromptParams struct {
	UserID   int32
	Question GettingPersonalPromptType
	Answer   string
}

func (q *Queries) CreateGettingPersonalPrompt(ctx context.Context, arg CreateGettingPersonalPromptParams) (GettingPersonalPrompt, error) {
	row := q.db.QueryRow(ctx, createGettingPersonalPrompt, arg.UserID, arg.Question, arg.Answer)
	var i GettingPersonalPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createMyTypePrompt = `-- name: CreateMyTypePrompt :one
INSERT INTO my_type_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateMyTypePromptParams struct {
	UserID   int32
	Question MyTypePromptType
	Answer   string
}

func (q *Queries) CreateMyTypePrompt(ctx context.Context, arg CreateMyTypePromptParams) (MyTypePrompt, error) {
	row := q.db.QueryRow(ctx, createMyTypePrompt, arg.UserID, arg.Question, arg.Answer)
	var i MyTypePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createStoryTimePrompt = `-- name: CreateStoryTimePrompt :one
INSERT INTO story_time_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateStoryTimePromptParams struct {
	UserID   int32
	Question StoryTimePromptType
	Answer   string
}

func (q *Queries) CreateStoryTimePrompt(ctx context.Context, arg CreateStoryTimePromptParams) (StoryTimePrompt, error) {
	row := q.db.QueryRow(ctx, createStoryTimePrompt, arg.UserID, arg.Question, arg.Answer)
	var i StoryTimePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createUserWithEmail = `-- name: CreateUserWithEmail :one
INSERT INTO users (
    email
) VALUES (
    $1
)
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

// Creates a new user with only their email address initially.
func (q *Queries) CreateUserWithEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const decrementUserConsumable = `-- name: DecrementUserConsumable :one

UPDATE user_consumables
SET quantity = quantity - 1,
    updated_at = NOW()
WHERE user_id = $1
  AND consumable_type = $2 -- e.g., 'rose'
  AND quantity > 0
RETURNING user_id, consumable_type, quantity, updated_at
`

type DecrementUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

// e.g., 'rose'
func (q *Queries) DecrementUserConsumable(ctx context.Context, arg DecrementUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, decrementUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserDateVibesPrompts = `-- name: DeleteUserDateVibesPrompts :exec
DELETE FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserDateVibesPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserDateVibesPrompts, userID)
	return err
}

const deleteUserGettingPersonalPrompts = `-- name: DeleteUserGettingPersonalPrompts :exec
DELETE FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserGettingPersonalPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserGettingPersonalPrompts, userID)
	return err
}

const deleteUserMyTypePrompts = `-- name: DeleteUserMyTypePrompts :exec
DELETE FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserMyTypePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserMyTypePrompts, userID)
	return err
}

const deleteUserStoryTimePrompts = `-- name: DeleteUserStoryTimePrompts :exec
DELETE FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserStoryTimePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserStoryTimePrompts, userID)
	return err
}

const getActiveSubscription = `-- name: GetActiveSubscription :one
SELECT id, user_id, feature_type, activated_at, expires_at, created_at FROM user_subscriptions
WHERE user_id = $1
  AND feature_type = $2 -- e.g., 'unlimited_likes'
  AND expires_at > NOW()
LIMIT 1
`

type GetActiveSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
}

func (q *Queries) GetActiveSubscription(ctx context.Context, arg GetActiveSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, getActiveSubscription, arg.UserID, arg.FeatureType)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getHomeFeed = `-- name: GetHomeFeed :many
WITH RequestingUser AS (
    SELECT
        u.id, u.latitude, u.longitude, u.gender, u.date_of_birth, u.spotlight_active_until
    FROM users u WHERE u.id = $1
), RequestingUserFilters AS (
    SELECT
        f.user_id, f.who_you_want_to_see, f.radius_km, f.active_today, f.age_min, f.age_max
    FROM filters f WHERE f.user_id = $1
)
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.email, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer, target_user.spotlight_active_until,
    haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
JOIN RequestingUser ru ON target_user.id != ru.id
JOIN RequestingUserFilters rf ON ru.id = rf.user_id
LEFT JOIN filters AS target_user_filters ON target_user.id = target_user_filters.user_id
WHERE
    target_user.latitude IS NOT NULL AND target_user.longitude IS NOT NULL -- Ensure target has location
    AND ru.latitude IS NOT NULL AND ru.longitude IS NOT NULL             -- Ensure requesting user has location
    AND ru.gender IS NOT NULL                                             -- Ensure requesting user has gender set
    AND rf.who_you_want_to_see IS NOT NULL                                -- Ensure filter preference is set
    AND rf.age_min IS NOT NULL AND rf.age_max IS NOT NULL                 -- Ensure age filters are set
    AND (rf.radius_km IS NULL OR haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) <= rf.radius_km)
    AND target_user.gender = rf.who_you_want_to_see -- Target gender matches filter
    AND (target_user_filters.user_id IS NULL OR target_user_filters.who_you_want_to_see IS NULL OR target_user_filters.who_you_want_to_see = ru.gender) -- Target preferences allow requesting user's gender
    AND target_user.date_of_birth IS NOT NULL
    AND EXTRACT(YEAR FROM AGE(target_user.date_of_birth)) BETWEEN rf.age_min AND rf.age_max
    AND (NOT rf.active_today OR EXISTS (
            SELECT 1 FROM app_open_logs aol
            WHERE aol.user_id = target_user.id AND aol.opened_at >= NOW() - INTERVAL '24 hours'
        ))
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = ru.id AND d.disliked_user_id = target_user.id)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = target_user.id AND d.disliked_user_id = ru.id)
    AND NOT EXISTS (SELECT 1 FROM likes l WHERE l.liker_user_id = ru.id AND l.liked_user_id = target_user.id)
ORDER BY
    CASE WHEN target_user.spotlight_active_until > NOW() THEN 0 ELSE 1 END ASC, -- Spotlight users first
    distance_km ASC,
    -- Use age difference calculation only if requesting user DOB is set
    CASE WHEN ru.date_of_birth IS NOT NULL THEN
      ABS(EXTRACT(YEAR FROM AGE(ru.date_of_birth)) - EXTRACT(YEAR FROM AGE(target_user.date_of_birth)))
    ELSE
      NULL -- Or some other default ordering if DOB is missing
    END ASC NULLS LAST
LIMIT $2
`

type GetHomeFeedParams struct {
	ID    int32
	Limit int32
}

type GetHomeFeedRow struct {
	ID                   int32
	CreatedAt            pgtype.Timestamptz
	Name                 pgtype.Text
	LastName             pgtype.Text
	Email                string
	DateOfBirth          pgtype.Date
	Latitude             pgtype.Float8
	Longitude            pgtype.Float8
	Gender               NullGenderEnum
	DatingIntention      NullDatingIntention
	Height               pgtype.Float8
	Hometown             pgtype.Text
	JobTitle             pgtype.Text
	Education            pgtype.Text
	ReligiousBeliefs     NullReligion
	DrinkingHabit        NullDrinkingSmokingHabits
	SmokingHabit         NullDrinkingSmokingHabits
	MediaUrls            []string
	VerificationStatus   VerificationStatus
	VerificationPic      pgtype.Text
	Role                 UserRole
	AudioPromptQuestion  NullAudioPrompt
	AudioPromptAnswer    pgtype.Text
	SpotlightActiveUntil pgtype.Timestamptz
	DistanceKm           float64
}

// Retrieves the main feed based on user filters and location.
func (q *Queries) GetHomeFeed(ctx context.Context, arg GetHomeFeedParams) ([]GetHomeFeedRow, error) {
	rows, err := q.db.Query(ctx, getHomeFeed, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHomeFeedRow
	for rows.Next() {
		var i GetHomeFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikeDetails = `-- name: GetLikeDetails :one

SELECT
    comment,
    interaction_type
FROM likes
WHERE liker_user_id = $1 -- The user who sent the like
AND liked_user_id = $2   -- The user who received the like (current user)
LIMIT 1
`

type GetLikeDetailsParams struct {
	LikerUserID int32
	LikedUserID int32
}

type GetLikeDetailsRow struct {
	Comment         pgtype.Text
	InteractionType LikeInteractionType
}

// Then by time
func (q *Queries) GetLikeDetails(ctx context.Context, arg GetLikeDetailsParams) (GetLikeDetailsRow, error) {
	row := q.db.QueryRow(ctx, getLikeDetails, arg.LikerUserID, arg.LikedUserID)
	var i GetLikeDetailsRow
	err := row.Scan(&i.Comment, &i.InteractionType)
	return i, err
}

const getLikersForUser = `-- name: GetLikersForUser :many
SELECT
    l.liker_user_id,
    l.comment,
    l.interaction_type,
    l.created_at as liked_at,
    u.name,
    u.last_name,
    u.media_urls
FROM likes l
JOIN users u ON l.liker_user_id = u.id
WHERE l.liked_user_id = $1 -- The user receiving the likes (current user)
ORDER BY
    (l.interaction_type = 'rose') DESC, -- Roses first
    l.created_at DESC
`

type GetLikersForUserRow struct {
	LikerUserID     int32
	Comment         pgtype.Text
	InteractionType LikeInteractionType
	LikedAt         pgtype.Timestamptz
	Name            pgtype.Text
	LastName        pgtype.Text
	MediaUrls       []string
}

func (q *Queries) GetLikersForUser(ctx context.Context, likedUserID int32) ([]GetLikersForUserRow, error) {
	rows, err := q.db.Query(ctx, getLikersForUser, likedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLikersForUserRow
	for rows.Next() {
		var i GetLikersForUserRow
		if err := rows.Scan(
			&i.LikerUserID,
			&i.Comment,
			&i.InteractionType,
			&i.LikedAt,
			&i.Name,
			&i.LastName,
			&i.MediaUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingVerificationUsers = `-- name: GetPendingVerificationUsers :many
SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE verification_status = $1
`

// Fetches users whose verification status is 'pending'.
func (q *Queries) GetPendingVerificationUsers(ctx context.Context, verificationStatus VerificationStatus) ([]User, error) {
	rows, err := q.db.Query(ctx, getPendingVerificationUsers, verificationStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuickFeed = `-- name: GetQuickFeed :many

SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.email, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer, target_user.spotlight_active_until,
    haversine($1, $2, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
WHERE
      target_user.id != $3 -- Exclude self
  AND target_user.latitude IS NOT NULL
  AND target_user.longitude IS NOT NULL
  AND target_user.gender = $4 -- Filter by the OPPOSITE gender passed as param
  AND target_user.name IS NOT NULL AND target_user.name != '' -- Basic profile check
  AND target_user.date_of_birth IS NOT NULL                  -- Basic profile check
ORDER BY
    distance_km ASC
LIMIT $5
`

type GetQuickFeedParams struct {
	Lat1   float64
	Lon1   float64
	ID     int32
	Gender NullGenderEnum
	Limit  int32
}

type GetQuickFeedRow struct {
	ID                   int32
	CreatedAt            pgtype.Timestamptz
	Name                 pgtype.Text
	LastName             pgtype.Text
	Email                string
	DateOfBirth          pgtype.Date
	Latitude             pgtype.Float8
	Longitude            pgtype.Float8
	Gender               NullGenderEnum
	DatingIntention      NullDatingIntention
	Height               pgtype.Float8
	Hometown             pgtype.Text
	JobTitle             pgtype.Text
	Education            pgtype.Text
	ReligiousBeliefs     NullReligion
	DrinkingHabit        NullDrinkingSmokingHabits
	SmokingHabit         NullDrinkingSmokingHabits
	MediaUrls            []string
	VerificationStatus   VerificationStatus
	VerificationPic      pgtype.Text
	Role                 UserRole
	AudioPromptQuestion  NullAudioPrompt
	AudioPromptAnswer    pgtype.Text
	SpotlightActiveUntil pgtype.Timestamptz
	DistanceKm           float64
}

// Param $2 is the feed batch size (e.g., 15)
// Retrieves a small feed based purely on proximity and opposite gender.
// Parameters: $1=latitude, $2=longitude (of requesting user), $3=requesting_user_id, $4=gender_to_show, $5=limit
func (q *Queries) GetQuickFeed(ctx context.Context, arg GetQuickFeedParams) ([]GetQuickFeedRow, error) {
	rows, err := q.db.Query(ctx, getQuickFeed,
		arg.Lat1,
		arg.Lon1,
		arg.ID,
		arg.Gender,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuickFeedRow
	for rows.Next() {
		var i GetQuickFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAudioPrompt = `-- name: GetUserAudioPrompt :one
SELECT id, audio_prompt_question, audio_prompt_answer
FROM users
WHERE id = $1 LIMIT 1
`

type GetUserAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) GetUserAudioPrompt(ctx context.Context, id int32) (GetUserAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, getUserAudioPrompt, id)
	var i GetUserAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until FROM users
WHERE id = $1 LIMIT 1
`

// FILE: db/queries.sql
func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const getUserConsumable = `-- name: GetUserConsumable :one
SELECT user_id, consumable_type, quantity, updated_at FROM user_consumables
WHERE user_id = $1
  AND consumable_type = $2
`

type GetUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

func (q *Queries) GetUserConsumable(ctx context.Context, arg GetUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, getUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDateVibesPrompts = `-- name: GetUserDateVibesPrompts :many
SELECT id, user_id, question, answer FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) GetUserDateVibesPrompts(ctx context.Context, userID int32) ([]DateVibesPrompt, error) {
	rows, err := q.db.Query(ctx, getUserDateVibesPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DateVibesPrompt
	for rows.Next() {
		var i DateVibesPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFilters = `-- name: GetUserFilters :one
SELECT user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at FROM filters
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserFilters(ctx context.Context, userID int32) (Filter, error) {
	row := q.db.QueryRow(ctx, getUserFilters, userID)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserGettingPersonalPrompts = `-- name: GetUserGettingPersonalPrompts :many
SELECT id, user_id, question, answer FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) GetUserGettingPersonalPrompts(ctx context.Context, userID int32) ([]GettingPersonalPrompt, error) {
	rows, err := q.db.Query(ctx, getUserGettingPersonalPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GettingPersonalPrompt
	for rows.Next() {
		var i GettingPersonalPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMyTypePrompts = `-- name: GetUserMyTypePrompts :many
SELECT id, user_id, question, answer FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) GetUserMyTypePrompts(ctx context.Context, userID int32) ([]MyTypePrompt, error) {
	rows, err := q.db.Query(ctx, getUserMyTypePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyTypePrompt
	for rows.Next() {
		var i MyTypePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryTimePrompts = `-- name: GetUserStoryTimePrompts :many
SELECT id, user_id, question, answer FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) GetUserStoryTimePrompts(ctx context.Context, userID int32) ([]StoryTimePrompt, error) {
	rows, err := q.db.Query(ctx, getUserStoryTimePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StoryTimePrompt
	for rows.Next() {
		var i StoryTimePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logAppOpen = `-- name: LogAppOpen :exec
INSERT INTO app_open_logs (user_id)
VALUES ($1)
`

func (q *Queries) LogAppOpen(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, logAppOpen, userID)
	return err
}

const updateAudioPrompt = `-- name: UpdateAudioPrompt :one
UPDATE users
SET audio_prompt_question = $1, audio_prompt_answer = $2
WHERE id = $3
RETURNING id, audio_prompt_question, audio_prompt_answer
`

type UpdateAudioPromptParams struct {
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
	ID                  int32
}

type UpdateAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) UpdateAudioPrompt(ctx context.Context, arg UpdateAudioPromptParams) (UpdateAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, updateAudioPrompt, arg.AudioPromptQuestion, arg.AudioPromptAnswer, arg.ID)
	var i UpdateAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const updateUserLocationGender = `-- name: UpdateUserLocationGender :one
UPDATE users SET
    latitude = $1,
    longitude = $2,
    gender = $3
WHERE id = $4
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserLocationGenderParams struct {
	Latitude  pgtype.Float8
	Longitude pgtype.Float8
	Gender    NullGenderEnum
	ID        int32
}

// Updates only the user's latitude, longitude, and gender.
func (q *Queries) UpdateUserLocationGender(ctx context.Context, arg UpdateUserLocationGenderParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserLocationGender,
		arg.Latitude,
		arg.Longitude,
		arg.Gender,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserMediaURLs = `-- name: UpdateUserMediaURLs :exec
UPDATE users
SET media_urls = $1
WHERE id = $2
`

type UpdateUserMediaURLsParams struct {
	MediaUrls []string
	ID        int32
}

// Sets the media URLs for a user, replacing any existing ones.
func (q *Queries) UpdateUserMediaURLs(ctx context.Context, arg UpdateUserMediaURLsParams) error {
	_, err := q.db.Exec(ctx, updateUserMediaURLs, arg.MediaUrls, arg.ID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one

UPDATE users SET
    name = $1,                -- param $1
    last_name = $2,           -- param $2
    date_of_birth = $3,       -- param $3
    dating_intention = $4,    -- param $4
    height = $5,              -- param $5
    hometown = $6,            -- param $6
    job_title = $7,           -- param $7
    education = $8,           -- param $8
    religious_beliefs = $9,   -- param $9
    drinking_habit = $10,     -- param $10
    smoking_habit = $11       -- param $11
WHERE id = $12                -- param $12
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserProfileParams struct {
	Name             pgtype.Text
	LastName         pgtype.Text
	DateOfBirth      pgtype.Date
	DatingIntention  NullDatingIntention
	Height           pgtype.Float8
	Hometown         pgtype.Text
	JobTitle         pgtype.Text
	Education        pgtype.Text
	ReligiousBeliefs NullReligion
	DrinkingHabit    NullDrinkingSmokingHabits
	SmokingHabit     NullDrinkingSmokingHabits
	ID               int32
}

// $1 should be 'pending'
// Updates the main profile details, EXCLUDING location and gender.
// Parameter indexes adjusted after removing location/gender params.
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.Name,
		arg.LastName,
		arg.DateOfBirth,
		arg.DatingIntention,
		arg.Height,
		arg.Hometown,
		arg.JobTitle,
		arg.Education,
		arg.ReligiousBeliefs,
		arg.DrinkingHabit,
		arg.SmokingHabit,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET role = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserRoleParams struct {
	Role UserRole
	ID   int32
}

// Updates the user's role (e.g., to 'admin' or 'user').
func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserVerificationDetails = `-- name: UpdateUserVerificationDetails :one
UPDATE users
SET
    verification_pic = $1,
    verification_status = $2
WHERE id = $3
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserVerificationDetailsParams struct {
	VerificationPic    pgtype.Text
	VerificationStatus VerificationStatus
	ID                 int32
}

// Updates the verification picture URL and status together.
func (q *Queries) UpdateUserVerificationDetails(ctx context.Context, arg UpdateUserVerificationDetailsParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationDetails, arg.VerificationPic, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :one
UPDATE users
SET verification_status = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until
`

type UpdateUserVerificationStatusParams struct {
	VerificationStatus VerificationStatus
	ID                 int32
}

// Updates the verification status ('true', 'false', 'pending').
func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationStatus, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
	)
	return i, err
}

const upsertUserConsumable = `-- name: UpsertUserConsumable :one
INSERT INTO user_consumables (user_id, consumable_type, quantity)
VALUES ($1, $2, $3) -- $3 is the quantity to add
ON CONFLICT (user_id, consumable_type) DO UPDATE
SET quantity = user_consumables.quantity + EXCLUDED.quantity,
    updated_at = NOW()
RETURNING user_id, consumable_type, quantity, updated_at
`

type UpsertUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
	Quantity       int32
}

func (q *Queries) UpsertUserConsumable(ctx context.Context, arg UpsertUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, upsertUserConsumable, arg.UserID, arg.ConsumableType, arg.Quantity)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserFilters = `-- name: UpsertUserFilters :one
INSERT INTO filters (
    user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (user_id) DO UPDATE SET
    who_you_want_to_see = EXCLUDED.who_you_want_to_see,
    radius_km = EXCLUDED.radius_km,
    active_today = EXCLUDED.active_today,
    age_min = EXCLUDED.age_min,
    age_max = EXCLUDED.age_max,
    updated_at = NOW()
RETURNING user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at
`

type UpsertUserFiltersParams struct {
	UserID          int32
	WhoYouWantToSee NullGenderEnum
	RadiusKm        pgtype.Int4
	ActiveToday     bool
	AgeMin          pgtype.Int4
	AgeMax          pgtype.Int4
}

func (q *Queries) UpsertUserFilters(ctx context.Context, arg UpsertUserFiltersParams) (Filter, error) {
	row := q.db.QueryRow(ctx, upsertUserFilters,
		arg.UserID,
		arg.WhoYouWantToSee,
		arg.RadiusKm,
		arg.ActiveToday,
		arg.AgeMin,
		arg.AgeMax,
	)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package migrations

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addContentLike = `-- name: AddContentLike :one
INSERT INTO likes (
    liker_user_id,
    liked_user_id,
    content_type,
    content_identifier,
    comment,
    interaction_type
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (liker_user_id, liked_user_id, content_type, content_identifier)
DO NOTHING
RETURNING id, liker_user_id, liked_user_id, content_type, content_identifier, comment, interaction_type, is_seen, created_at
`

type AddContentLikeParams struct {
	LikerUserID       int32
	LikedUserID       int32
	ContentType       ContentLikeType
	ContentIdentifier string
	Comment           pgtype.Text
	InteractionType   LikeInteractionType
}

func (q *Queries) AddContentLike(ctx context.Context, arg AddContentLikeParams) (Like, error) {
	row := q.db.QueryRow(ctx, addContentLike,
		arg.LikerUserID,
		arg.LikedUserID,
		arg.ContentType,
		arg.ContentIdentifier,
		arg.Comment,
		arg.InteractionType,
	)
	var i Like
	err := row.Scan(
		&i.ID,
		&i.LikerUserID,
		&i.LikedUserID,
		&i.ContentType,
		&i.ContentIdentifier,
		&i.Comment,
		&i.InteractionType,
		&i.IsSeen,
		&i.CreatedAt,
	)
	return i, err
}

const addDislike = `-- name: AddDislike :exec
INSERT INTO dislikes (disliker_user_id, disliked_user_id)
VALUES ($1, $2)
ON CONFLICT (disliker_user_id, disliked_user_id) DO NOTHING
`

type AddDislikeParams struct {
	DislikerUserID int32
	DislikedUserID int32
}

func (q *Queries) AddDislike(ctx context.Context, arg AddDislikeParams) error {
	_, err := q.db.Exec(ctx, addDislike, arg.DislikerUserID, arg.DislikedUserID)
	return err
}

const addUserSubscription = `-- name: AddUserSubscription :one
INSERT INTO user_subscriptions (
    user_id, feature_type, expires_at, activated_at
) VALUES (
    $1, $2, $3, NOW()
)
RETURNING id, user_id, feature_type, activated_at, expires_at, created_at
`

type AddUserSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
	ExpiresAt   pgtype.Timestamptz
}

func (q *Queries) AddUserSubscription(ctx context.Context, arg AddUserSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, addUserSubscription, arg.UserID, arg.FeatureType, arg.ExpiresAt)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const checkLikeExists = `-- name: CheckLikeExists :one
SELECT EXISTS (
    SELECT 1 FROM likes
    WHERE liker_user_id = $1 AND liked_user_id = $2
)
`

type CheckLikeExistsParams struct {
	LikerUserID int32
	LikedUserID int32
}

func (q *Queries) CheckLikeExists(ctx context.Context, arg CheckLikeExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLikeExists, arg.LikerUserID, arg.LikedUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkLikeExistsForRecipient = `-- name: CheckLikeExistsForRecipient :one
SELECT EXISTS (
    SELECT 1
    FROM likes
    WHERE id = $1
      AND liked_user_id = $2
)
`

type CheckLikeExistsForRecipientParams struct {
	ID          int32
	LikedUserID int32
}

func (q *Queries) CheckLikeExistsForRecipient(ctx context.Context, arg CheckLikeExistsForRecipientParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkLikeExistsForRecipient, arg.ID, arg.LikedUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkMutualLikeExists = `-- name: CheckMutualLikeExists :one
SELECT EXISTS (SELECT 1 FROM likes l1 WHERE l1.liker_user_id = $1 AND l1.liked_user_id = $2)
   AND EXISTS (SELECT 1 FROM likes l2 WHERE l2.liker_user_id = $2 AND l2.liked_user_id = $1)
`

type CheckMutualLikeExistsParams struct {
	LikerUserID int32
	LikedUserID int32
}

func (q *Queries) CheckMutualLikeExists(ctx context.Context, arg CheckMutualLikeExistsParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, checkMutualLikeExists, arg.LikerUserID, arg.LikedUserID)
	var column_1 pgtype.Bool
	err := row.Scan(&column_1)
	return column_1, err
}

const clearUserMediaURLs = `-- name: ClearUserMediaURLs :exec
UPDATE users
SET media_urls = '{}'
WHERE id = $1
`

// Removes all media URLs for a user.
func (q *Queries) ClearUserMediaURLs(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, clearUserMediaURLs, id)
	return err
}

const countDislikesReceived = `-- name: CountDislikesReceived :one
SELECT COUNT(*)
FROM dislikes
WHERE disliked_user_id = $1 -- Use named param
  AND ($2::timestamptz IS NULL OR created_at >= $2)
  AND ($3::timestamptz IS NULL OR created_at <= $3)
`

type CountDislikesReceivedParams struct {
	DislikedUserID int32
	StartDate      pgtype.Timestamptz
	EndDate        pgtype.Timestamptz
}

func (q *Queries) CountDislikesReceived(ctx context.Context, arg CountDislikesReceivedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDislikesReceived, arg.DislikedUserID, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDislikesSent = `-- name: CountDislikesSent :one
SELECT COUNT(*)
FROM dislikes
WHERE disliker_user_id = $1 -- Use named param
  AND ($2::timestamptz IS NULL OR created_at >= $2)
  AND ($3::timestamptz IS NULL OR created_at <= $3)
`

type CountDislikesSentParams struct {
	DislikerUserID int32
	StartDate      pgtype.Timestamptz
	EndDate        pgtype.Timestamptz
}

// Counts dislikes sent by the user within a date range.
func (q *Queries) CountDislikesSent(ctx context.Context, arg CountDislikesSentParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDislikesSent, arg.DislikerUserID, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImpressionsDuringSpotlight = `-- name: CountImpressionsDuringSpotlight :one
SELECT COUNT(*)
FROM user_profile_impressions
WHERE shown_user_id = $1
  AND source = 'spotlight'
  AND ($2::timestamptz IS NULL OR impression_timestamp >= $2)
  AND ($3::timestamptz IS NULL OR impression_timestamp <= $3)
`

type CountImpressionsDuringSpotlightParams struct {
	ShownUserID int32
	StartDate   pgtype.Timestamptz
	EndDate     pgtype.Timestamptz
}

func (q *Queries) CountImpressionsDuringSpotlight(ctx context.Context, arg CountImpressionsDuringSpotlightParams) (int64, error) {
	row := q.db.QueryRow(ctx, countImpressionsDuringSpotlight, arg.ShownUserID, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProfileImpressions = `-- name: CountProfileImpressions :one
SELECT COUNT(*)
FROM user_profile_impressions
WHERE shown_user_id = $1
  AND ($2::timestamptz IS NULL OR impression_timestamp >= $2)
  AND ($3::timestamptz IS NULL OR impression_timestamp <= $3)
`

type CountProfileImpressionsParams struct {
	ShownUserID int32
	StartDate   pgtype.Timestamptz
	EndDate     pgtype.Timestamptz
}

func (q *Queries) CountProfileImpressions(ctx context.Context, arg CountProfileImpressionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProfileImpressions, arg.ShownUserID, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProfilesOpenedFromLike = `-- name: CountProfilesOpenedFromLike :one
SELECT COUNT(*)
FROM like_profile_views
WHERE liker_user_id = $1 -- Use named param
  AND ($2::timestamptz IS NULL OR view_timestamp >= $2)
  AND ($3::timestamptz IS NULL OR view_timestamp <= $3)
`

type CountProfilesOpenedFromLikeParams struct {
	LikerUserID int32
	StartDate   pgtype.Timestamptz
	EndDate     pgtype.Timestamptz
}

func (q *Queries) CountProfilesOpenedFromLike(ctx context.Context, arg CountProfilesOpenedFromLikeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProfilesOpenedFromLike, arg.LikerUserID, arg.StartDate, arg.EndDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentStandardLikes = `-- name: CountRecentStandardLikes :one
SELECT COUNT(*) FROM likes
WHERE liker_user_id = $1
  AND interaction_type = 'standard'
  AND created_at >= NOW() - INTERVAL '24 hours'
`

func (q *Queries) CountRecentStandardLikes(ctx context.Context, likerUserID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentStandardLikes, likerUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (
    sender_user_id,
    recipient_user_id,
    message_text,
    media_url,
    media_type,
    reply_to_message_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, sender_user_id, recipient_user_id, message_text, media_url, media_type, sent_at, is_read, reply_to_message_id
`

type CreateChatMessageParams struct {
	SenderUserID     int32
	RecipientUserID  int32
	MessageText      pgtype.Text
	MediaUrl         pgtype.Text
	MediaType        pgtype.Text
	ReplyToMessageID pgtype.Int8
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.SenderUserID,
		arg.RecipientUserID,
		arg.MessageText,
		arg.MediaUrl,
		arg.MediaType,
		arg.ReplyToMessageID,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.SenderUserID,
		&i.RecipientUserID,
		&i.MessageText,
		&i.MediaUrl,
		&i.MediaType,
		&i.SentAt,
		&i.IsRead,
		&i.ReplyToMessageID,
	)
	return i, err
}

const createDateVibesPrompt = `-- name: CreateDateVibesPrompt :one
INSERT INTO date_vibes_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateDateVibesPromptParams struct {
	UserID   int32
	Question DateVibesPromptType
	Answer   string
}

func (q *Queries) CreateDateVibesPrompt(ctx context.Context, arg CreateDateVibesPromptParams) (DateVibesPrompt, error) {
	row := q.db.QueryRow(ctx, createDateVibesPrompt, arg.UserID, arg.Question, arg.Answer)
	var i DateVibesPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createGettingPersonalPrompt = `-- name: CreateGettingPersonalPrompt :one
INSERT INTO getting_personal_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateGettingPersonalPromptParams struct {
	UserID   int32
	Question GettingPersonalPromptType
	Answer   string
}

func (q *Queries) CreateGettingPersonalPrompt(ctx context.Context, arg CreateGettingPersonalPromptParams) (GettingPersonalPrompt, error) {
	row := q.db.QueryRow(ctx, createGettingPersonalPrompt, arg.UserID, arg.Question, arg.Answer)
	var i GettingPersonalPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createMyTypePrompt = `-- name: CreateMyTypePrompt :one
INSERT INTO my_type_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateMyTypePromptParams struct {
	UserID   int32
	Question MyTypePromptType
	Answer   string
}

func (q *Queries) CreateMyTypePrompt(ctx context.Context, arg CreateMyTypePromptParams) (MyTypePrompt, error) {
	row := q.db.QueryRow(ctx, createMyTypePrompt, arg.UserID, arg.Question, arg.Answer)
	var i MyTypePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createReport = `-- name: CreateReport :one
INSERT INTO reports (
    reporter_user_id,
    reported_user_id,
    reason
) VALUES (
    $1, $2, $3
)
RETURNING id, reporter_user_id, reported_user_id, reason, created_at
`

type CreateReportParams struct {
	ReporterUserID int32
	ReportedUserID int32
	Reason         ReportReason
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (Report, error) {
	row := q.db.QueryRow(ctx, createReport, arg.ReporterUserID, arg.ReportedUserID, arg.Reason)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.ReporterUserID,
		&i.ReportedUserID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const createStoryTimePrompt = `-- name: CreateStoryTimePrompt :one
INSERT INTO story_time_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateStoryTimePromptParams struct {
	UserID   int32
	Question StoryTimePromptType
	Answer   string
}

func (q *Queries) CreateStoryTimePrompt(ctx context.Context, arg CreateStoryTimePromptParams) (StoryTimePrompt, error) {
	row := q.db.QueryRow(ctx, createStoryTimePrompt, arg.UserID, arg.Question, arg.Answer)
	var i StoryTimePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createUserWithEmail = `-- name: CreateUserWithEmail :one
INSERT INTO users (
    email
) VALUES (
    $1
)
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online
`

// Creates a new user with only their email address initially.
func (q *Queries) CreateUserWithEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const decrementUserConsumable = `-- name: DecrementUserConsumable :one

UPDATE user_consumables
SET quantity = quantity - 1,
    updated_at = NOW()
WHERE user_id = $1
  AND consumable_type = $2 -- e.g., 'rose'
  AND quantity > 0
RETURNING user_id, consumable_type, quantity, updated_at
`

type DecrementUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

// e.g., 'rose'
func (q *Queries) DecrementUserConsumable(ctx context.Context, arg DecrementUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, decrementUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLikesBetweenUsers = `-- name: DeleteLikesBetweenUsers :exec
DELETE FROM likes
WHERE (liker_user_id = $1 AND liked_user_id = $2)
   OR (liker_user_id = $2 AND liked_user_id = $1)
`

type DeleteLikesBetweenUsersParams struct {
	LikerUserID int32
	LikedUserID int32
}

func (q *Queries) DeleteLikesBetweenUsers(ctx context.Context, arg DeleteLikesBetweenUsersParams) error {
	_, err := q.db.Exec(ctx, deleteLikesBetweenUsers, arg.LikerUserID, arg.LikedUserID)
	return err
}

const deleteMessageReactionByUser = `-- name: DeleteMessageReactionByUser :execresult
DELETE FROM message_reactions
WHERE message_id = $1
  AND user_id = $2
`

type DeleteMessageReactionByUserParams struct {
	MessageID int64
	UserID    int32
}

func (q *Queries) DeleteMessageReactionByUser(ctx context.Context, arg DeleteMessageReactionByUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteMessageReactionByUser, arg.MessageID, arg.UserID)
}

const deleteUserDateVibesPrompts = `-- name: DeleteUserDateVibesPrompts :exec
DELETE FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserDateVibesPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserDateVibesPrompts, userID)
	return err
}

const deleteUserGettingPersonalPrompts = `-- name: DeleteUserGettingPersonalPrompts :exec
DELETE FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserGettingPersonalPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserGettingPersonalPrompts, userID)
	return err
}

const deleteUserMyTypePrompts = `-- name: DeleteUserMyTypePrompts :exec
DELETE FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserMyTypePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserMyTypePrompts, userID)
	return err
}

const deleteUserStoryTimePrompts = `-- name: DeleteUserStoryTimePrompts :exec
DELETE FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserStoryTimePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserStoryTimePrompts, userID)
	return err
}

const getActiveSubscription = `-- name: GetActiveSubscription :one
SELECT id, user_id, feature_type, activated_at, expires_at, created_at FROM user_subscriptions
WHERE user_id = $1
  AND feature_type = $2 -- e.g., 'unlimited_likes'
  AND expires_at > NOW()
LIMIT 1
`

type GetActiveSubscriptionParams struct {
	UserID      int32
	FeatureType PremiumFeatureType
}

func (q *Queries) GetActiveSubscription(ctx context.Context, arg GetActiveSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRow(ctx, getActiveSubscription, arg.UserID, arg.FeatureType)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FeatureType,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getApproximateProfileViewTimeSeconds = `-- name: GetApproximateProfileViewTimeSeconds :one
WITH UserInteractions AS (
    SELECT
        l.liker_user_id AS viewer_user_id,
        l.liked_user_id AS interacted_user_id,
        l.created_at
    FROM likes l
    WHERE l.liked_user_id = $1
      AND ($2::timestamptz IS NULL OR l.created_at >= $2)
      AND ($3::timestamptz IS NULL OR l.created_at <= $3)
    UNION ALL
    SELECT
        d.disliker_user_id AS viewer_user_id,
        d.disliked_user_id AS interacted_user_id,
        d.created_at
    FROM dislikes d
    WHERE d.disliked_user_id = $1
      AND ($2::timestamptz IS NULL OR d.created_at >= $2)
      AND ($3::timestamptz IS NULL OR d.created_at <= $3)
),
InteractionIntervals AS (
    SELECT
        created_at,
        LAG(created_at, 1) OVER (PARTITION BY viewer_user_id ORDER BY created_at ASC) as prev_created_at
    FROM UserInteractions
)
SELECT
    COALESCE(AVG(
        LEAST(
            EXTRACT(EPOCH FROM (created_at - prev_created_at)),
            60.0
        )
    ), 0.0)::float
FROM InteractionIntervals
WHERE prev_created_at IS NOT NULL
`

type GetApproximateProfileViewTimeSecondsParams struct {
	TargetUserID int32
	StartDate    pgtype.Timestamptz
	EndDate      pgtype.Timestamptz
}

func (q *Queries) GetApproximateProfileViewTimeSeconds(ctx context.Context, arg GetApproximateProfileViewTimeSecondsParams) (float64, error) {
	row := q.db.QueryRow(ctx, getApproximateProfileViewTimeSeconds, arg.TargetUserID, arg.StartDate, arg.EndDate)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}

const getBasicMatchInfo = `-- name: GetBasicMatchInfo :one
SELECT
    id,
    name,
    last_name,
    media_urls,
    is_online,
    last_online
FROM users
WHERE id = $1 LIMIT 1
`

type GetBasicMatchInfoRow struct {
	ID         int32
	Name       pgtype.Text
	LastName   pgtype.Text
	MediaUrls  []string
	IsOnline   bool
	LastOnline pgtype.Timestamptz
}

func (q *Queries) GetBasicMatchInfo(ctx context.Context, id int32) (GetBasicMatchInfoRow, error) {
	row := q.db.QueryRow(ctx, getBasicMatchInfo, id)
	var i GetBasicMatchInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LastName,
		&i.MediaUrls,
		&i.IsOnline,
		&i.LastOnline,
	)
	return i, err
}

const getBasicUserInfo = `-- name: GetBasicUserInfo :one
SELECT
    id,
    name,
    last_name,
    media_urls
FROM users
WHERE id = $1 LIMIT 1
`

type GetBasicUserInfoRow struct {
	ID        int32
	Name      pgtype.Text
	LastName  pgtype.Text
	MediaUrls []string
}

func (q *Queries) GetBasicUserInfo(ctx context.Context, id int32) (GetBasicUserInfoRow, error) {
	row := q.db.QueryRow(ctx, getBasicUserInfo, id)
	var i GetBasicUserInfoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.LastName,
		&i.MediaUrls,
	)
	return i, err
}

const getConversationMessages = `-- name: GetConversationMessages :many
WITH MessageReactionsAgg AS (
    SELECT
        message_id,
        jsonb_object_agg(emoji, count) FILTER (WHERE emoji IS NOT NULL) AS reactions_summary_json
     FROM (
        SELECT message_id, emoji, COUNT(user_id) as count
        FROM message_reactions
        WHERE message_id IN (
            SELECT id FROM chat_messages
            WHERE (sender_user_id = $1 AND recipient_user_id = $2)
               OR (sender_user_id = $2 AND recipient_user_id = $1)
        )
        GROUP BY message_id, emoji
     ) AS grouped_reactions
    GROUP BY message_id
)
SELECT
    cm.id, cm.sender_user_id, cm.recipient_user_id, cm.message_text, cm.media_url, cm.media_type, cm.sent_at, cm.is_read,
    COALESCE(mra.reactions_summary_json, '{}'::jsonb) AS reactions_data,
    cm.reply_to_message_id,
    replied_msg.sender_user_id AS replied_message_sender_id,
    COALESCE(substring(replied_msg.message_text for 50)::TEXT, '') AS replied_message_text_snippet,
    replied_msg.media_type AS replied_message_media_type
FROM chat_messages cm
LEFT JOIN MessageReactionsAgg mra ON cm.id = mra.message_id
LEFT JOIN chat_messages replied_msg ON cm.reply_to_message_id = replied_msg.id
WHERE (cm.sender_user_id = $1 AND cm.recipient_user_id = $2)
   OR (cm.sender_user_id = $2 AND cm.recipient_user_id = $1)
ORDER BY cm.sent_at ASC
`

type GetConversationMessagesParams struct {
	SenderUserID    int32
	RecipientUserID int32
}

type GetConversationMessagesRow struct {
	ID                        int64
	SenderUserID              int32
	RecipientUserID           int32
	MessageText               pgtype.Text
	MediaUrl                  pgtype.Text
	MediaType                 pgtype.Text
	SentAt                    pgtype.Timestamptz
	IsRead                    bool
	ReactionsData             []byte
	ReplyToMessageID          pgtype.Int8
	RepliedMessageSenderID    pgtype.Int4
	RepliedMessageTextSnippet interface{}
	RepliedMessageMediaType   pgtype.Text
}

func (q *Queries) GetConversationMessages(ctx context.Context, arg GetConversationMessagesParams) ([]GetConversationMessagesRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, arg.SenderUserID, arg.RecipientUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversationMessagesRow
	for rows.Next() {
		var i GetConversationMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderUserID,
			&i.RecipientUserID,
			&i.MessageText,
			&i.MediaUrl,
			&i.MediaType,
			&i.SentAt,
			&i.IsRead,
			&i.ReactionsData,
			&i.ReplyToMessageID,
			&i.RepliedMessageSenderID,
			&i.RepliedMessageTextSnippet,
			&i.RepliedMessageMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHomeFeed = `-- name: GetHomeFeed :many
WITH RequestingUser AS (
    SELECT
        u.id, u.latitude, u.longitude, u.gender, u.date_of_birth, u.spotlight_active_until
    FROM users u WHERE u.id = $1
), RequestingUserFilters AS (
    SELECT
        f.user_id, f.who_you_want_to_see, f.radius_km, f.active_today, f.age_min, f.age_max
    FROM filters f WHERE f.user_id = $1
), AllPrompts AS (
    SELECT user_id, 'storyTime' as category, question::text, answer FROM story_time_prompts
    UNION ALL
    SELECT user_id, 'myType' as category, question::text, answer FROM my_type_prompts
    UNION ALL
    SELECT user_id, 'gettingPersonal' as category, question::text, answer FROM getting_personal_prompts
    UNION ALL
    SELECT user_id, 'dateVibes' as category, question::text, answer FROM date_vibes_prompts
), AggregatedPrompts AS (
    SELECT
        user_id,
        jsonb_agg(jsonb_build_object('category', category, 'question', question, 'answer', answer)) as prompts
    FROM AllPrompts
    GROUP BY user_id
)
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.email, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer, target_user.spotlight_active_until, target_user.last_online, target_user.is_online,
    COALESCE(ap.prompts, '[]'::jsonb) as prompts,
    haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
JOIN RequestingUser ru ON target_user.id != ru.id
JOIN RequestingUserFilters rf ON ru.id = rf.user_id
LEFT JOIN filters AS target_user_filters ON target_user.id = target_user_filters.user_id
LEFT JOIN AggregatedPrompts ap ON target_user.id = ap.user_id
WHERE
    target_user.latitude IS NOT NULL AND target_user.longitude IS NOT NULL
    AND ru.latitude IS NOT NULL AND ru.longitude IS NOT NULL
    AND ru.gender IS NOT NULL
    AND rf.who_you_want_to_see IS NOT NULL
    AND rf.age_min IS NOT NULL AND rf.age_max IS NOT NULL
    AND (rf.radius_km IS NULL OR haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) <= rf.radius_km)
    AND target_user.gender = rf.who_you_want_to_see
    AND (target_user_filters.user_id IS NULL OR target_user_filters.who_you_want_to_see IS NULL OR target_user_filters.who_you_want_to_see = ru.gender)
    AND target_user.date_of_birth IS NOT NULL
    AND EXTRACT(YEAR FROM AGE(target_user.date_of_birth)) BETWEEN rf.age_min AND rf.age_max
    AND (NOT rf.active_today OR (
		target_user.last_online IS NOT NULL AND target_user.last_online >= NOW() - INTERVAL '24 hours'
    ))
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = ru.id AND d.disliked_user_id = target_user.id)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = target_user.id AND d.disliked_user_id = ru.id)
    AND NOT EXISTS (SELECT 1 FROM likes l WHERE l.liker_user_id = ru.id AND l.liked_user_id = target_user.id)
ORDER BY
    CASE WHEN target_user.spotlight_active_until > NOW() THEN 0 ELSE 1 END ASC,
    distance_km ASC,
    CASE WHEN ru.date_of_birth IS NOT NULL THEN
      ABS(EXTRACT(YEAR FROM AGE(ru.date_of_birth)) - EXTRACT(YEAR FROM AGE(target_user.date_of_birth)))
    ELSE
      NULL
    END ASC NULLS LAST
LIMIT $2
`

type GetHomeFeedParams struct {
	ID    int32
	Limit int32
}

type GetHomeFeedRow struct {
	ID                   int32
	CreatedAt            pgtype.Timestamptz
	Name                 pgtype.Text
	LastName             pgtype.Text
	Email                string
	DateOfBirth          pgtype.Date
	Latitude             pgtype.Float8
	Longitude            pgtype.Float8
	Gender               NullGenderEnum
	DatingIntention      NullDatingIntention
	Height               pgtype.Float8
	Hometown             pgtype.Text
	JobTitle             pgtype.Text
	Education            pgtype.Text
	ReligiousBeliefs     NullReligion
	DrinkingHabit        NullDrinkingSmokingHabits
	SmokingHabit         NullDrinkingSmokingHabits
	MediaUrls            []string
	VerificationStatus   VerificationStatus
	VerificationPic      pgtype.Text
	Role                 UserRole
	AudioPromptQuestion  NullAudioPrompt
	AudioPromptAnswer    pgtype.Text
	SpotlightActiveUntil pgtype.Timestamptz
	LastOnline           pgtype.Timestamptz
	IsOnline             bool
	Prompts              []byte
	DistanceKm           float64
}

func (q *Queries) GetHomeFeed(ctx context.Context, arg GetHomeFeedParams) ([]GetHomeFeedRow, error) {
	rows, err := q.db.Query(ctx, getHomeFeed, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHomeFeedRow
	for rows.Next() {
		var i GetHomeFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.LastOnline,
			&i.IsOnline,
			&i.Prompts,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikeDetails = `-- name: GetLikeDetails :one
SELECT
    comment,
    interaction_type
FROM likes
WHERE liker_user_id = $1
AND liked_user_id = $2
LIMIT 1
`

type GetLikeDetailsParams struct {
	LikerUserID int32
	LikedUserID int32
}

type GetLikeDetailsRow struct {
	Comment         pgtype.Text
	InteractionType LikeInteractionType
}

func (q *Queries) GetLikeDetails(ctx context.Context, arg GetLikeDetailsParams) (GetLikeDetailsRow, error) {
	row := q.db.QueryRow(ctx, getLikeDetails, arg.LikerUserID, arg.LikedUserID)
	var i GetLikeDetailsRow
	err := row.Scan(&i.Comment, &i.InteractionType)
	return i, err
}

const getLikersForUser = `-- name: GetLikersForUser :many
SELECT
    l.id AS like_id,
    l.liker_user_id,
    l.comment,
    l.interaction_type,
    l.is_seen,
    l.created_at as liked_at,
    u.name,
    u.last_name,
    u.media_urls
FROM likes l
JOIN users u ON l.liker_user_id = u.id
WHERE l.liked_user_id = $1
  AND NOT EXISTS (
      SELECT 1
      FROM likes l2
      WHERE l2.liker_user_id = l.liked_user_id
        AND l2.liked_user_id = l.liker_user_id
  )
ORDER BY
    (l.interaction_type = 'rose') DESC,
    l.is_seen ASC,
    l.created_at DESC
`

type GetLikersForUserRow struct {
	LikeID          int32
	LikerUserID     int32
	Comment         pgtype.Text
	InteractionType LikeInteractionType
	IsSeen          pgtype.Bool
	LikedAt         pgtype.Timestamptz
	Name            pgtype.Text
	LastName        pgtype.Text
	MediaUrls       []string
}

func (q *Queries) GetLikersForUser(ctx context.Context, likedUserID int32) ([]GetLikersForUserRow, error) {
	rows, err := q.db.Query(ctx, getLikersForUser, likedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLikersForUserRow
	for rows.Next() {
		var i GetLikersForUserRow
		if err := rows.Scan(
			&i.LikeID,
			&i.LikerUserID,
			&i.Comment,
			&i.InteractionType,
			&i.IsSeen,
			&i.LikedAt,
			&i.Name,
			&i.LastName,
			&i.MediaUrls,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchIDs = `-- name: GetMatchIDs :many
SELECT
  l1.liked_user_id
FROM
  likes l1
JOIN
  likes l2
  ON l1.liker_user_id = l2.liked_user_id
  AND l1.liked_user_id = l2.liker_user_id
WHERE
  l1.liker_user_id = $1
`

func (q *Queries) GetMatchIDs(ctx context.Context, likerUserID int32) ([]int32, error) {
	rows, err := q.db.Query(ctx, getMatchIDs, likerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var liked_user_id int32
		if err := rows.Scan(&liked_user_id); err != nil {
			return nil, err
		}
		items = append(items, liked_user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesWithLastEvent = `-- name: GetMatchesWithLastEvent :many
SELECT
    target_user.id AS matched_user_id,
    target_user.name AS matched_user_name,
    target_user.last_name AS matched_user_last_name,
    target_user.media_urls AS matched_user_media_urls,
    target_user.is_online AS matched_user_is_online,
    target_user.last_online AS matched_user_last_online,
    last_event.event_at AS last_event_timestamp,
    COALESCE(last_event.event_user_id, 0) AS last_event_user_id,
    COALESCE(last_event.event_type, '') AS last_event_type,
    COALESCE(last_event.event_content, '') AS last_event_content,
    COALESCE(last_event.event_extra, '') AS last_event_extra,
    (
        SELECT COUNT(*)
        FROM chat_messages cm_unread
        WHERE cm_unread.recipient_user_id = l1.liker_user_id
          AND cm_unread.sender_user_id = l1.liked_user_id
          AND cm_unread.is_read = false
    ) AS unread_message_count
FROM
    likes l1
JOIN
    users target_user
    ON l1.liked_user_id = target_user.id
JOIN
    likes l2
    ON l1.liked_user_id = l2.liker_user_id
   AND l1.liker_user_id = l2.liked_user_id
LEFT JOIN LATERAL (
    (
        SELECT
            cm.sent_at AS event_at,
            cm.sender_user_id AS event_user_id,
            CASE
                WHEN cm.message_text IS NOT NULL THEN 'text'
                ELSE 'media'
            END AS event_type,
            COALESCE(cm.message_text, cm.media_type) AS event_content,
            cm.media_url AS event_extra
        FROM chat_messages cm
        WHERE
            (cm.sender_user_id = l1.liker_user_id AND cm.recipient_user_id = l1.liked_user_id)
            OR (cm.sender_user_id = l1.liked_user_id AND cm.recipient_user_id = l1.liker_user_id)

        UNION ALL

        SELECT
            mr.updated_at AS event_at,
            mr.user_id AS event_user_id,
            'reaction' AS event_type,
            mr.emoji AS event_content,
            NULL AS event_extra
        FROM message_reactions mr
        JOIN chat_messages cm_react
            ON mr.message_id = cm_react.id
        WHERE
            (mr.user_id = l1.liker_user_id OR mr.user_id = l1.liked_user_id)
            AND (
                (cm_react.sender_user_id = l1.liker_user_id AND cm_react.recipient_user_id = l1.liked_user_id)
                OR (cm_react.sender_user_id = l1.liked_user_id AND cm_react.recipient_user_id = l1.liker_user_id)
            )
    )
    ORDER BY event_at DESC
    LIMIT 1
) AS last_event ON true
WHERE
    l1.liker_user_id = $1
ORDER BY
    COALESCE(last_event.event_at, '1970-01-01'::timestamptz) DESC,
    target_user.id
`

type GetMatchesWithLastEventRow struct {
	MatchedUserID         int32
	MatchedUserName       pgtype.Text
	MatchedUserLastName   pgtype.Text
	MatchedUserMediaUrls  []string
	MatchedUserIsOnline   bool
	MatchedUserLastOnline pgtype.Timestamptz
	LastEventTimestamp    pgtype.Timestamptz
	LastEventUserID       int32
	LastEventType         string
	LastEventContent      string
	LastEventExtra        string
	UnreadMessageCount    int64
}

func (q *Queries) GetMatchesWithLastEvent(ctx context.Context, likerUserID int32) ([]GetMatchesWithLastEventRow, error) {
	rows, err := q.db.Query(ctx, getMatchesWithLastEvent, likerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchesWithLastEventRow
	for rows.Next() {
		var i GetMatchesWithLastEventRow
		if err := rows.Scan(
			&i.MatchedUserID,
			&i.MatchedUserName,
			&i.MatchedUserLastName,
			&i.MatchedUserMediaUrls,
			&i.MatchedUserIsOnline,
			&i.MatchedUserLastOnline,
			&i.LastEventTimestamp,
			&i.LastEventUserID,
			&i.LastEventType,
			&i.LastEventContent,
			&i.LastEventExtra,
			&i.UnreadMessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageSenderRecipient = `-- name: GetMessageSenderRecipient :one
SELECT sender_user_id, recipient_user_id
FROM chat_messages
WHERE id = $1
LIMIT 1
`

type GetMessageSenderRecipientRow struct {
	SenderUserID    int32
	RecipientUserID int32
}

func (q *Queries) GetMessageSenderRecipient(ctx context.Context, id int64) (GetMessageSenderRecipientRow, error) {
	row := q.db.QueryRow(ctx, getMessageSenderRecipient, id)
	var i GetMessageSenderRecipientRow
	err := row.Scan(&i.SenderUserID, &i.RecipientUserID)
	return i, err
}

const getPendingVerificationUsers = `-- name: GetPendingVerificationUsers :many
SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online FROM users
WHERE verification_status = $1
`

func (q *Queries) GetPendingVerificationUsers(ctx context.Context, verificationStatus VerificationStatus) ([]User, error) {
	rows, err := q.db.Query(ctx, getPendingVerificationUsers, verificationStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.LastOnline,
			&i.IsOnline,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhotoAverageViewDurations = `-- name: GetPhotoAverageViewDurations :many
SELECT
    photo_index,
    COALESCE(AVG(duration_ms), 0)::float AS average_duration_ms
FROM photo_view_durations
WHERE
    viewed_user_id = $1
    AND ($2::timestamptz IS NULL OR view_timestamp >= $2)
    AND ($3::timestamptz IS NULL OR view_timestamp <= $3)
GROUP BY photo_index
ORDER BY photo_index
`

type GetPhotoAverageViewDurationsParams struct {
	ViewedUserID int32
	StartDate    pgtype.Timestamptz
	EndDate      pgtype.Timestamptz
}

type GetPhotoAverageViewDurationsRow struct {
	PhotoIndex        int16
	AverageDurationMs float64
}

func (q *Queries) GetPhotoAverageViewDurations(ctx context.Context, arg GetPhotoAverageViewDurationsParams) ([]GetPhotoAverageViewDurationsRow, error) {
	rows, err := q.db.Query(ctx, getPhotoAverageViewDurations, arg.ViewedUserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPhotoAverageViewDurationsRow
	for rows.Next() {
		var i GetPhotoAverageViewDurationsRow
		if err := rows.Scan(&i.PhotoIndex, &i.AverageDurationMs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuickFeed = `-- name: GetQuickFeed :many
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.email, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer, target_user.spotlight_active_until, target_user.last_online, target_user.is_online,
    haversine($1, $2, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
WHERE
      target_user.id != $3
  AND target_user.latitude IS NOT NULL
  AND target_user.longitude IS NOT NULL
  AND target_user.gender = $4
  AND target_user.name IS NOT NULL AND target_user.name != ''
  AND target_user.date_of_birth IS NOT NULL
ORDER BY
    distance_km ASC
LIMIT $5
`

type GetQuickFeedParams struct {
	Lat1   float64
	Lon1   float64
	ID     int32
	Gender NullGenderEnum
	Limit  int32
}

type GetQuickFeedRow struct {
	ID                   int32
	CreatedAt            pgtype.Timestamptz
	Name                 pgtype.Text
	LastName             pgtype.Text
	Email                string
	DateOfBirth          pgtype.Date
	Latitude             pgtype.Float8
	Longitude            pgtype.Float8
	Gender               NullGenderEnum
	DatingIntention      NullDatingIntention
	Height               pgtype.Float8
	Hometown             pgtype.Text
	JobTitle             pgtype.Text
	Education            pgtype.Text
	ReligiousBeliefs     NullReligion
	DrinkingHabit        NullDrinkingSmokingHabits
	SmokingHabit         NullDrinkingSmokingHabits
	MediaUrls            []string
	VerificationStatus   VerificationStatus
	VerificationPic      pgtype.Text
	Role                 UserRole
	AudioPromptQuestion  NullAudioPrompt
	AudioPromptAnswer    pgtype.Text
	SpotlightActiveUntil pgtype.Timestamptz
	LastOnline           pgtype.Timestamptz
	IsOnline             bool
	DistanceKm           float64
}

func (q *Queries) GetQuickFeed(ctx context.Context, arg GetQuickFeedParams) ([]GetQuickFeedRow, error) {
	rows, err := q.db.Query(ctx, getQuickFeed,
		arg.Lat1,
		arg.Lon1,
		arg.ID,
		arg.Gender,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuickFeedRow
	for rows.Next() {
		var i GetQuickFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.SpotlightActiveUntil,
			&i.LastOnline,
			&i.IsOnline,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleReactionByUser = `-- name: GetSingleReactionByUser :one
SELECT id, message_id, user_id, emoji, created_at, updated_at
FROM message_reactions
WHERE message_id = $1 AND user_id = $2
LIMIT 1
`

type GetSingleReactionByUserParams struct {
	MessageID int64
	UserID    int32
}

func (q *Queries) GetSingleReactionByUser(ctx context.Context, arg GetSingleReactionByUserParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, getSingleReactionByUser, arg.MessageID, arg.UserID)
	var i MessageReaction
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.UserID,
		&i.Emoji,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalUnreadCount = `-- name: GetTotalUnreadCount :one
SELECT COUNT(*)
FROM chat_messages
WHERE recipient_user_id = $1
  AND is_read = false
`

func (q *Queries) GetTotalUnreadCount(ctx context.Context, recipientUserID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalUnreadCount, recipientUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUnseenLikeCount = `-- name: GetUnseenLikeCount :one
SELECT COUNT(*)
FROM likes l
WHERE l.liked_user_id = $1 -- The user receiving the likes
  AND l.is_seen = false
  AND NOT EXISTS ( -- Ensure it's not a mutual like
      SELECT 1
      FROM likes l2
      WHERE l2.liker_user_id = l.liked_user_id -- The recipient liked the liker back
        AND l2.liked_user_id = l.liker_user_id
  )
`

func (q *Queries) GetUnseenLikeCount(ctx context.Context, likedUserID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getUnseenLikeCount, likedUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserAudioPrompt = `-- name: GetUserAudioPrompt :one
SELECT id, audio_prompt_question, audio_prompt_answer
FROM users
WHERE id = $1 LIMIT 1
`

type GetUserAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) GetUserAudioPrompt(ctx context.Context, id int32) (GetUserAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, getUserAudioPrompt, id)
	var i GetUserAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const getUserConsumable = `-- name: GetUserConsumable :one
SELECT user_id, consumable_type, quantity, updated_at FROM user_consumables
WHERE user_id = $1
  AND consumable_type = $2
`

type GetUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
}

func (q *Queries) GetUserConsumable(ctx context.Context, arg GetUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, getUserConsumable, arg.UserID, arg.ConsumableType)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDateVibesPrompts = `-- name: GetUserDateVibesPrompts :many
SELECT id, user_id, question, answer FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) GetUserDateVibesPrompts(ctx context.Context, userID int32) ([]DateVibesPrompt, error) {
	rows, err := q.db.Query(ctx, getUserDateVibesPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DateVibesPrompt
	for rows.Next() {
		var i DateVibesPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFilters = `-- name: GetUserFilters :one
SELECT user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at FROM filters
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserFilters(ctx context.Context, userID int32) (Filter, error) {
	row := q.db.QueryRow(ctx, getUserFilters, userID)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserGettingPersonalPrompts = `-- name: GetUserGettingPersonalPrompts :many
SELECT id, user_id, question, answer FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) GetUserGettingPersonalPrompts(ctx context.Context, userID int32) ([]GettingPersonalPrompt, error) {
	rows, err := q.db.Query(ctx, getUserGettingPersonalPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GettingPersonalPrompt
	for rows.Next() {
		var i GettingPersonalPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLastOnline = `-- name: GetUserLastOnline :one
SELECT last_online FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserLastOnline(ctx context.Context, id int32) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getUserLastOnline, id)
	var last_online pgtype.Timestamptz
	err := row.Scan(&last_online)
	return last_online, err
}

const getUserMyTypePrompts = `-- name: GetUserMyTypePrompts :many
SELECT id, user_id, question, answer FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) GetUserMyTypePrompts(ctx context.Context, userID int32) ([]MyTypePrompt, error) {
	rows, err := q.db.Query(ctx, getUserMyTypePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyTypePrompt
	for rows.Next() {
		var i MyTypePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOnlineStatus = `-- name: GetUserOnlineStatus :one
SELECT is_online FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserOnlineStatus(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, getUserOnlineStatus, id)
	var is_online bool
	err := row.Scan(&is_online)
	return is_online, err
}

const getUserReactionsForMessages = `-- name: GetUserReactionsForMessages :many
SELECT message_id, emoji
FROM message_reactions
WHERE user_id = $1 AND message_id = ANY($2::bigint[])
`

type GetUserReactionsForMessagesParams struct {
	UserID  int32
	Column2 []int64
}

type GetUserReactionsForMessagesRow struct {
	MessageID int64
	Emoji     string
}

func (q *Queries) GetUserReactionsForMessages(ctx context.Context, arg GetUserReactionsForMessagesParams) ([]GetUserReactionsForMessagesRow, error) {
	rows, err := q.db.Query(ctx, getUserReactionsForMessages, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserReactionsForMessagesRow
	for rows.Next() {
		var i GetUserReactionsForMessagesRow
		if err := rows.Scan(&i.MessageID, &i.Emoji); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSpotlightActivationTimes = `-- name: GetUserSpotlightActivationTimes :many
SELECT
    updated_at as potentially_activated_at,
    u.spotlight_active_until as expires_at
FROM user_consumables uc
JOIN users u ON uc.user_id = u.id
WHERE uc.user_id = $1
  AND uc.consumable_type = 'spotlight'
  AND u.spotlight_active_until IS NOT NULL
  AND (
       ($2::timestamptz IS NULL OR u.spotlight_active_until >= $2)
       AND
       ($3::timestamptz IS NULL OR uc.updated_at <= $3)
      )
ORDER BY u.spotlight_active_until DESC
`

type GetUserSpotlightActivationTimesParams struct {
	UserID    int32
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
}

type GetUserSpotlightActivationTimesRow struct {
	PotentiallyActivatedAt pgtype.Timestamptz
	ExpiresAt              pgtype.Timestamptz
}

func (q *Queries) GetUserSpotlightActivationTimes(ctx context.Context, arg GetUserSpotlightActivationTimesParams) ([]GetUserSpotlightActivationTimesRow, error) {
	rows, err := q.db.Query(ctx, getUserSpotlightActivationTimes, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSpotlightActivationTimesRow
	for rows.Next() {
		var i GetUserSpotlightActivationTimesRow
		if err := rows.Scan(&i.PotentiallyActivatedAt, &i.ExpiresAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryTimePrompts = `-- name: GetUserStoryTimePrompts :many
SELECT id, user_id, question, answer FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) GetUserStoryTimePrompts(ctx context.Context, userID int32) ([]StoryTimePrompt, error) {
	rows, err := q.db.Query(ctx, getUserStoryTimePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StoryTimePrompt
	for rows.Next() {
		var i StoryTimePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logLikeProfileView = `-- name: LogLikeProfileView :exec
INSERT INTO like_profile_views (
    viewer_user_id, liker_user_id, like_id
) VALUES (
    $1, $2, $3
)
`

type LogLikeProfileViewParams struct {
	ViewerUserID int32
	LikerUserID  int32
	LikeID       int32
}

func (q *Queries) LogLikeProfileView(ctx context.Context, arg LogLikeProfileViewParams) error {
	_, err := q.db.Exec(ctx, logLikeProfileView, arg.ViewerUserID, arg.LikerUserID, arg.LikeID)
	return err
}

const logPhotoViewDuration = `-- name: LogPhotoViewDuration :exec
INSERT INTO photo_view_durations (
    viewer_user_id, viewed_user_id, photo_index, duration_ms
) VALUES (
    $1, $2, $3, $4
)
`

type LogPhotoViewDurationParams struct {
	ViewerUserID int32
	ViewedUserID int32
	PhotoIndex   int16
	DurationMs   int32
}

func (q *Queries) LogPhotoViewDuration(ctx context.Context, arg LogPhotoViewDurationParams) error {
	_, err := q.db.Exec(ctx, logPhotoViewDuration,
		arg.ViewerUserID,
		arg.ViewedUserID,
		arg.PhotoIndex,
		arg.DurationMs,
	)
	return err
}

const logUserProfileImpression = `-- name: LogUserProfileImpression :exec
INSERT INTO user_profile_impressions (
    viewer_user_id, shown_user_id, source
) VALUES (
    $1, $2, $3
)
`

type LogUserProfileImpressionParams struct {
	ViewerUserID int32
	ShownUserID  int32
	Source       string
}

func (q *Queries) LogUserProfileImpression(ctx context.Context, arg LogUserProfileImpressionParams) error {
	_, err := q.db.Exec(ctx, logUserProfileImpression, arg.ViewerUserID, arg.ShownUserID, arg.Source)
	return err
}

const markChatAsReadOnUnmatch = `-- name: MarkChatAsReadOnUnmatch :execresult
UPDATE chat_messages
SET is_read = true
WHERE is_read = false
  AND (
       (recipient_user_id = $1 AND sender_user_id = $2)
    OR (recipient_user_id = $2 AND sender_user_id = $1)
  )
`

type MarkChatAsReadOnUnmatchParams struct {
	RecipientUserID int32
	SenderUserID    int32
}

func (q *Queries) MarkChatAsReadOnUnmatch(ctx context.Context, arg MarkChatAsReadOnUnmatchParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, markChatAsReadOnUnmatch, arg.RecipientUserID, arg.SenderUserID)
}

const markLikesAsSeenUntil = `-- name: MarkLikesAsSeenUntil :execresult
UPDATE likes
SET is_seen = true
WHERE liked_user_id = $1
  AND id <= $2
  AND is_seen = false
`

type MarkLikesAsSeenUntilParams struct {
	LikedUserID int32
	ID          int32
}

func (q *Queries) MarkLikesAsSeenUntil(ctx context.Context, arg MarkLikesAsSeenUntilParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, markLikesAsSeenUntil, arg.LikedUserID, arg.ID)
}

const markMessagesAsReadUntil = `-- name: MarkMessagesAsReadUntil :execresult
UPDATE chat_messages
SET is_read = true
WHERE recipient_user_id = $1
  AND sender_user_id = $2
  AND id <= $3
  AND is_read = false
`

type MarkMessagesAsReadUntilParams struct {
	RecipientUserID int32
	SenderUserID    int32
	ID              int64
}

func (q *Queries) MarkMessagesAsReadUntil(ctx context.Context, arg MarkMessagesAsReadUntilParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, markMessagesAsReadUntil, arg.RecipientUserID, arg.SenderUserID, arg.ID)
}

const setUserOffline = `-- name: SetUserOffline :exec
UPDATE users
SET is_online = false,
    last_online = NOW()
WHERE id = $1
`

func (q *Queries) SetUserOffline(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, setUserOffline, id)
	return err
}

const setUserOnline = `-- name: SetUserOnline :exec
UPDATE users
SET is_online = true
WHERE id = $1
`

func (q *Queries) SetUserOnline(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, setUserOnline, id)
	return err
}

const updateAudioPrompt = `-- name: UpdateAudioPrompt :one
UPDATE users
SET audio_prompt_question = $1, audio_prompt_answer = $2
WHERE id = $3
RETURNING id, audio_prompt_question, audio_prompt_answer
`

type UpdateAudioPromptParams struct {
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
	ID                  int32
}

type UpdateAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) UpdateAudioPrompt(ctx context.Context, arg UpdateAudioPromptParams) (UpdateAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, updateAudioPrompt, arg.AudioPromptQuestion, arg.AudioPromptAnswer, arg.ID)
	var i UpdateAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const updateLastOnline = `-- name: UpdateLastOnline :exec
UPDATE users
SET last_online = NOW()
WHERE id = $1
`

func (q *Queries) UpdateLastOnline(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateLastOnline, id)
	return err
}

const updateUserLocationGender = `-- name: UpdateUserLocationGender :one
UPDATE users SET
    latitude = $1,
    longitude = $2,
    gender = $3
WHERE id = $4
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online
`

type UpdateUserLocationGenderParams struct {
	Latitude  pgtype.Float8
	Longitude pgtype.Float8
	Gender    NullGenderEnum
	ID        int32
}

// Updates only the user's latitude, longitude, and gender.
func (q *Queries) UpdateUserLocationGender(ctx context.Context, arg UpdateUserLocationGenderParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserLocationGender,
		arg.Latitude,
		arg.Longitude,
		arg.Gender,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const updateUserMediaURLs = `-- name: UpdateUserMediaURLs :exec
UPDATE users
SET media_urls = $1
WHERE id = $2
`

type UpdateUserMediaURLsParams struct {
	MediaUrls []string
	ID        int32
}

// Sets the media URLs for a user, replacing any existing ones.
func (q *Queries) UpdateUserMediaURLs(ctx context.Context, arg UpdateUserMediaURLsParams) error {
	_, err := q.db.Exec(ctx, updateUserMediaURLs, arg.MediaUrls, arg.ID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one

UPDATE users SET
    name = $1,                -- param $1
    last_name = $2,           -- param $2
    date_of_birth = $3,       -- param $3
    dating_intention = $4,    -- param $4
    height = $5,              -- param $5
    hometown = $6,            -- param $6
    job_title = $7,           -- param $7
    education = $8,           -- param $8
    religious_beliefs = $9,   -- param $9
    drinking_habit = $10,     -- param $10
    smoking_habit = $11       -- param $11
WHERE id = $12                -- param $12
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online
`

type UpdateUserProfileParams struct {
	Name             pgtype.Text
	LastName         pgtype.Text
	DateOfBirth      pgtype.Date
	DatingIntention  NullDatingIntention
	Height           pgtype.Float8
	Hometown         pgtype.Text
	JobTitle         pgtype.Text
	Education        pgtype.Text
	ReligiousBeliefs NullReligion
	DrinkingHabit    NullDrinkingSmokingHabits
	SmokingHabit     NullDrinkingSmokingHabits
	ID               int32
}

// $1 should be 'pending'
// Updates the main profile details, EXCLUDING location and gender.
// Parameter indexes adjusted after removing location/gender params.
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.Name,
		arg.LastName,
		arg.DateOfBirth,
		arg.DatingIntention,
		arg.Height,
		arg.Hometown,
		arg.JobTitle,
		arg.Education,
		arg.ReligiousBeliefs,
		arg.DrinkingHabit,
		arg.SmokingHabit,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET role = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online
`

type UpdateUserRoleParams struct {
	Role UserRole
	ID   int32
}

// Updates the user's role (e.g., to 'admin' or 'user').
func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const updateUserVerificationDetails = `-- name: UpdateUserVerificationDetails :one
UPDATE users
SET
    verification_pic = $1,
    verification_status = $2
WHERE id = $3
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online
`

type UpdateUserVerificationDetailsParams struct {
	VerificationPic    pgtype.Text
	VerificationStatus VerificationStatus
	ID                 int32
}

// Updates the verification picture URL and status together.
func (q *Queries) UpdateUserVerificationDetails(ctx context.Context, arg UpdateUserVerificationDetailsParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationDetails, arg.VerificationPic, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :one
UPDATE users
SET verification_status = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, email, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer, spotlight_active_until, last_online, is_online
`

type UpdateUserVerificationStatusParams struct {
	VerificationStatus VerificationStatus
	ID                 int32
}

// Updates the verification status ('true', 'false', 'pending').
func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationStatus, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.Email,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
		&i.SpotlightActiveUntil,
		&i.LastOnline,
		&i.IsOnline,
	)
	return i, err
}

const upsertMessageReaction = `-- name: UpsertMessageReaction :one
INSERT INTO message_reactions (message_id, user_id, emoji)
VALUES ($1, $2, $3)
ON CONFLICT (message_id, user_id) DO UPDATE SET
    emoji = EXCLUDED.emoji,
    updated_at = NOW()
RETURNING id, message_id, user_id, emoji, created_at, updated_at
`

type UpsertMessageReactionParams struct {
	MessageID int64
	UserID    int32
	Emoji     string
}

func (q *Queries) UpsertMessageReaction(ctx context.Context, arg UpsertMessageReactionParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, upsertMessageReaction, arg.MessageID, arg.UserID, arg.Emoji)
	var i MessageReaction
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.UserID,
		&i.Emoji,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserConsumable = `-- name: UpsertUserConsumable :one
INSERT INTO user_consumables (user_id, consumable_type, quantity)
VALUES ($1, $2, $3) -- $3 is the quantity to add
ON CONFLICT (user_id, consumable_type) DO UPDATE
SET quantity = user_consumables.quantity + EXCLUDED.quantity,
    updated_at = NOW()
RETURNING user_id, consumable_type, quantity, updated_at
`

type UpsertUserConsumableParams struct {
	UserID         int32
	ConsumableType PremiumFeatureType
	Quantity       int32
}

func (q *Queries) UpsertUserConsumable(ctx context.Context, arg UpsertUserConsumableParams) (UserConsumable, error) {
	row := q.db.QueryRow(ctx, upsertUserConsumable, arg.UserID, arg.ConsumableType, arg.Quantity)
	var i UserConsumable
	err := row.Scan(
		&i.UserID,
		&i.ConsumableType,
		&i.Quantity,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserFilters = `-- name: UpsertUserFilters :one
INSERT INTO filters (
    user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (user_id) DO UPDATE SET
    who_you_want_to_see = EXCLUDED.who_you_want_to_see,
    radius_km = EXCLUDED.radius_km,
    active_today = EXCLUDED.active_today,
    age_min = EXCLUDED.age_min,
    age_max = EXCLUDED.age_max,
    updated_at = NOW()
RETURNING user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at
`

type UpsertUserFiltersParams struct {
	UserID          int32
	WhoYouWantToSee NullGenderEnum
	RadiusKm        pgtype.Int4
	ActiveToday     bool
	AgeMin          pgtype.Int4
	AgeMax          pgtype.Int4
}

func (q *Queries) UpsertUserFilters(ctx context.Context, arg UpsertUserFiltersParams) (Filter, error) {
	row := q.db.QueryRow(ctx, upsertUserFilters,
		arg.UserID,
		arg.WhoYouWantToSee,
		arg.RadiusKm,
		arg.ActiveToday,
		arg.AgeMin,
		arg.AgeMax,
	)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

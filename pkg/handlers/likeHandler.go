// pkg/handlers/likeHandler.go
package handlers

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"unicode/utf8"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/arnnvv/peeple-api/pkg/utils"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

const dailyStandardLikeLimit = 15
const maxCommentLength = 140
const profileLikeIdentifier = "profile" // Define placeholder identifier

type ContentLikeRequest struct {
	LikedUserID       int32   `json:"liked_user_id"`
	ContentType       string  `json:"content_type"`       // Receive as string for flexibility
	ContentIdentifier string  `json:"content_identifier"` // Receive as string
	Comment           *string `json:"comment,omitempty"`
	InteractionType   *string `json:"interaction_type,omitempty"` // "standard" or "rose"
}

type LikeResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

func LikeHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()
	pool := db.GetPool()

	if queries == nil || pool == nil {
		log.Println("ERROR: LikeHandler: Database connection not available.")
		utils.RespondWithJSON(w, http.StatusInternalServerError, LikeResponse{Success: false, Message: "Database connection error"})
		return
	}

	if r.Method != http.MethodPost {
		utils.RespondWithJSON(w, http.StatusMethodNotAllowed, LikeResponse{Success: false, Message: "Method Not Allowed: Use POST"})
		return
	}

	claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil || claims.UserID <= 0 {
		utils.RespondWithJSON(w, http.StatusUnauthorized, LikeResponse{Success: false, Message: "Authentication required"})
		return
	}
	likerUserID := int32(claims.UserID)

	// Fetch liker's data (needed for gender check later)
	likerUser, err := queries.GetUserByID(ctx, likerUserID)
	if err != nil {
		log.Printf("ERROR: LikeHandler: Failed to fetch liker user %d: %v", likerUserID, err)
		if errors.Is(err, pgx.ErrNoRows) {
			utils.RespondWithJSON(w, http.StatusNotFound, LikeResponse{Success: false, Message: "Liker user not found"})
		} else {
			utils.RespondWithJSON(w, http.StatusInternalServerError, LikeResponse{Success: false, Message: "Error fetching liker user data"})
		}
		return
	}

	var req ContentLikeRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("ERROR: LikeHandler: Invalid request body for user %d: %v", likerUserID, err)
		utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: "Invalid request body format"})
		return
	}
	defer r.Body.Close()

	// --- Basic Input Validation ---
	if req.LikedUserID <= 0 {
		utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: "Valid liked_user_id is required"})
		return
	}
	if req.LikedUserID == likerUserID {
		utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: "Cannot like yourself"})
		return
	}
	if req.ContentType == "" {
		utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: "content_type is required"})
		return
	}
	if req.ContentIdentifier == "" {
		utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: "content_identifier is required"})
		return
	}

	// --- Convert Content Type String to Enum ---
	// This needs to be updated after regenerating sqlc models to include ContentLikeTypeProfile
	var contentTypeEnum migrations.ContentLikeType
	err = contentTypeEnum.Scan(req.ContentType) // Use the Scan method generated by sqlc
	if err != nil {
		// If scan fails, it's not a valid enum value *defined in your Go code*
		utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: fmt.Sprintf("Invalid content_type specified: %s", req.ContentType)})
		return
	}

	// --- Check if the other user has already liked the current user ---
	reverseLikeExists := false
	reverseLikeParams := migrations.CheckLikeExistsParams{
		LikerUserID: req.LikedUserID, // The user receiving the current like
		LikedUserID: likerUserID,     // The user sending the current like
	}
	existsResult, checkErr := queries.CheckLikeExists(ctx, reverseLikeParams)
	if checkErr != nil && !errors.Is(checkErr, pgx.ErrNoRows) {
		log.Printf("WARN: LikeHandler: Failed to check for existing reverse like (user %d -> %d): %v", req.LikedUserID, likerUserID, checkErr)
		// Proceed cautiously, assuming no reverse like if check fails unexpectedly
	} else if checkErr == nil {
		reverseLikeExists = existsResult
	}

	// --- Content Validation / Profile Like Check ---
	var contentValid bool = false
	var validationErr error

	// ** NEW LOGIC **
	isProfileLikeAttempt := contentTypeEnum == migrations.ContentLikeTypeProfile && req.ContentIdentifier == profileLikeIdentifier

	if isProfileLikeAttempt {
		// This is an attempt to make a "profile" like.
		// ONLY allow it if the other user already liked us (it's a "like back").
		if !reverseLikeExists {
			log.Printf("WARN: LikeHandler: User %d attempted 'profile' like on user %d, but no reverse like exists. Forbidden.", likerUserID, req.LikedUserID)
			utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: "Generic profile like is only allowed when liking someone back."})
			return
		}
		// It's a valid "profile like back" scenario. Skip specific content validation.
		log.Printf("INFO: LikeHandler: Processing 'profile' like back: User %d -> User %d.", likerUserID, req.LikedUserID)
		contentValid = true
		validationErr = nil
	} else {
		// This is an attempt to like specific content (media, prompt, audio).
		// Perform the standard validation.
		log.Printf("INFO: LikeHandler: Processing specific content like: User %d -> User %d, Type=%s, ID=%s", likerUserID, req.LikedUserID, contentTypeEnum, req.ContentIdentifier)
		contentValid, validationErr = validateContentInput(ctx, queries, req.LikedUserID, contentTypeEnum, req.ContentIdentifier)
		if validationErr != nil {
			log.Printf("ERROR: LikeHandler: Error validating specific content input for user %d liking %d: %v", likerUserID, req.LikedUserID, validationErr)
			utils.RespondWithJSON(w, http.StatusInternalServerError, LikeResponse{Success: false, Message: "Error validating content"})
			return
		}
		if !contentValid {
			log.Printf("WARN: LikeHandler: Specific content invalid/not found for user %d liking %d: Type=%s, Identifier=%s", likerUserID, req.LikedUserID, contentTypeEnum, req.ContentIdentifier)
			utils.RespondWithJSON(w, http.StatusNotFound, LikeResponse{Success: false, Message: "The specific content you tried to like does not exist or is invalid."})
			return
		}
		log.Printf("INFO: Specific content validation passed for like request: User=%d -> User=%d", likerUserID, req.LikedUserID)
	}
	// ** END NEW LOGIC **

	// --- Comment Validation and Requirement Check ---
	commentText := ""
	commentProvided := false
	if req.Comment != nil {
		commentText = strings.TrimSpace(*req.Comment)
		if commentText != "" {
			commentProvided = true
			if utf8.RuneCountInString(commentText) > maxCommentLength {
				utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: fmt.Sprintf("Comment exceeds maximum length of %d characters", maxCommentLength)})
				return
			}
		}
	}

	// Check if a comment is required (only for initial likes from men on specific content)
	commentRequired := false
	// isMutualLike is true if the *current* like completes the match (i.e., reverseLikeExists was true)
	isMutualLike := reverseLikeExists
	if !isMutualLike && !commentProvided && !isProfileLikeAttempt {
		// Comment might be required if it's NOT a mutual like, no comment was given, AND it's not a profile like.
		if likerUser.Gender.Valid && likerUser.Gender.GenderEnum == migrations.GenderEnumMan {
			commentRequired = true
			log.Printf("WARN: LikeHandler: Comment required for initial specific content like from male user %d to %d", likerUserID, req.LikedUserID)
		} else {
			log.Printf("INFO: LikeHandler: Allowing initial specific content like without comment from non-male/unknown-gender user %d to %d", likerUserID, req.LikedUserID)
		}
	} else if isMutualLike && !commentProvided {
		log.Printf("INFO: LikeHandler: Allowing empty comment for mutual like scenario or profile like back between %d and %d", likerUserID, req.LikedUserID)
	}

	if commentRequired {
		utils.RespondWithJSON(w, http.StatusBadRequest, LikeResponse{Success: false, Message: "Comment is required when sending an initial like on specific content"})
		return
	}

	// --- Determine Interaction Type (Standard vs. Rose) ---
	interactionType := migrations.LikeInteractionTypeStandard
	if req.InteractionType != nil && strings.ToLower(*req.InteractionType) == string(migrations.LikeInteractionTypeRose) {
		interactionType = migrations.LikeInteractionTypeRose
	}

	log.Printf("INFO: Like attempt: User=%d -> User=%d, Type=%s, Content=%s:%s, CommentPresent=%t, IsProfileLike=%t",
		likerUserID, req.LikedUserID, interactionType, contentTypeEnum, req.ContentIdentifier, commentProvided, isProfileLikeAttempt)

	// --- Prepare Like Parameters ---
	addLikeParams := migrations.AddContentLikeParams{
		LikerUserID:       likerUserID,
		LikedUserID:       req.LikedUserID,
		ContentType:       contentTypeEnum,       // Use the validated enum
		ContentIdentifier: req.ContentIdentifier, // Use the potentially modified identifier
		Comment:           pgtype.Text{String: commentText, Valid: commentProvided},
		InteractionType:   interactionType,
	}

	// --- Process Like based on Type ---
	var likeErr error
	if interactionType == migrations.LikeInteractionTypeRose {
		likeErr = handleRoseLike(ctx, queries, pool, addLikeParams)
		if likeErr != nil {
			log.Printf("ERROR: LikeHandler: Failed rose like: User=%d -> User=%d, Error=%v", likerUserID, req.LikedUserID, likeErr)
			status := http.StatusInternalServerError
			msg := "Failed to process rose like"
			if errors.Is(likeErr, ErrInsufficientConsumables) {
				status = http.StatusForbidden
				msg = likeErr.Error()
			} else if errors.Is(likeErr, ErrLikeAlreadyExists) {
				status = http.StatusConflict
				msg = likeErr.Error() // Return the specific error message
			}
			utils.RespondWithJSON(w, status, LikeResponse{Success: false, Message: msg})
			return
		}
		utils.RespondWithJSON(w, http.StatusOK, LikeResponse{Success: true, Message: "Rose sent successfully"})

	} else { // Standard Like
		likeErr = handleStandardLike(ctx, queries, addLikeParams)
		if likeErr != nil {
			log.Printf("ERROR: LikeHandler: Failed standard like: User=%d -> User=%d, Error=%v", likerUserID, req.LikedUserID, likeErr)
			status := http.StatusInternalServerError
			msg := "Failed to process like"
			if errors.Is(likeErr, ErrLikeLimitReached) {
				status = http.StatusForbidden
				msg = likeErr.Error()
			} else if errors.Is(likeErr, ErrLikeAlreadyExists) {
				status = http.StatusConflict
				msg = likeErr.Error() // Return the specific error message
			}
			utils.RespondWithJSON(w, status, LikeResponse{Success: false, Message: msg})
			return
		}
		utils.RespondWithJSON(w, http.StatusOK, LikeResponse{Success: true, Message: "Liked successfully"})
	}
}

// Custom error types for specific like failures
var ErrInsufficientConsumables = errors.New("insufficient consumables (e.g., roses)")
var ErrLikeLimitReached = errors.New("daily like limit reached")
var ErrLikeAlreadyExists = errors.New("you have already liked this specific item") // Keep this specific error

// handleRoseLike processes a like using a Rose consumable within a transaction.
// (Keep this function exactly as it was in the previous correct version)
func handleRoseLike(ctx context.Context, queries *migrations.Queries, pool *pgxpool.Pool, params migrations.AddContentLikeParams) error {
	// 1. Check Rose Balance
	consumable, err := queries.GetUserConsumable(ctx, migrations.GetUserConsumableParams{UserID: params.LikerUserID, ConsumableType: migrations.PremiumFeatureTypeRose})
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("WARN: handleRoseLike: No roses found for user %d", params.LikerUserID)
			return ErrInsufficientConsumables
		}
		log.Printf("ERROR: handleRoseLike: DB error checking rose balance for user %d: %v", params.LikerUserID, err)
		return fmt.Errorf("db error checking balance: %w", err)
	}
	if consumable.Quantity <= 0 {
		log.Printf("WARN: handleRoseLike: Insufficient roses (0) for user %d", params.LikerUserID)
		return ErrInsufficientConsumables
	}

	// 2. Start Transaction
	tx, err := pool.Begin(ctx)
	if err != nil {
		log.Printf("ERROR: handleRoseLike: Failed to begin transaction for user %d: %v", params.LikerUserID, err)
		return fmt.Errorf("begin transaction error: %w", err)
	}
	defer tx.Rollback(ctx) // Ensure rollback on error

	qtx := queries.WithTx(tx) // Use transactional queries

	// 3. Decrement Rose Consumable
	_, err = qtx.DecrementUserConsumable(ctx, migrations.DecrementUserConsumableParams{UserID: params.LikerUserID, ConsumableType: migrations.PremiumFeatureTypeRose})
	if err != nil {
		// Check if decrement failed because quantity was already 0 (race condition?)
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("WARN: handleRoseLike: Failed to decrement rose for user %d (likely insufficient quantity during tx): %v", params.LikerUserID, err)
			return ErrInsufficientConsumables // Return the specific error
		}
		log.Printf("ERROR: handleRoseLike: Failed to use rose for user %d: %v", params.LikerUserID, err)
		return fmt.Errorf("failed to use rose: %w", err) // Generic DB error
	}
	log.Printf("DEBUG: handleRoseLike: Rose decremented successfully for user %d", params.LikerUserID)

	// 4. Add the Like entry
	_, err = qtx.AddContentLike(ctx, params)
	if err != nil {
		// Use the UNIQUE constraint uq_like_item (liker_user_id, liked_user_id, content_type, content_identifier)
		// If AddContentLike fails due to this constraint, it might return a specific error code or just a general error.
		// Testing or checking pgx documentation for the specific error type is needed.
		// Assuming pgx.ErrNoRows is returned because RETURNING yields nothing on conflict:
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("WARN: handleRoseLike: Like for item already exists (Conflict Detected by RETURNING): User=%d -> User=%d, Type=%s, ID=%s", params.LikerUserID, params.LikedUserID, params.ContentType, params.ContentIdentifier)
			// Return the specific error; the transaction rollback handles the decremented rose.
			return ErrLikeAlreadyExists
		}
		// Handle other potential database errors during like insertion
		log.Printf("ERROR: handleRoseLike: Failed to record like for user %d: %v", params.LikerUserID, err)
		return fmt.Errorf("failed to record like: %w", err)
	}

	// 5. Commit Transaction
	if err = tx.Commit(ctx); err != nil {
		log.Printf("ERROR: handleRoseLike: Failed to commit transaction for user %d: %v", params.LikerUserID, err)
		return fmt.Errorf("commit transaction error: %w", err)
	}

	log.Printf("INFO: Rose like processed successfully: User=%d -> User=%d, Content=%s:%s", params.LikerUserID, params.LikedUserID, params.ContentType, params.ContentIdentifier)
	return nil // Success
}

// handleStandardLike processes a regular like, checking limits if applicable.
// (Keep this function exactly as it was in the previous correct version)
func handleStandardLike(ctx context.Context, queries *migrations.Queries, params migrations.AddContentLikeParams) error {
	// 1. Check for Unlimited Likes subscription
	_, err := queries.GetActiveSubscription(ctx, migrations.GetActiveSubscriptionParams{UserID: params.LikerUserID, FeatureType: migrations.PremiumFeatureTypeUnlimitedLikes})
	hasUnlimitedLikes := err == nil // If no error (and not ErrNoRows), subscription exists
	if err != nil && !errors.Is(err, pgx.ErrNoRows) {
		// Log unexpected DB error during subscription check
		log.Printf("ERROR: handleStandardLike: DB error checking subscription for user %d: %v", params.LikerUserID, err)
		return fmt.Errorf("db error checking subscription: %w", err)
	}

	// 2. Check Daily Limit if user does NOT have unlimited likes
	if !hasUnlimitedLikes {
		log.Printf("INFO: handleStandardLike: Checking daily like limit for User=%d", params.LikerUserID)
		count, countErr := queries.CountRecentStandardLikes(ctx, params.LikerUserID)
		if countErr != nil {
			log.Printf("ERROR: handleStandardLike: DB error counting likes for user %d: %v", params.LikerUserID, countErr)
			return fmt.Errorf("db error counting likes: %w", countErr)
		}
		if count >= dailyStandardLikeLimit {
			log.Printf("WARN: handleStandardLike: Daily like limit reached for User=%d (%d/%d)", params.LikerUserID, count, dailyStandardLikeLimit)
			return ErrLikeLimitReached // Return the specific error
		}
		log.Printf("INFO: handleStandardLike: Processing standard like (limited %d/%d): User=%d -> User=%d", count, dailyStandardLikeLimit, params.LikerUserID, params.LikedUserID)
	} else {
		log.Printf("INFO: handleStandardLike: Processing standard like (unlimited): User=%d -> User=%d", params.LikerUserID, params.LikedUserID)
	}

	// 3. Add the Like entry
	_, err = queries.AddContentLike(ctx, params)
	if err != nil {
		// Check if the error is specifically because the like already exists
		// Again, assuming pgx.ErrNoRows indicates a conflict due to RETURNING nothing
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("WARN: handleStandardLike: Like for item already exists (Conflict Detected by RETURNING): User=%d -> User=%d, Type=%s, ID=%s", params.LikerUserID, params.LikedUserID, params.ContentType, params.ContentIdentifier)
			return ErrLikeAlreadyExists
		}
		// Handle other potential database errors
		log.Printf("ERROR: handleStandardLike: Failed to record like for user %d: %v", params.LikerUserID, err)
		return fmt.Errorf("failed to record like: %w", err)
	}

	log.Printf("INFO: Standard like processed successfully: User=%d -> User=%d, Content=%s:%s", params.LikerUserID, params.LikedUserID, params.ContentType, params.ContentIdentifier)
	return nil // Success
}

// validateContentInput checks if the specified content exists for the liked user.
// Needs to be aware of the 'profile' type but doesn't need to validate it here
// as the main handler now performs the conditional check.
func validateContentInput(ctx context.Context, queries *migrations.Queries, likedUserID int32, contentType migrations.ContentLikeType, contentIdentifier string) (bool, error) {
	// ** IMPORTANT: The main handler now bypasses this function for ContentLikeTypeProfile **
	// This function now only needs to handle specific content types.

	log.Printf("DEBUG: Validating specific content: User=%d, Type=%s, Identifier=%s", likedUserID, contentType, contentIdentifier)

	// Fetch the user being liked to check their content
	likedUser, err := queries.GetUserByID(ctx, likedUserID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("WARN: validateContentInput: Liked user %d not found.", likedUserID)
			return false, nil // User doesn't exist
		}
		log.Printf("ERROR: validateContentInput: Failed to fetch liked user %d: %v", likedUserID, err)
		return false, fmt.Errorf("failed to fetch liked user %d: %w", likedUserID, err)
	}

	// Validate based on content type
	switch contentType {
	case migrations.ContentLikeTypeMedia:
		index, err := strconv.Atoi(contentIdentifier)
		if err != nil {
			log.Printf("WARN: validateContentInput: Invalid media index '%s' for user %d: %v", contentIdentifier, likedUserID, err)
			return false, nil
		}
		isValidIndex := index >= 0 && index < len(likedUser.MediaUrls)
		if !isValidIndex {
			log.Printf("WARN: validateContentInput: Media index %d out of bounds for user %d (has %d media)", index, likedUserID, len(likedUser.MediaUrls))
		}
		return isValidIndex, nil

	case migrations.ContentLikeTypeAudioPrompt:
		isValid := contentIdentifier == "0" && likedUser.AudioPromptQuestion.Valid && likedUser.AudioPromptAnswer.Valid && likedUser.AudioPromptAnswer.String != ""
		if !isValid {
			log.Printf("WARN: validateContentInput: Invalid audio prompt like for user %d: Identifier='%s', AudioQuestionValid=%t, AudioAnswerValid=%t", likedUserID, contentIdentifier, likedUser.AudioPromptQuestion.Valid, likedUser.AudioPromptAnswer.Valid)
		}
		return isValid, nil

	case migrations.ContentLikeTypePromptStory:
		prompts, err := queries.GetUserStoryTimePrompts(ctx, likedUserID)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return false, nil
			}
			log.Printf("ERROR: validateContentInput: DB error fetching story prompts for user %d: %v", likedUserID, err)
			return false, fmt.Errorf("db error fetching story prompts: %w", err)
		}
		for _, p := range prompts {
			if string(p.Question) == contentIdentifier {
				return true, nil
			}
		}
		log.Printf("WARN: validateContentInput: Story prompt '%s' not found for user %d", contentIdentifier, likedUserID)
		return false, nil

	case migrations.ContentLikeTypePromptMytype:
		prompts, err := queries.GetUserMyTypePrompts(ctx, likedUserID)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return false, nil
			}
			log.Printf("ERROR: validateContentInput: DB error fetching mytype prompts for user %d: %v", likedUserID, err)
			return false, fmt.Errorf("db error fetching mytype prompts: %w", err)
		}
		for _, p := range prompts {
			if string(p.Question) == contentIdentifier {
				return true, nil
			}
		}
		log.Printf("WARN: validateContentInput: MyType prompt '%s' not found for user %d", contentIdentifier, likedUserID)
		return false, nil

	case migrations.ContentLikeTypePromptGettingpersonal:
		prompts, err := queries.GetUserGettingPersonalPrompts(ctx, likedUserID)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return false, nil
			}
			log.Printf("ERROR: validateContentInput: DB error fetching gettingpersonal prompts for user %d: %v", likedUserID, err)
			return false, fmt.Errorf("db error fetching gettingpersonal prompts: %w", err)
		}
		for _, p := range prompts {
			if string(p.Question) == contentIdentifier {
				return true, nil
			}
		}
		log.Printf("WARN: validateContentInput: GettingPersonal prompt '%s' not found for user %d", contentIdentifier, likedUserID)
		return false, nil

	case migrations.ContentLikeTypePromptDatevibes:
		prompts, err := queries.GetUserDateVibesPrompts(ctx, likedUserID)
		if err != nil {
			if errors.Is(err, pgx.ErrNoRows) {
				return false, nil
			}
			log.Printf("ERROR: validateContentInput: DB error fetching datevibes prompts for user %d: %v", likedUserID, err)
			return false, fmt.Errorf("db error fetching datevibes prompts: %w", err)
		}
		for _, p := range prompts {
			if string(p.Question) == contentIdentifier {
				return true, nil
			}
		}
		log.Printf("WARN: validateContentInput: DateVibes prompt '%s' not found for user %d", contentIdentifier, likedUserID)
		return false, nil

	case migrations.ContentLikeTypeProfile:
		// This case should ideally not be reached if the main handler logic is correct.
		log.Printf("ERROR: validateContentInput: Reached 'profile' type validation unexpectedly. This should be handled earlier.")
		return false, fmt.Errorf("internal error: profile type should not be validated here")

	default:
		log.Printf("ERROR: validateContentInput: Unknown content type encountered: %s", contentType)
		return false, fmt.Errorf("unknown content_type for validation: %s", contentType)
	}
}

Directory structure:
└── peeple-api/
    ├── Dockerfile
    ├── go.mod
    ├── go.sum
    ├── main.go
    ├── seed_test_data.sql
    ├── sqlc.yml
    ├── .dockerignore
    ├── .env.example
    ├── assets/
    ├── db/
    │   ├── queries.sql
    │   └── schema.sql
    ├── migrations/
    │   ├── db.go
    │   ├── models.go
    │   └── queries.sql.go
    ├── pkg/
    │   ├── db/
    │   │   └── db.go
    │   ├── handlers/
    │   │   ├── adminHandler.go
    │   │   ├── appOpenHandler.go
    │   │   ├── audio.go
    │   │   ├── checkauthstatus.go
    │   │   ├── createprofile.go
    │   │   ├── filtersHandler.go
    │   │   ├── getPendingVerification.go
    │   │   ├── homeFeedHandler.go
    │   │   ├── imagehandler.go
    │   │   ├── newuser.go
    │   │   ├── profileHandler.go
    │   │   ├── protectedHandler.go
    │   │   ├── sendotp.go
    │   │   ├── testHandler.go
    │   │   ├── updateVerificationStatus.go
    │   │   ├── verifyProfileHandler.go
    │   │   └── verifyotp.go
    │   ├── token/
    │   │   ├── adminAuthMiddleware.go
    │   │   ├── claims.go
    │   │   ├── generate.go
    │   │   ├── keys.go
    │   │   └── middleware.go
    │   └── utils/
    │       └── utils.go
    └── .github/
        └── workflows/
            └── deploy.yml

================================================
File: Dockerfile
================================================
FROM golang:1.24.2-alpine3.21 as builder

RUN apk add --no-cache git
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .

RUN go build -o api

FROM gcr.io/distroless/static:nonroot
COPY --from=builder --chmod=0755 /app/api /api
USER nonroot:nonroot
ENTRYPOINT ["/api"]



================================================
File: go.mod
================================================
module github.com/arnnvv/peeple-api

go 1.24.2

require (
	github.com/aws/aws-sdk-go v1.55.6
	github.com/golang-jwt/jwt/v5 v5.2.2
	github.com/jackc/pgx/v5 v5.7.4
)

require (
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jmespath/go-jmespath v0.4.0 // indirect
	golang.org/x/crypto v0.31.0 // indirect
	golang.org/x/sync v0.10.0 // indirect
	golang.org/x/text v0.21.0 // indirect
)



================================================
File: go.sum
================================================
github.com/aws/aws-sdk-go v1.55.6 h1:cSg4pvZ3m8dgYcgqB97MrcdjUmZ1BeMYKUxMMB89IPk=
github.com/aws/aws-sdk-go v1.55.6/go.mod h1:eRwEWoyTWFMVYVQzKMNHWP5/RV4xIUGMQfXQHfHkpNU=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/golang-jwt/jwt/v5 v5.2.2 h1:Rl4B7itRWVtYIHFrSNd7vhTiz9UpLdi6gZhZ3wEeDy8=
github.com/golang-jwt/jwt/v5 v5.2.2/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.7.4 h1:9wKznZrhWa2QiHL+NjTSPP6yjl3451BX3imWDnokYlg=
github.com/jackc/pgx/v5 v5.7.4/go.mod h1:ncY89UGWxg82EykZUwSpUKEfccBGGYq1xjrOpsbsfGQ=
github.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=
github.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=
github.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=
github.com/jmespath/go-jmespath/internal/testify v1.5.1 h1:shLQSRRSCCPj3f2gpwzGwWFoC7ycTf1rcQZHOlsJ6N8=
github.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
golang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=
golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
golang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=
golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.8 h1:obN1ZagJSUGI0Ek/LBmuj4SNLPfIny3KsKFopxRdj10=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=



================================================
File: main.go
================================================
package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"runtime"
	"time"

	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/handlers"
	"github.com/arnnvv/peeple-api/pkg/token"
)

func main() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	port := os.Getenv("PORT")

	server := &http.Server{
		Addr:              ":" + port,
		ReadHeaderTimeout: 2 * time.Second,
		WriteTimeout:      5 * time.Second,
		IdleTimeout:       30 * time.Second,
	}

	http.HandleFunc("/", token.AuthMiddleware(handlers.ProtectedHandler))
	http.HandleFunc("/token", token.GenerateTokenHandler)
	http.HandleFunc("/upload", token.AuthMiddleware(handlers.GeneratePresignedURLs))
	http.HandleFunc("/audio", token.AuthMiddleware(handlers.GenerateAudioPresignedURL))
	http.HandleFunc("/get-profile", token.AuthMiddleware(handlers.ProfileHandler))
	http.HandleFunc("/api/profile", token.AuthMiddleware(handlers.CreateProfile))
	http.HandleFunc("/api/auth-status", token.AuthMiddleware(handlers.CheckAuthStatus))
	http.HandleFunc("/verify", token.AuthMiddleware(handlers.GenerateVerificationPresignedURL))
	http.HandleFunc("/api/send-otp", handlers.SendOTP)
	http.HandleFunc("/api/verify-otp", handlers.VerifyOTP)
	http.HandleFunc("/api/set-admin", token.AdminAuthMiddleware(handlers.SetAdminHandler))
	http.HandleFunc("/api/admin/verifications", token.AdminAuthMiddleware(handlers.GetPendingVerificationsHandler))
	http.HandleFunc("/api/admin/verify", token.AdminAuthMiddleware(handlers.UpdateVerificationStatusHandler))
	http.HandleFunc("/api/filters", token.AuthMiddleware(handlers.ApplyFiltersHandler))
	http.HandleFunc("/api/app-opened", token.AuthMiddleware(handlers.LogAppOpenHandler))
	http.HandleFunc("/api/homefeed", token.AuthMiddleware(handlers.GetHomeFeedHandler)) // <-- ADDED ROUTE
	http.HandleFunc("/test", handlers.TestHandler)

	go cleanupExpiredOTPs()

	log.Printf("Server is running on http://localhost:%s\n", port)
	if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatal(err)
	}
}

func cleanupExpiredOTPs() {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		db.GetDB().CleanOTPs(context.Background())
	}
}



================================================
File: seed_test_data.sql
================================================
-- ====================================================================
-- Peeple API Test Data Seeding Script
-- ====================================================================

-- Start Transaction
BEGIN;

-- Clean existing test data (optional but recommended for repeatable testing)
-- CASCADE will follow foreign keys
TRUNCATE TABLE likes CASCADE;
TRUNCATE TABLE dislikes CASCADE;
TRUNCATE TABLE app_open_logs CASCADE;
TRUNCATE TABLE filters CASCADE;
-- Delete specific user range or TRUNCATE users if acceptable for testing
DELETE FROM users WHERE id BETWEEN 1 AND 20;

-- Reset sequences (Important for predictable IDs like 1, 2, 3...)
-- Adjust sequence names if they differ ('public.' prefix might be needed sometimes)
SELECT setval(pg_get_serial_sequence('users', 'id'), COALESCE((SELECT MAX(id) FROM users), 0) + 1, false);
SELECT setval(pg_get_serial_sequence('app_open_logs', 'id'), COALESCE((SELECT MAX(id) FROM app_open_logs), 0) + 1, false);


-- Insert Test Users (Corrected multi-row INSERT syntax)
INSERT INTO users (id, name, phone_number, gender, date_of_birth, latitude, longitude, media_urls, created_at) VALUES
    (1, 'Alice', '1110000001', 'woman',   '1995-05-15', 40.7128, -74.0060, '{"img_alice1.jpg", "vid_alice1.mp4"}', NOW() - INTERVAL '10 days'),
    (2, 'Bob',   '1110000002', 'man',     '1993-08-20', 40.7135, -74.0050, '{"img_bob1.jpg"}', NOW() - INTERVAL '5 days'),
    (3, 'Charlie','1110000003', 'man',     '1997-01-10', 40.7580, -73.9855, '{"img_charlie1.jpg"}', NOW() - INTERVAL '8 days'),
    (4, 'David', '1110000004', 'man',     '1994-11-05', 34.0522, -118.2437,'{"img_david1.jpg"}', NOW() - INTERVAL '12 days'),
    (5, 'Eve',   '1110000005', 'woman',   '1996-03-25', 40.7120, -74.0070, '{"img_eve1.jpg"}', NOW() - INTERVAL '3 days'),
    (6, 'Frank', '1110000006', 'man',     '1987-07-12', 40.7140, -74.0045, '{"img_frank1.jpg"}', NOW() - INTERVAL '20 days'),
    (7, 'Grace', '1110000007', 'man',     '1996-09-30', 40.7130, -74.0065, '{"img_grace1.jpg"}', NOW() - INTERVAL '6 days'),
    (8, 'Hank',  '1110000008', 'man',     '1994-06-18', 40.7125, -74.0055, '{"img_hank1.jpg"}', NOW() - INTERVAL '15 days'),
    (9, 'Ivy',   '1110000009', 'man',     '1992-12-22', 40.7132, -74.0048, '{"img_ivy1.jpg"}', NOW() - INTERVAL '18 days'),
    (10,'Jack',  '1110000010', 'man',     '1991-02-01', 40.7138, -74.0052, '{"img_jack1.jpg"}', NOW() - INTERVAL '25 days'),
    (11,'Ken',   '1110000011', 'man',     '1996-04-14', 40.7129, -74.0062, '{"img_ken1.jpg"}', NOW() - INTERVAL '9 days'),
    (12,'Liam',  '1110000012', 'man',     '1995-01-05', 40.7127, -74.0061, '{"img_liam1.jpg"}', NOW() - INTERVAL '2 days'),
    (13,'Mia',   '1110000013', 'man',     '1999-10-10', 40.7133, -74.0058, '{}', NOW() - INTERVAL '4 days'),
    (14,'Noah',  '1110000014', 'man',     '1990-03-15', 40.7142, -74.0040, '{"img_noah1.jpg"}', NOW() - INTERVAL '30 days'),
    (15,'Olivia','1110000015', 'man',     '1993-07-20', 40.7122, -74.0068, '{"img_olivia1.jpg"}', NOW() - INTERVAL '1 day'),
    (16,'Peter', '1110000016', 'man',     '1994-08-25', 40.7100, -74.0100, '{"img_peter1.jpg"}', NOW() - INTERVAL '7 days'),
    (17,'Quinn', '1110000017', 'man',     '1995-09-01', 40.6892, -74.0445, '{"img_quinn1.jpg"}', NOW() - INTERVAL '11 days');


-- Insert Filters (Using multiple INSERT statements is fine too)
INSERT INTO filters (user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max) VALUES
    (1, 'man', 20, true, 28, 36),
    (2, 'woman', 50, false, 28, 38),
    (3, 'woman', NULL, true, 25, 35),
    (4, 'woman', 100, true, 25, 40),
    -- Eve (5) - No filter needed for test
    (6, 'woman', 30, false, 30, 45),
    (7, 'man', 30, true, 25, 35),
    (8, 'woman', 40, true, 25, 35),
    (9, 'woman', 50, false, 28, 38),
    (10,'woman', 60, true, 29, 39),
    (11,'woman', 25, false, 25, 33),
    (12,'woman', 15, true, 26, 34),
    (13,'woman', NULL, true, 22, 30),
    (14,'woman', 20, true, 30, 40),
    (15,'woman', 25, true, 27, 35),
    -- Peter (16) - No filters
    (17,'woman', 50, true, 26, 36);


-- Insert App Open Logs
INSERT INTO app_open_logs (user_id, opened_at) VALUES
    (2, NOW()),
    (3, NOW() - INTERVAL '5 hour'),
    (4, NOW()),
    (6, NOW() - INTERVAL '10 minute'),
    (7, NOW()),
    (8, NOW() - INTERVAL '1 hour'),
    (9, NOW()),
    (10, NOW() - INTERVAL '2 hour'),
    (11, NOW() - INTERVAL '3 day'), -- Ken INACTIVE
    (12, NOW() - INTERVAL '5 minute'),
    (13, NOW()),
    (14, NOW() - INTERVAL '1 day'), -- Noah INACTIVE
    (15, NOW() - INTERVAL '30 minute'),
    (16, NOW()),
    (17, NOW() - INTERVAL '6 hour');


-- Insert Likes FROM Alice (ID 1)
INSERT INTO likes (liker_user_id, liked_user_id) VALUES
    (1, 8);  -- Alice liked Hank


-- Insert Dislikes involving Alice (ID 1)
INSERT INTO dislikes (disliker_user_id, disliked_user_id) VALUES
    (1, 9),   -- Alice disliked Ivy
    (10, 1);  -- Jack disliked Alice


-- Commit Transaction
COMMIT;

-- Optional: Query to verify data after running
-- SELECT u.id, u.name, f.who_you_want_to_see, f.radius_km, f.active_today, f.age_min, f.age_max FROM users u LEFT JOIN filters f ON u.id = f.user_id WHERE u.id BETWEEN 1 AND 20 ORDER BY u.id;
-- SELECT * FROM app_open_logs WHERE user_id BETWEEN 1 AND 20 ORDER BY user_id, opened_at DESC;
-- SELECT * FROM likes WHERE liker_user_id = 1 OR liked_user_id = 1;
-- SELECT * FROM dislikes WHERE disliker_user_id = 1 OR disliked_user_id = 1;



================================================
File: sqlc.yml
================================================
version: "2"
sql:
  - engine: "postgresql"
    queries: "db/queries.sql"
    schema: "db/schema.sql"
    gen:
      go:
        package: "migrations"
        out: "./migrations"
        sql_package: "pgx/v5"



================================================
File: .dockerignore
================================================
api
.env
.git/
assets/
.github
.gitignore
.env.example



================================================
File: .env.example
================================================
DATABASE_URL=
JWT_SECRET=
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=
S3_BUCKET=
PORT=




================================================
File: db/queries.sql
================================================
-- name: CleanOTP :exec
DELETE FROM otps
WHERE expires_at < NOW();

-- name: DeleteOTPsByPhoneNumber :exec
DELETE FROM otps
WHERE user_id = (SELECT id FROM users WHERE phone_number = $1);

-- name: GetUserByID :one
SELECT * FROM users
WHERE id = $1 LIMIT 1;

-- name: GetUserByPhone :one
SELECT * FROM users
WHERE phone_number = $1 LIMIT 1;

-- name: GetPendingVerificationUsers :many
SELECT * FROM users
WHERE verification_status = $1; -- $1 should be 'pending'

-- name: AddPhoneNumberInUsers :one
INSERT INTO users (
    phone_number
) VALUES (
    $1
)
RETURNING *;

-- name: CreateUserMinimal :one
INSERT INTO users (
    phone_number, gender
) VALUES (
    $1, $2
)
RETURNING *;

-- name: UpdateUserProfile :one
UPDATE users SET
    name = $1,
    last_name = $2,
    date_of_birth = $3,
    latitude = $4,
    longitude = $5,
    gender = $6,
    dating_intention = $7,
    height = $8,
    hometown = $9,
    job_title = $10,
    education = $11,
    religious_beliefs = $12,
    drinking_habit = $13,
    smoking_habit = $14
WHERE id = $15
RETURNING *;

-- name: UpdateUserRole :one
UPDATE users
SET role = $1
WHERE id = $2
RETURNING *;

-- name: ClearUserMediaURLs :exec
UPDATE users
SET media_urls = '{}'
WHERE id = $1;

-- name: UpdateUserMediaURLs :exec
UPDATE users
SET media_urls = $1
WHERE id = $2;

-- name: UpdateUserVerificationStatus :one
UPDATE users
SET verification_status = $1
WHERE id = $2
RETURNING *;

-- name: UpdateUserVerificationDetails :one
UPDATE users
SET
    verification_pic = $1,
    verification_status = $2
WHERE id = $3
RETURNING *;

-- name: GetOTPByUser :one
SELECT * FROM otps
WHERE user_id = $1
ORDER BY id DESC
LIMIT 1;

-- name: CreateOTP :one
INSERT INTO otps (
    user_id, otp_code
) VALUES (
    $1, $2
)
RETURNING *;

-- name: DeleteOTPByID :exec
DELETE FROM otps
WHERE id = $1;

-- name: DeleteOTPByUser :exec
DELETE FROM otps
WHERE user_id = $1;

-- name: CleanOTPs :exec
DELETE FROM otps
WHERE expires_at < NOW();

-- name: DeleteUserStoryTimePrompts :exec
DELETE FROM story_time_prompts WHERE user_id = $1;

-- name: DeleteUserMyTypePrompts :exec
DELETE FROM my_type_prompts WHERE user_id = $1;

-- name: DeleteUserGettingPersonalPrompts :exec
DELETE FROM getting_personal_prompts WHERE user_id = $1;

-- name: DeleteUserDateVibesPrompts :exec
DELETE FROM date_vibes_prompts WHERE user_id = $1;

-- name: CreateStoryTimePrompt :one
INSERT INTO story_time_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING *;

-- name: CreateMyTypePrompt :one
INSERT INTO my_type_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING *;

-- name: CreateGettingPersonalPrompt :one
INSERT INTO getting_personal_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING *;

-- name: CreateDateVibesPrompt :one
INSERT INTO date_vibes_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING *;

-- name: GetUserStoryTimePrompts :many
SELECT * FROM story_time_prompts WHERE user_id = $1;

-- name: GetUserMyTypePrompts :many
SELECT * FROM my_type_prompts WHERE user_id = $1;

-- name: GetUserGettingPersonalPrompts :many
SELECT * FROM getting_personal_prompts WHERE user_id = $1;

-- name: GetUserDateVibesPrompts :many
SELECT * FROM date_vibes_prompts WHERE user_id = $1;

-- name: GetUserAudioPrompt :one
SELECT id, audio_prompt_question, audio_prompt_answer
FROM users
WHERE id = $1 LIMIT 1;

-- name: UpdateAudioPrompt :one
UPDATE users
SET audio_prompt_question = $1, audio_prompt_answer = $2
WHERE id = $3
RETURNING id, audio_prompt_question, audio_prompt_answer;

-- name: UpsertUserFilters :one
INSERT INTO filters (
    user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (user_id) DO UPDATE SET
    who_you_want_to_see = EXCLUDED.who_you_want_to_see,
    radius_km = EXCLUDED.radius_km,
    active_today = EXCLUDED.active_today,
    age_min = EXCLUDED.age_min,
    age_max = EXCLUDED.age_max,
    updated_at = NOW()
RETURNING *;

-- name: GetUserFilters :one
SELECT * FROM filters
WHERE user_id = $1 LIMIT 1;

-- name: LogAppOpen :exec
INSERT INTO app_open_logs (user_id)
VALUES ($1);

-- name: AddDislike :exec
-- name: AddDislike :exec
INSERT INTO dislikes (disliker_user_id, disliked_user_id)
VALUES ($1, $2)
ON CONFLICT (disliker_user_id, disliked_user_id) DO NOTHING;

-- name: AddLike :exec
INSERT INTO likes (liker_user_id, liked_user_id)
VALUES ($1, $2)
ON CONFLICT (liker_user_id, liked_user_id) DO NOTHING; -- Ignore if like already exists

-- name: GetHomeFeed :many
WITH RequestingUser AS (
    SELECT
        u.id,
        u.latitude,
        u.longitude,
        u.gender,
        u.date_of_birth
    FROM users u
    WHERE u.id = $1 -- requesting_user_id
), RequestingUserFilters AS (
    SELECT
        f.user_id,
        f.who_you_want_to_see,
        f.radius_km,
        f.active_today,
        f.age_min,
        f.age_max
    FROM filters f
    WHERE f.user_id = $1 -- requesting_user_id
)
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.phone_number, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer,
    haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
JOIN RequestingUser ru ON target_user.id != ru.id -- Don't show self
JOIN RequestingUserFilters rf ON ru.id = rf.user_id -- Ensure requesting user has filters (or defaults were just created)
LEFT JOIN filters AS target_user_filters ON target_user.id = target_user_filters.user_id -- Filters of the potential match
WHERE
    -- Location Check: target user must have location
    target_user.latitude IS NOT NULL AND target_user.longitude IS NOT NULL
    -- Radius Check: target user must be within radius OR radius filter is not set
    AND (rf.radius_km IS NULL OR haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) <= rf.radius_km)

    -- Gender Preference Check (Requesting User's Preference)
    AND target_user.gender = rf.who_you_want_to_see

    -- Gender Preference Check (Target User's Preference - Reciprocal)
    AND target_user_filters.who_you_want_to_see = ru.gender

    -- Age Check: target user's age must be within requesting user's filter range
    AND target_user.date_of_birth IS NOT NULL
    AND EXTRACT(YEAR FROM AGE(target_user.date_of_birth)) BETWEEN rf.age_min AND rf.age_max

    -- Active Today Check (only if filter is enabled)
    AND (NOT rf.active_today OR EXISTS (
            SELECT 1 FROM app_open_logs aol
            WHERE aol.user_id = target_user.id AND aol.opened_at >= NOW() - INTERVAL '24 hours'
        ))

    -- Dislike Checks (Neither user disliked the other)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = ru.id AND d.disliked_user_id = target_user.id)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = target_user.id AND d.disliked_user_id = ru.id)

    -- Like Check (Requesting user has NOT liked the target user)
    AND NOT EXISTS (SELECT 1 FROM likes l WHERE l.liker_user_id = ru.id AND l.liked_user_id = target_user.id) -- <-- ADDED like check

ORDER BY
    distance_km ASC, -- Primary sort: Closest first
    ABS(EXTRACT(YEAR FROM AGE(ru.date_of_birth)) - EXTRACT(YEAR FROM AGE(target_user.date_of_birth))) ASC NULLS LAST
LIMIT $2; -- page_size (e.g., 15) -- Only Limit ($2), no Offset ($3)



================================================
File: db/schema.sql
================================================
CREATE TYPE gender_enum AS ENUM (
    'man',
    'woman',
    'gay',
    'lesbian',
    'bisexual'
);

COMMENT ON TYPE gender_enum IS 'Enumerated type for representing gender identity and/or sexual orientation as specified.';

CREATE TYPE dating_intention AS ENUM (
    'lifePartner',
    'longTerm',
    'longTermOpenShort',
    'shortTermOpenLong',
    'shortTerm',
    'figuringOut'
);

CREATE TYPE religion AS ENUM (
    'agnostic',
    'atheist',
    'buddhist',
    'christian',
    'hindu',
    'jain',
    'jewish',
    'muslim',
    'zoroastrian',
    'sikh',
    'spiritual'
);

CREATE TYPE drinking_smoking_habits AS ENUM (
    'yes',
    'sometimes',
    'no'
);

CREATE TYPE story_time_prompt_type AS ENUM (
    'twoTruthsAndALie',
    'worstIdea',
    'biggestRisk',
    'biggestDateFail',
    'neverHaveIEver',
    'bestTravelStory',
    'weirdestGift',
    'mostSpontaneous',
    'oneThingNeverDoAgain'
);

CREATE TYPE my_type_prompt_type AS ENUM (
    'nonNegotiable',
    'hallmarkOfGoodRelationship',
    'lookingFor',
    'weirdlyAttractedTo',
    'allIAskIsThatYou',
    'wellGetAlongIf',
    'wantSomeoneWho',
    'greenFlags',
    'sameTypeOfWeird',
    'fallForYouIf',
    'bragAboutYou'
);

CREATE TYPE getting_personal_prompt_type AS ENUM (
    'oneThingYouShouldKnow',
    'loveLanguage',
    'dorkiestThing',
    'dontHateMeIf',
    'geekOutOn',
    'ifLovingThisIsWrong',
    'keyToMyHeart',
    'wontShutUpAbout',
    'shouldNotGoOutWithMeIf',
    'whatIfIToldYouThat'
);

CREATE TYPE date_vibes_prompt_type AS ENUM (
    'togetherWeCould',
    'firstRoundIsOnMeIf',
    'whatIOrderForTheTable',
    'bestSpotInTown',
    'bestWayToAskMeOut'
);

CREATE TYPE audio_prompt AS ENUM (
    'canWeTalkAbout',
    'captionThisPhoto',
    'caughtInTheAct',
    'changeMyMindAbout',
    'chooseOurFirstDate',
    'commentIfYouveBeenHere',
    'cookWithMe',
    'datingMeIsLike',
    'datingMeWillLookLike',
    'doYouAgreeOrDisagreeThat',
    'dontHateMeIfI',
    'dontJudgeMe',
    'mondaysAmIRight',
    'aBoundaryOfMineIs',
    'aDailyEssential',
    'aDreamHomeMustInclude',
    'aFavouriteMemoryOfMine',
    'aFriendsReviewOfMe',
    'aLifeGoalOfMine',
    'aQuickRantAbout',
    'aRandomFactILoveIs',
    'aSpecialTalentOfMine',
    'aThoughtIRecentlyHadInTheShower',
    'allIAskIsThatYou',
    'guessWhereThisPhotoWasTaken',
    'helpMeIdentifyThisPhotoBomber',
    'hiFromMeAndMyPet',
    'howIFightTheSundayScaries',
    'howHistoryWillRememberMe',
    'howMyFriendsSeeMe',
    'howToPronounceMyName',
    'iBeatMyBluesBy',
    'iBetYouCant',
    'iCanTeachYouHowTo',
    'iFeelFamousWhen',
    'iFeelMostSupportedWhen'
);

CREATE TYPE verification_status AS ENUM (
    'false',
    'true',
    'pending'
);

CREATE TYPE user_role AS ENUM (
    'user',
    'admin'
);

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    name TEXT,
    last_name TEXT,
    phone_number TEXT NOT NULL UNIQUE,
    date_of_birth DATE,
    latitude DOUBLE PRECISION,
    longitude DOUBLE PRECISION,
    gender gender_enum,
    dating_intention dating_intention,
    height DOUBLE PRECISION,
    hometown TEXT,
    job_title TEXT,
    education TEXT,
    religious_beliefs religion,
    drinking_habit drinking_smoking_habits,
    smoking_habit drinking_smoking_habits,
    media_urls TEXT[],
    verification_status verification_status NOT NULL DEFAULT 'false',
    verification_pic TEXT,
    role user_role NOT NULL DEFAULT 'user',
    audio_prompt_question audio_prompt,
    audio_prompt_answer TEXT
);

CREATE TABLE otps (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    otp_code VARCHAR(6) NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + INTERVAL '2 minute'),
    CONSTRAINT fk_otps_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE story_time_prompts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    question story_time_prompt_type NOT NULL,
    answer TEXT NOT NULL,
    CONSTRAINT fk_story_time_prompt_user
        FOREIGN KEY (user_id)
        REFERENCES users(id)
        ON DELETE CASCADE,
    CONSTRAINT uq_user_story_time_prompt UNIQUE (user_id, question)
);

CREATE TABLE my_type_prompts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    question my_type_prompt_type NOT NULL,
    answer TEXT NOT NULL,
    CONSTRAINT fk_my_type_prompt_user
        FOREIGN KEY (user_id)
        REFERENCES users(id)
        ON DELETE CASCADE,
    CONSTRAINT uq_user_my_type_prompt UNIQUE (user_id, question)
);

CREATE TABLE getting_personal_prompts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    question getting_personal_prompt_type NOT NULL,
    answer TEXT NOT NULL,
    CONSTRAINT fk_getting_personal_prompt_user
        FOREIGN KEY (user_id)
        REFERENCES users(id)
        ON DELETE CASCADE,
    CONSTRAINT uq_user_getting_personal_prompt UNIQUE (user_id, question)
);

CREATE TABLE date_vibes_prompts (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    question date_vibes_prompt_type NOT NULL,
    answer TEXT NOT NULL,
    CONSTRAINT fk_date_vibes_prompt_user
        FOREIGN KEY (user_id)
        REFERENCES users(id)
        ON DELETE CASCADE,
    CONSTRAINT uq_user_date_vibes_prompts UNIQUE (user_id, question)
);

-- Function to update the updated_at column
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ language 'plpgsql';

-- Filters table
CREATE TABLE filters (
    user_id INTEGER PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    who_you_want_to_see gender_enum, -- Can be 'man' or 'woman' from existing enum
    radius_km INTEGER CHECK (radius_km > 0 AND radius_km <= 500), -- Example constraint: 1-500 km
    active_today BOOLEAN NOT NULL DEFAULT false,
    age_min INTEGER CHECK (age_min >= 18),
    age_max INTEGER CHECK (age_max >= 18),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT age_check CHECK (age_max >= age_min) -- Ensure max age is not less than min age
);

COMMENT ON COLUMN filters.who_you_want_to_see IS 'Which gender the user wants to see in their feed.';
COMMENT ON COLUMN filters.radius_km IS 'Maximum distance in kilometers for potential matches.';
COMMENT ON COLUMN filters.active_today IS 'Filter for users active within the last 24 hours.';
COMMENT ON COLUMN filters.age_min IS 'Minimum age preference.';
COMMENT ON COLUMN filters.age_max IS 'Maximum age preference.';


-- Trigger to automatically update updated_at on table update
CREATE TRIGGER set_timestamp
BEFORE UPDATE ON filters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Table to log app open events
CREATE TABLE app_open_logs (
    id BIGSERIAL PRIMARY KEY, -- Use BIGSERIAL for potentially high volume
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    opened_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE app_open_logs IS 'Logs each time a user is considered to have opened the app (triggered by a specific API call).';
COMMENT ON COLUMN app_open_logs.id IS 'Unique identifier for the log entry.';
COMMENT ON COLUMN app_open_logs.user_id IS 'The ID of the user who opened the app.';
COMMENT ON COLUMN app_open_logs.opened_at IS 'The timestamp when the app open event was recorded.';

-- Index for potential analysis of user activity over time
CREATE INDEX idx_app_open_logs_user_time ON app_open_logs (user_id, opened_at DESC);

-- Haversine function to calculate distance between two lat/lon points in kilometers
-- Assumes WGS84 spheroid
CREATE OR REPLACE FUNCTION haversine(lat1 float, lon1 float, lat2 float, lon2 float)
RETURNS float AS $$
DECLARE
    radius float := 6371; -- Earth radius in kilometers
    delta_lat float;
    delta_lon float;
    a float;
    c float;
    d float;
BEGIN
    delta_lat := RADIANS(lat2 - lat1);
    delta_lon := RADIANS(lon2 - lon1);
    a := SIN(delta_lat / 2) * SIN(delta_lat / 2) +
         COS(RADIANS(lat1)) * COS(RADIANS(lat2)) *
         SIN(delta_lon / 2) * SIN(delta_lon / 2);
    c := 2 * ASIN(SQRT(a));
    d := radius * c;
    RETURN d;
END;
$$ LANGUAGE plpgsql IMMUTABLE; -- IMMUTABLE suggests the function result depends only on input

COMMENT ON FUNCTION haversine(float, float, float, float) IS 'Calculates the great-circle distance between two points (latitude/longitude) in kilometers using the Haversine formula.';


-- Table to store user dislikes
CREATE TABLE dislikes (
    disliker_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    disliked_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (disliker_user_id, disliked_user_id) -- Ensure a user cannot dislike the same person multiple times
);

COMMENT ON TABLE dislikes IS 'Stores records of users disliking other users.';
COMMENT ON COLUMN dislikes.disliker_user_id IS 'The ID of the user performing the dislike action.';
COMMENT ON COLUMN dislikes.disliked_user_id IS 'The ID of the user being disliked.';
COMMENT ON COLUMN dislikes.created_at IS 'Timestamp when the dislike occurred.';

-- Index to quickly check if a specific user has been disliked by someone
CREATE INDEX idx_dislikes_disliked_user ON dislikes (disliked_user_id);
-- Index is implicitly created for the primary key (disliker_user_id, disliked_user_id)

-- Table to store user likes
CREATE TABLE likes (
    liker_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    liked_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (liker_user_id, liked_user_id) -- Ensure a user cannot like the same person multiple times
);

COMMENT ON TABLE likes IS 'Stores records of users liking other users.';
COMMENT ON COLUMN likes.liker_user_id IS 'The ID of the user performing the like action.';
COMMENT ON COLUMN likes.liked_user_id IS 'The ID of the user being liked.';
COMMENT ON COLUMN likes.created_at IS 'Timestamp when the like occurred.';

-- Index to quickly check if a specific user has been liked by someone
CREATE INDEX idx_likes_liked_user ON likes (liked_user_id);
-- Index is implicitly created for the primary key (liker_user_id, liked_user_id)



================================================
File: migrations/db.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package migrations

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}



================================================
File: migrations/models.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0

package migrations

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type AudioPrompt string

const (
	AudioPromptCanWeTalkAbout                  AudioPrompt = "canWeTalkAbout"
	AudioPromptCaptionThisPhoto                AudioPrompt = "captionThisPhoto"
	AudioPromptCaughtInTheAct                  AudioPrompt = "caughtInTheAct"
	AudioPromptChangeMyMindAbout               AudioPrompt = "changeMyMindAbout"
	AudioPromptChooseOurFirstDate              AudioPrompt = "chooseOurFirstDate"
	AudioPromptCommentIfYouveBeenHere          AudioPrompt = "commentIfYouveBeenHere"
	AudioPromptCookWithMe                      AudioPrompt = "cookWithMe"
	AudioPromptDatingMeIsLike                  AudioPrompt = "datingMeIsLike"
	AudioPromptDatingMeWillLookLike            AudioPrompt = "datingMeWillLookLike"
	AudioPromptDoYouAgreeOrDisagreeThat        AudioPrompt = "doYouAgreeOrDisagreeThat"
	AudioPromptDontHateMeIfI                   AudioPrompt = "dontHateMeIfI"
	AudioPromptDontJudgeMe                     AudioPrompt = "dontJudgeMe"
	AudioPromptMondaysAmIRight                 AudioPrompt = "mondaysAmIRight"
	AudioPromptABoundaryOfMineIs               AudioPrompt = "aBoundaryOfMineIs"
	AudioPromptADailyEssential                 AudioPrompt = "aDailyEssential"
	AudioPromptADreamHomeMustInclude           AudioPrompt = "aDreamHomeMustInclude"
	AudioPromptAFavouriteMemoryOfMine          AudioPrompt = "aFavouriteMemoryOfMine"
	AudioPromptAFriendsReviewOfMe              AudioPrompt = "aFriendsReviewOfMe"
	AudioPromptALifeGoalOfMine                 AudioPrompt = "aLifeGoalOfMine"
	AudioPromptAQuickRantAbout                 AudioPrompt = "aQuickRantAbout"
	AudioPromptARandomFactILoveIs              AudioPrompt = "aRandomFactILoveIs"
	AudioPromptASpecialTalentOfMine            AudioPrompt = "aSpecialTalentOfMine"
	AudioPromptAThoughtIRecentlyHadInTheShower AudioPrompt = "aThoughtIRecentlyHadInTheShower"
	AudioPromptAllIAskIsThatYou                AudioPrompt = "allIAskIsThatYou"
	AudioPromptGuessWhereThisPhotoWasTaken     AudioPrompt = "guessWhereThisPhotoWasTaken"
	AudioPromptHelpMeIdentifyThisPhotoBomber   AudioPrompt = "helpMeIdentifyThisPhotoBomber"
	AudioPromptHiFromMeAndMyPet                AudioPrompt = "hiFromMeAndMyPet"
	AudioPromptHowIFightTheSundayScaries       AudioPrompt = "howIFightTheSundayScaries"
	AudioPromptHowHistoryWillRememberMe        AudioPrompt = "howHistoryWillRememberMe"
	AudioPromptHowMyFriendsSeeMe               AudioPrompt = "howMyFriendsSeeMe"
	AudioPromptHowToPronounceMyName            AudioPrompt = "howToPronounceMyName"
	AudioPromptIBeatMyBluesBy                  AudioPrompt = "iBeatMyBluesBy"
	AudioPromptIBetYouCant                     AudioPrompt = "iBetYouCant"
	AudioPromptICanTeachYouHowTo               AudioPrompt = "iCanTeachYouHowTo"
	AudioPromptIFeelFamousWhen                 AudioPrompt = "iFeelFamousWhen"
	AudioPromptIFeelMostSupportedWhen          AudioPrompt = "iFeelMostSupportedWhen"
)

func (e *AudioPrompt) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AudioPrompt(s)
	case string:
		*e = AudioPrompt(s)
	default:
		return fmt.Errorf("unsupported scan type for AudioPrompt: %T", src)
	}
	return nil
}

type NullAudioPrompt struct {
	AudioPrompt AudioPrompt
	Valid       bool // Valid is true if AudioPrompt is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAudioPrompt) Scan(value interface{}) error {
	if value == nil {
		ns.AudioPrompt, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AudioPrompt.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAudioPrompt) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AudioPrompt), nil
}

type DateVibesPromptType string

const (
	DateVibesPromptTypeTogetherWeCould       DateVibesPromptType = "togetherWeCould"
	DateVibesPromptTypeFirstRoundIsOnMeIf    DateVibesPromptType = "firstRoundIsOnMeIf"
	DateVibesPromptTypeWhatIOrderForTheTable DateVibesPromptType = "whatIOrderForTheTable"
	DateVibesPromptTypeBestSpotInTown        DateVibesPromptType = "bestSpotInTown"
	DateVibesPromptTypeBestWayToAskMeOut     DateVibesPromptType = "bestWayToAskMeOut"
)

func (e *DateVibesPromptType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DateVibesPromptType(s)
	case string:
		*e = DateVibesPromptType(s)
	default:
		return fmt.Errorf("unsupported scan type for DateVibesPromptType: %T", src)
	}
	return nil
}

type NullDateVibesPromptType struct {
	DateVibesPromptType DateVibesPromptType
	Valid               bool // Valid is true if DateVibesPromptType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDateVibesPromptType) Scan(value interface{}) error {
	if value == nil {
		ns.DateVibesPromptType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DateVibesPromptType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDateVibesPromptType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DateVibesPromptType), nil
}

type DatingIntention string

const (
	DatingIntentionLifePartner       DatingIntention = "lifePartner"
	DatingIntentionLongTerm          DatingIntention = "longTerm"
	DatingIntentionLongTermOpenShort DatingIntention = "longTermOpenShort"
	DatingIntentionShortTermOpenLong DatingIntention = "shortTermOpenLong"
	DatingIntentionShortTerm         DatingIntention = "shortTerm"
	DatingIntentionFiguringOut       DatingIntention = "figuringOut"
)

func (e *DatingIntention) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DatingIntention(s)
	case string:
		*e = DatingIntention(s)
	default:
		return fmt.Errorf("unsupported scan type for DatingIntention: %T", src)
	}
	return nil
}

type NullDatingIntention struct {
	DatingIntention DatingIntention
	Valid           bool // Valid is true if DatingIntention is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDatingIntention) Scan(value interface{}) error {
	if value == nil {
		ns.DatingIntention, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DatingIntention.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDatingIntention) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DatingIntention), nil
}

type DrinkingSmokingHabits string

const (
	DrinkingSmokingHabitsYes       DrinkingSmokingHabits = "yes"
	DrinkingSmokingHabitsSometimes DrinkingSmokingHabits = "sometimes"
	DrinkingSmokingHabitsNo        DrinkingSmokingHabits = "no"
)

func (e *DrinkingSmokingHabits) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DrinkingSmokingHabits(s)
	case string:
		*e = DrinkingSmokingHabits(s)
	default:
		return fmt.Errorf("unsupported scan type for DrinkingSmokingHabits: %T", src)
	}
	return nil
}

type NullDrinkingSmokingHabits struct {
	DrinkingSmokingHabits DrinkingSmokingHabits
	Valid                 bool // Valid is true if DrinkingSmokingHabits is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDrinkingSmokingHabits) Scan(value interface{}) error {
	if value == nil {
		ns.DrinkingSmokingHabits, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DrinkingSmokingHabits.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDrinkingSmokingHabits) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DrinkingSmokingHabits), nil
}

// Enumerated type for representing gender identity and/or sexual orientation as specified.
type GenderEnum string

const (
	GenderEnumMan      GenderEnum = "man"
	GenderEnumWoman    GenderEnum = "woman"
	GenderEnumGay      GenderEnum = "gay"
	GenderEnumLesbian  GenderEnum = "lesbian"
	GenderEnumBisexual GenderEnum = "bisexual"
)

func (e *GenderEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GenderEnum(s)
	case string:
		*e = GenderEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for GenderEnum: %T", src)
	}
	return nil
}

type NullGenderEnum struct {
	GenderEnum GenderEnum
	Valid      bool // Valid is true if GenderEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGenderEnum) Scan(value interface{}) error {
	if value == nil {
		ns.GenderEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GenderEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGenderEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GenderEnum), nil
}

type GettingPersonalPromptType string

const (
	GettingPersonalPromptTypeOneThingYouShouldKnow  GettingPersonalPromptType = "oneThingYouShouldKnow"
	GettingPersonalPromptTypeLoveLanguage           GettingPersonalPromptType = "loveLanguage"
	GettingPersonalPromptTypeDorkiestThing          GettingPersonalPromptType = "dorkiestThing"
	GettingPersonalPromptTypeDontHateMeIf           GettingPersonalPromptType = "dontHateMeIf"
	GettingPersonalPromptTypeGeekOutOn              GettingPersonalPromptType = "geekOutOn"
	GettingPersonalPromptTypeIfLovingThisIsWrong    GettingPersonalPromptType = "ifLovingThisIsWrong"
	GettingPersonalPromptTypeKeyToMyHeart           GettingPersonalPromptType = "keyToMyHeart"
	GettingPersonalPromptTypeWontShutUpAbout        GettingPersonalPromptType = "wontShutUpAbout"
	GettingPersonalPromptTypeShouldNotGoOutWithMeIf GettingPersonalPromptType = "shouldNotGoOutWithMeIf"
	GettingPersonalPromptTypeWhatIfIToldYouThat     GettingPersonalPromptType = "whatIfIToldYouThat"
)

func (e *GettingPersonalPromptType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GettingPersonalPromptType(s)
	case string:
		*e = GettingPersonalPromptType(s)
	default:
		return fmt.Errorf("unsupported scan type for GettingPersonalPromptType: %T", src)
	}
	return nil
}

type NullGettingPersonalPromptType struct {
	GettingPersonalPromptType GettingPersonalPromptType
	Valid                     bool // Valid is true if GettingPersonalPromptType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGettingPersonalPromptType) Scan(value interface{}) error {
	if value == nil {
		ns.GettingPersonalPromptType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GettingPersonalPromptType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGettingPersonalPromptType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GettingPersonalPromptType), nil
}

type MyTypePromptType string

const (
	MyTypePromptTypeNonNegotiable              MyTypePromptType = "nonNegotiable"
	MyTypePromptTypeHallmarkOfGoodRelationship MyTypePromptType = "hallmarkOfGoodRelationship"
	MyTypePromptTypeLookingFor                 MyTypePromptType = "lookingFor"
	MyTypePromptTypeWeirdlyAttractedTo         MyTypePromptType = "weirdlyAttractedTo"
	MyTypePromptTypeAllIAskIsThatYou           MyTypePromptType = "allIAskIsThatYou"
	MyTypePromptTypeWellGetAlongIf             MyTypePromptType = "wellGetAlongIf"
	MyTypePromptTypeWantSomeoneWho             MyTypePromptType = "wantSomeoneWho"
	MyTypePromptTypeGreenFlags                 MyTypePromptType = "greenFlags"
	MyTypePromptTypeSameTypeOfWeird            MyTypePromptType = "sameTypeOfWeird"
	MyTypePromptTypeFallForYouIf               MyTypePromptType = "fallForYouIf"
	MyTypePromptTypeBragAboutYou               MyTypePromptType = "bragAboutYou"
)

func (e *MyTypePromptType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MyTypePromptType(s)
	case string:
		*e = MyTypePromptType(s)
	default:
		return fmt.Errorf("unsupported scan type for MyTypePromptType: %T", src)
	}
	return nil
}

type NullMyTypePromptType struct {
	MyTypePromptType MyTypePromptType
	Valid            bool // Valid is true if MyTypePromptType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMyTypePromptType) Scan(value interface{}) error {
	if value == nil {
		ns.MyTypePromptType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MyTypePromptType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMyTypePromptType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MyTypePromptType), nil
}

type Religion string

const (
	ReligionAgnostic    Religion = "agnostic"
	ReligionAtheist     Religion = "atheist"
	ReligionBuddhist    Religion = "buddhist"
	ReligionChristian   Religion = "christian"
	ReligionHindu       Religion = "hindu"
	ReligionJain        Religion = "jain"
	ReligionJewish      Religion = "jewish"
	ReligionMuslim      Religion = "muslim"
	ReligionZoroastrian Religion = "zoroastrian"
	ReligionSikh        Religion = "sikh"
	ReligionSpiritual   Religion = "spiritual"
)

func (e *Religion) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Religion(s)
	case string:
		*e = Religion(s)
	default:
		return fmt.Errorf("unsupported scan type for Religion: %T", src)
	}
	return nil
}

type NullReligion struct {
	Religion Religion
	Valid    bool // Valid is true if Religion is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReligion) Scan(value interface{}) error {
	if value == nil {
		ns.Religion, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Religion.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReligion) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Religion), nil
}

type StoryTimePromptType string

const (
	StoryTimePromptTypeTwoTruthsAndALie     StoryTimePromptType = "twoTruthsAndALie"
	StoryTimePromptTypeWorstIdea            StoryTimePromptType = "worstIdea"
	StoryTimePromptTypeBiggestRisk          StoryTimePromptType = "biggestRisk"
	StoryTimePromptTypeBiggestDateFail      StoryTimePromptType = "biggestDateFail"
	StoryTimePromptTypeNeverHaveIEver       StoryTimePromptType = "neverHaveIEver"
	StoryTimePromptTypeBestTravelStory      StoryTimePromptType = "bestTravelStory"
	StoryTimePromptTypeWeirdestGift         StoryTimePromptType = "weirdestGift"
	StoryTimePromptTypeMostSpontaneous      StoryTimePromptType = "mostSpontaneous"
	StoryTimePromptTypeOneThingNeverDoAgain StoryTimePromptType = "oneThingNeverDoAgain"
)

func (e *StoryTimePromptType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = StoryTimePromptType(s)
	case string:
		*e = StoryTimePromptType(s)
	default:
		return fmt.Errorf("unsupported scan type for StoryTimePromptType: %T", src)
	}
	return nil
}

type NullStoryTimePromptType struct {
	StoryTimePromptType StoryTimePromptType
	Valid               bool // Valid is true if StoryTimePromptType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullStoryTimePromptType) Scan(value interface{}) error {
	if value == nil {
		ns.StoryTimePromptType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.StoryTimePromptType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullStoryTimePromptType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.StoryTimePromptType), nil
}

type UserRole string

const (
	UserRoleUser  UserRole = "user"
	UserRoleAdmin UserRole = "admin"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole
	Valid    bool // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type VerificationStatus string

const (
	VerificationStatusFalse   VerificationStatus = "false"
	VerificationStatusTrue    VerificationStatus = "true"
	VerificationStatusPending VerificationStatus = "pending"
)

func (e *VerificationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VerificationStatus(s)
	case string:
		*e = VerificationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for VerificationStatus: %T", src)
	}
	return nil
}

type NullVerificationStatus struct {
	VerificationStatus VerificationStatus
	Valid              bool // Valid is true if VerificationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVerificationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.VerificationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VerificationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVerificationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VerificationStatus), nil
}

// Logs each time a user is considered to have opened the app (triggered by a specific API call).
type AppOpenLog struct {
	// Unique identifier for the log entry.
	ID int64
	// The ID of the user who opened the app.
	UserID int32
	// The timestamp when the app open event was recorded.
	OpenedAt pgtype.Timestamptz
}

type DateVibesPrompt struct {
	ID       int32
	UserID   int32
	Question DateVibesPromptType
	Answer   string
}

// Stores records of users disliking other users.
type Dislike struct {
	// The ID of the user performing the dislike action.
	DislikerUserID int32
	// The ID of the user being disliked.
	DislikedUserID int32
	// Timestamp when the dislike occurred.
	CreatedAt pgtype.Timestamptz
}

type Filter struct {
	UserID int32
	// Which gender the user wants to see in their feed.
	WhoYouWantToSee NullGenderEnum
	// Maximum distance in kilometers for potential matches.
	RadiusKm pgtype.Int4
	// Filter for users active within the last 24 hours.
	ActiveToday bool
	// Minimum age preference.
	AgeMin pgtype.Int4
	// Maximum age preference.
	AgeMax    pgtype.Int4
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

type GettingPersonalPrompt struct {
	ID       int32
	UserID   int32
	Question GettingPersonalPromptType
	Answer   string
}

// Stores records of users liking other users.
type Like struct {
	// The ID of the user performing the like action.
	LikerUserID int32
	// The ID of the user being liked.
	LikedUserID int32
	// Timestamp when the like occurred.
	CreatedAt pgtype.Timestamptz
}

type MyTypePrompt struct {
	ID       int32
	UserID   int32
	Question MyTypePromptType
	Answer   string
}

type Otp struct {
	ID        int32
	UserID    int32
	OtpCode   string
	ExpiresAt pgtype.Timestamptz
}

type StoryTimePrompt struct {
	ID       int32
	UserID   int32
	Question StoryTimePromptType
	Answer   string
}

type User struct {
	ID                  int32
	CreatedAt           pgtype.Timestamptz
	Name                pgtype.Text
	LastName            pgtype.Text
	PhoneNumber         string
	DateOfBirth         pgtype.Date
	Latitude            pgtype.Float8
	Longitude           pgtype.Float8
	Gender              NullGenderEnum
	DatingIntention     NullDatingIntention
	Height              pgtype.Float8
	Hometown            pgtype.Text
	JobTitle            pgtype.Text
	Education           pgtype.Text
	ReligiousBeliefs    NullReligion
	DrinkingHabit       NullDrinkingSmokingHabits
	SmokingHabit        NullDrinkingSmokingHabits
	MediaUrls           []string
	VerificationStatus  VerificationStatus
	VerificationPic     pgtype.Text
	Role                UserRole
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}



================================================
File: migrations/queries.sql.go
================================================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package migrations

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDislike = `-- name: AddDislike :exec
INSERT INTO dislikes (disliker_user_id, disliked_user_id)
VALUES ($1, $2)
ON CONFLICT (disliker_user_id, disliked_user_id) DO NOTHING
`

type AddDislikeParams struct {
	DislikerUserID int32
	DislikedUserID int32
}

func (q *Queries) AddDislike(ctx context.Context, arg AddDislikeParams) error {
	_, err := q.db.Exec(ctx, addDislike, arg.DislikerUserID, arg.DislikedUserID)
	return err
}

const addLike = `-- name: AddLike :exec
INSERT INTO likes (liker_user_id, liked_user_id)
VALUES ($1, $2)
ON CONFLICT (liker_user_id, liked_user_id) DO NOTHING
`

type AddLikeParams struct {
	LikerUserID int32
	LikedUserID int32
}

func (q *Queries) AddLike(ctx context.Context, arg AddLikeParams) error {
	_, err := q.db.Exec(ctx, addLike, arg.LikerUserID, arg.LikedUserID)
	return err
}

const addPhoneNumberInUsers = `-- name: AddPhoneNumberInUsers :one

INSERT INTO users (
    phone_number
) VALUES (
    $1
)
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer
`

// $1 should be 'pending'
func (q *Queries) AddPhoneNumberInUsers(ctx context.Context, phoneNumber string) (User, error) {
	row := q.db.QueryRow(ctx, addPhoneNumberInUsers, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const cleanOTP = `-- name: CleanOTP :exec
DELETE FROM otps
WHERE expires_at < NOW()
`

func (q *Queries) CleanOTP(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanOTP)
	return err
}

const cleanOTPs = `-- name: CleanOTPs :exec
DELETE FROM otps
WHERE expires_at < NOW()
`

func (q *Queries) CleanOTPs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanOTPs)
	return err
}

const clearUserMediaURLs = `-- name: ClearUserMediaURLs :exec
UPDATE users
SET media_urls = '{}'
WHERE id = $1
`

func (q *Queries) ClearUserMediaURLs(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, clearUserMediaURLs, id)
	return err
}

const createDateVibesPrompt = `-- name: CreateDateVibesPrompt :one
INSERT INTO date_vibes_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateDateVibesPromptParams struct {
	UserID   int32
	Question DateVibesPromptType
	Answer   string
}

func (q *Queries) CreateDateVibesPrompt(ctx context.Context, arg CreateDateVibesPromptParams) (DateVibesPrompt, error) {
	row := q.db.QueryRow(ctx, createDateVibesPrompt, arg.UserID, arg.Question, arg.Answer)
	var i DateVibesPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createGettingPersonalPrompt = `-- name: CreateGettingPersonalPrompt :one
INSERT INTO getting_personal_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateGettingPersonalPromptParams struct {
	UserID   int32
	Question GettingPersonalPromptType
	Answer   string
}

func (q *Queries) CreateGettingPersonalPrompt(ctx context.Context, arg CreateGettingPersonalPromptParams) (GettingPersonalPrompt, error) {
	row := q.db.QueryRow(ctx, createGettingPersonalPrompt, arg.UserID, arg.Question, arg.Answer)
	var i GettingPersonalPrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createMyTypePrompt = `-- name: CreateMyTypePrompt :one
INSERT INTO my_type_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateMyTypePromptParams struct {
	UserID   int32
	Question MyTypePromptType
	Answer   string
}

func (q *Queries) CreateMyTypePrompt(ctx context.Context, arg CreateMyTypePromptParams) (MyTypePrompt, error) {
	row := q.db.QueryRow(ctx, createMyTypePrompt, arg.UserID, arg.Question, arg.Answer)
	var i MyTypePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createOTP = `-- name: CreateOTP :one
INSERT INTO otps (
    user_id, otp_code
) VALUES (
    $1, $2
)
RETURNING id, user_id, otp_code, expires_at
`

type CreateOTPParams struct {
	UserID  int32
	OtpCode string
}

func (q *Queries) CreateOTP(ctx context.Context, arg CreateOTPParams) (Otp, error) {
	row := q.db.QueryRow(ctx, createOTP, arg.UserID, arg.OtpCode)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OtpCode,
		&i.ExpiresAt,
	)
	return i, err
}

const createStoryTimePrompt = `-- name: CreateStoryTimePrompt :one
INSERT INTO story_time_prompts (user_id, question, answer)
VALUES ($1, $2, $3)
RETURNING id, user_id, question, answer
`

type CreateStoryTimePromptParams struct {
	UserID   int32
	Question StoryTimePromptType
	Answer   string
}

func (q *Queries) CreateStoryTimePrompt(ctx context.Context, arg CreateStoryTimePromptParams) (StoryTimePrompt, error) {
	row := q.db.QueryRow(ctx, createStoryTimePrompt, arg.UserID, arg.Question, arg.Answer)
	var i StoryTimePrompt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Question,
		&i.Answer,
	)
	return i, err
}

const createUserMinimal = `-- name: CreateUserMinimal :one
INSERT INTO users (
    phone_number, gender
) VALUES (
    $1, $2
)
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer
`

type CreateUserMinimalParams struct {
	PhoneNumber string
	Gender      NullGenderEnum
}

func (q *Queries) CreateUserMinimal(ctx context.Context, arg CreateUserMinimalParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserMinimal, arg.PhoneNumber, arg.Gender)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const deleteOTPByID = `-- name: DeleteOTPByID :exec
DELETE FROM otps
WHERE id = $1
`

func (q *Queries) DeleteOTPByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOTPByID, id)
	return err
}

const deleteOTPByUser = `-- name: DeleteOTPByUser :exec
DELETE FROM otps
WHERE user_id = $1
`

func (q *Queries) DeleteOTPByUser(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteOTPByUser, userID)
	return err
}

const deleteOTPsByPhoneNumber = `-- name: DeleteOTPsByPhoneNumber :exec
DELETE FROM otps
WHERE user_id = (SELECT id FROM users WHERE phone_number = $1)
`

func (q *Queries) DeleteOTPsByPhoneNumber(ctx context.Context, phoneNumber string) error {
	_, err := q.db.Exec(ctx, deleteOTPsByPhoneNumber, phoneNumber)
	return err
}

const deleteUserDateVibesPrompts = `-- name: DeleteUserDateVibesPrompts :exec
DELETE FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserDateVibesPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserDateVibesPrompts, userID)
	return err
}

const deleteUserGettingPersonalPrompts = `-- name: DeleteUserGettingPersonalPrompts :exec
DELETE FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserGettingPersonalPrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserGettingPersonalPrompts, userID)
	return err
}

const deleteUserMyTypePrompts = `-- name: DeleteUserMyTypePrompts :exec
DELETE FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserMyTypePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserMyTypePrompts, userID)
	return err
}

const deleteUserStoryTimePrompts = `-- name: DeleteUserStoryTimePrompts :exec
DELETE FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) DeleteUserStoryTimePrompts(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, deleteUserStoryTimePrompts, userID)
	return err
}

const getHomeFeed = `-- name: GetHomeFeed :many

WITH RequestingUser AS (
    SELECT
        u.id,
        u.latitude,
        u.longitude,
        u.gender,
        u.date_of_birth
    FROM users u
    WHERE u.id = $1 -- requesting_user_id
), RequestingUserFilters AS (
    SELECT
        f.user_id,
        f.who_you_want_to_see,
        f.radius_km,
        f.active_today,
        f.age_min,
        f.age_max
    FROM filters f
    WHERE f.user_id = $1 -- requesting_user_id
)
SELECT
    target_user.id, target_user.created_at, target_user.name, target_user.last_name, target_user.phone_number, target_user.date_of_birth, target_user.latitude, target_user.longitude, target_user.gender, target_user.dating_intention, target_user.height, target_user.hometown, target_user.job_title, target_user.education, target_user.religious_beliefs, target_user.drinking_habit, target_user.smoking_habit, target_user.media_urls, target_user.verification_status, target_user.verification_pic, target_user.role, target_user.audio_prompt_question, target_user.audio_prompt_answer,
    haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) AS distance_km
FROM users AS target_user
JOIN RequestingUser ru ON target_user.id != ru.id -- Don't show self
JOIN RequestingUserFilters rf ON ru.id = rf.user_id -- Ensure requesting user has filters (or defaults were just created)
LEFT JOIN filters AS target_user_filters ON target_user.id = target_user_filters.user_id -- Filters of the potential match
WHERE
    -- Location Check: target user must have location
    target_user.latitude IS NOT NULL AND target_user.longitude IS NOT NULL
    -- Radius Check: target user must be within radius OR radius filter is not set
    AND (rf.radius_km IS NULL OR haversine(ru.latitude, ru.longitude, target_user.latitude, target_user.longitude) <= rf.radius_km)

    -- Gender Preference Check (Requesting User's Preference)
    AND target_user.gender = rf.who_you_want_to_see

    -- Gender Preference Check (Target User's Preference - Reciprocal)
    AND target_user_filters.who_you_want_to_see = ru.gender

    -- Age Check: target user's age must be within requesting user's filter range
    AND target_user.date_of_birth IS NOT NULL
    AND EXTRACT(YEAR FROM AGE(target_user.date_of_birth)) BETWEEN rf.age_min AND rf.age_max

    -- Active Today Check (only if filter is enabled)
    AND (NOT rf.active_today OR EXISTS (
            SELECT 1 FROM app_open_logs aol
            WHERE aol.user_id = target_user.id AND aol.opened_at >= NOW() - INTERVAL '24 hours'
        ))

    -- Dislike Checks (Neither user disliked the other)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = ru.id AND d.disliked_user_id = target_user.id)
    AND NOT EXISTS (SELECT 1 FROM dislikes d WHERE d.disliker_user_id = target_user.id AND d.disliked_user_id = ru.id)

    -- Like Check (Requesting user has NOT liked the target user)
    AND NOT EXISTS (SELECT 1 FROM likes l WHERE l.liker_user_id = ru.id AND l.liked_user_id = target_user.id) -- <-- ADDED like check

ORDER BY
    distance_km ASC, -- Primary sort: Closest first
    ABS(EXTRACT(YEAR FROM AGE(ru.date_of_birth)) - EXTRACT(YEAR FROM AGE(target_user.date_of_birth))) ASC NULLS LAST
LIMIT $2
`

type GetHomeFeedParams struct {
	ID    int32
	Limit int32
}

type GetHomeFeedRow struct {
	ID                  int32
	CreatedAt           pgtype.Timestamptz
	Name                pgtype.Text
	LastName            pgtype.Text
	PhoneNumber         string
	DateOfBirth         pgtype.Date
	Latitude            pgtype.Float8
	Longitude           pgtype.Float8
	Gender              NullGenderEnum
	DatingIntention     NullDatingIntention
	Height              pgtype.Float8
	Hometown            pgtype.Text
	JobTitle            pgtype.Text
	Education           pgtype.Text
	ReligiousBeliefs    NullReligion
	DrinkingHabit       NullDrinkingSmokingHabits
	SmokingHabit        NullDrinkingSmokingHabits
	MediaUrls           []string
	VerificationStatus  VerificationStatus
	VerificationPic     pgtype.Text
	Role                UserRole
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
	DistanceKm          float64
}

// Ignore if like already exists
func (q *Queries) GetHomeFeed(ctx context.Context, arg GetHomeFeedParams) ([]GetHomeFeedRow, error) {
	rows, err := q.db.Query(ctx, getHomeFeed, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHomeFeedRow
	for rows.Next() {
		var i GetHomeFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
			&i.DistanceKm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOTPByUser = `-- name: GetOTPByUser :one
SELECT id, user_id, otp_code, expires_at FROM otps
WHERE user_id = $1
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetOTPByUser(ctx context.Context, userID int32) (Otp, error) {
	row := q.db.QueryRow(ctx, getOTPByUser, userID)
	var i Otp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OtpCode,
		&i.ExpiresAt,
	)
	return i, err
}

const getPendingVerificationUsers = `-- name: GetPendingVerificationUsers :many
SELECT id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer FROM users
WHERE verification_status = $1
`

func (q *Queries) GetPendingVerificationUsers(ctx context.Context, verificationStatus VerificationStatus) ([]User, error) {
	rows, err := q.db.Query(ctx, getPendingVerificationUsers, verificationStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Name,
			&i.LastName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Latitude,
			&i.Longitude,
			&i.Gender,
			&i.DatingIntention,
			&i.Height,
			&i.Hometown,
			&i.JobTitle,
			&i.Education,
			&i.ReligiousBeliefs,
			&i.DrinkingHabit,
			&i.SmokingHabit,
			&i.MediaUrls,
			&i.VerificationStatus,
			&i.VerificationPic,
			&i.Role,
			&i.AudioPromptQuestion,
			&i.AudioPromptAnswer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAudioPrompt = `-- name: GetUserAudioPrompt :one
SELECT id, audio_prompt_question, audio_prompt_answer
FROM users
WHERE id = $1 LIMIT 1
`

type GetUserAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) GetUserAudioPrompt(ctx context.Context, id int32) (GetUserAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, getUserAudioPrompt, id)
	var i GetUserAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer FROM users
WHERE phone_number = $1 LIMIT 1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phoneNumber string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const getUserDateVibesPrompts = `-- name: GetUserDateVibesPrompts :many
SELECT id, user_id, question, answer FROM date_vibes_prompts WHERE user_id = $1
`

func (q *Queries) GetUserDateVibesPrompts(ctx context.Context, userID int32) ([]DateVibesPrompt, error) {
	rows, err := q.db.Query(ctx, getUserDateVibesPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DateVibesPrompt
	for rows.Next() {
		var i DateVibesPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFilters = `-- name: GetUserFilters :one
SELECT user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at FROM filters
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserFilters(ctx context.Context, userID int32) (Filter, error) {
	row := q.db.QueryRow(ctx, getUserFilters, userID)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserGettingPersonalPrompts = `-- name: GetUserGettingPersonalPrompts :many
SELECT id, user_id, question, answer FROM getting_personal_prompts WHERE user_id = $1
`

func (q *Queries) GetUserGettingPersonalPrompts(ctx context.Context, userID int32) ([]GettingPersonalPrompt, error) {
	rows, err := q.db.Query(ctx, getUserGettingPersonalPrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GettingPersonalPrompt
	for rows.Next() {
		var i GettingPersonalPrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMyTypePrompts = `-- name: GetUserMyTypePrompts :many
SELECT id, user_id, question, answer FROM my_type_prompts WHERE user_id = $1
`

func (q *Queries) GetUserMyTypePrompts(ctx context.Context, userID int32) ([]MyTypePrompt, error) {
	rows, err := q.db.Query(ctx, getUserMyTypePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MyTypePrompt
	for rows.Next() {
		var i MyTypePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryTimePrompts = `-- name: GetUserStoryTimePrompts :many
SELECT id, user_id, question, answer FROM story_time_prompts WHERE user_id = $1
`

func (q *Queries) GetUserStoryTimePrompts(ctx context.Context, userID int32) ([]StoryTimePrompt, error) {
	rows, err := q.db.Query(ctx, getUserStoryTimePrompts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StoryTimePrompt
	for rows.Next() {
		var i StoryTimePrompt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logAppOpen = `-- name: LogAppOpen :exec
INSERT INTO app_open_logs (user_id)
VALUES ($1)
`

func (q *Queries) LogAppOpen(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, logAppOpen, userID)
	return err
}

const updateAudioPrompt = `-- name: UpdateAudioPrompt :one
UPDATE users
SET audio_prompt_question = $1, audio_prompt_answer = $2
WHERE id = $3
RETURNING id, audio_prompt_question, audio_prompt_answer
`

type UpdateAudioPromptParams struct {
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
	ID                  int32
}

type UpdateAudioPromptRow struct {
	ID                  int32
	AudioPromptQuestion NullAudioPrompt
	AudioPromptAnswer   pgtype.Text
}

func (q *Queries) UpdateAudioPrompt(ctx context.Context, arg UpdateAudioPromptParams) (UpdateAudioPromptRow, error) {
	row := q.db.QueryRow(ctx, updateAudioPrompt, arg.AudioPromptQuestion, arg.AudioPromptAnswer, arg.ID)
	var i UpdateAudioPromptRow
	err := row.Scan(&i.ID, &i.AudioPromptQuestion, &i.AudioPromptAnswer)
	return i, err
}

const updateUserMediaURLs = `-- name: UpdateUserMediaURLs :exec
UPDATE users
SET media_urls = $1
WHERE id = $2
`

type UpdateUserMediaURLsParams struct {
	MediaUrls []string
	ID        int32
}

func (q *Queries) UpdateUserMediaURLs(ctx context.Context, arg UpdateUserMediaURLsParams) error {
	_, err := q.db.Exec(ctx, updateUserMediaURLs, arg.MediaUrls, arg.ID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users SET
    name = $1,
    last_name = $2,
    date_of_birth = $3,
    latitude = $4,
    longitude = $5,
    gender = $6,
    dating_intention = $7,
    height = $8,
    hometown = $9,
    job_title = $10,
    education = $11,
    religious_beliefs = $12,
    drinking_habit = $13,
    smoking_habit = $14
WHERE id = $15
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer
`

type UpdateUserProfileParams struct {
	Name             pgtype.Text
	LastName         pgtype.Text
	DateOfBirth      pgtype.Date
	Latitude         pgtype.Float8
	Longitude        pgtype.Float8
	Gender           NullGenderEnum
	DatingIntention  NullDatingIntention
	Height           pgtype.Float8
	Hometown         pgtype.Text
	JobTitle         pgtype.Text
	Education        pgtype.Text
	ReligiousBeliefs NullReligion
	DrinkingHabit    NullDrinkingSmokingHabits
	SmokingHabit     NullDrinkingSmokingHabits
	ID               int32
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.Name,
		arg.LastName,
		arg.DateOfBirth,
		arg.Latitude,
		arg.Longitude,
		arg.Gender,
		arg.DatingIntention,
		arg.Height,
		arg.Hometown,
		arg.JobTitle,
		arg.Education,
		arg.ReligiousBeliefs,
		arg.DrinkingHabit,
		arg.SmokingHabit,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :one
UPDATE users
SET role = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer
`

type UpdateUserRoleParams struct {
	Role UserRole
	ID   int32
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserRole, arg.Role, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const updateUserVerificationDetails = `-- name: UpdateUserVerificationDetails :one
UPDATE users
SET
    verification_pic = $1,
    verification_status = $2
WHERE id = $3
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer
`

type UpdateUserVerificationDetailsParams struct {
	VerificationPic    pgtype.Text
	VerificationStatus VerificationStatus
	ID                 int32
}

func (q *Queries) UpdateUserVerificationDetails(ctx context.Context, arg UpdateUserVerificationDetailsParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationDetails, arg.VerificationPic, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const updateUserVerificationStatus = `-- name: UpdateUserVerificationStatus :one
UPDATE users
SET verification_status = $1
WHERE id = $2
RETURNING id, created_at, name, last_name, phone_number, date_of_birth, latitude, longitude, gender, dating_intention, height, hometown, job_title, education, religious_beliefs, drinking_habit, smoking_habit, media_urls, verification_status, verification_pic, role, audio_prompt_question, audio_prompt_answer
`

type UpdateUserVerificationStatusParams struct {
	VerificationStatus VerificationStatus
	ID                 int32
}

func (q *Queries) UpdateUserVerificationStatus(ctx context.Context, arg UpdateUserVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserVerificationStatus, arg.VerificationStatus, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.LastName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Latitude,
		&i.Longitude,
		&i.Gender,
		&i.DatingIntention,
		&i.Height,
		&i.Hometown,
		&i.JobTitle,
		&i.Education,
		&i.ReligiousBeliefs,
		&i.DrinkingHabit,
		&i.SmokingHabit,
		&i.MediaUrls,
		&i.VerificationStatus,
		&i.VerificationPic,
		&i.Role,
		&i.AudioPromptQuestion,
		&i.AudioPromptAnswer,
	)
	return i, err
}

const upsertUserFilters = `-- name: UpsertUserFilters :one
INSERT INTO filters (
    user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (user_id) DO UPDATE SET
    who_you_want_to_see = EXCLUDED.who_you_want_to_see,
    radius_km = EXCLUDED.radius_km,
    active_today = EXCLUDED.active_today,
    age_min = EXCLUDED.age_min,
    age_max = EXCLUDED.age_max,
    updated_at = NOW()
RETURNING user_id, who_you_want_to_see, radius_km, active_today, age_min, age_max, created_at, updated_at
`

type UpsertUserFiltersParams struct {
	UserID          int32
	WhoYouWantToSee NullGenderEnum
	RadiusKm        pgtype.Int4
	ActiveToday     bool
	AgeMin          pgtype.Int4
	AgeMax          pgtype.Int4
}

func (q *Queries) UpsertUserFilters(ctx context.Context, arg UpsertUserFiltersParams) (Filter, error) {
	row := q.db.QueryRow(ctx, upsertUserFilters,
		arg.UserID,
		arg.WhoYouWantToSee,
		arg.RadiusKm,
		arg.ActiveToday,
		arg.AgeMin,
		arg.AgeMax,
	)
	var i Filter
	err := row.Scan(
		&i.UserID,
		&i.WhoYouWantToSee,
		&i.RadiusKm,
		&i.ActiveToday,
		&i.AgeMin,
		&i.AgeMax,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}



================================================
File: pkg/db/db.go
================================================
package db

import (
	"context"
	"log"
	"os"
	"sync"
	"time"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/jackc/pgx/v5/pgxpool"
)

var (
	pool    *pgxpool.Pool
	poolMu  sync.Mutex
	queries *migrations.Queries
)

func InitDB() error {
	poolMu.Lock()
	defer poolMu.Unlock()

	if pool != nil {
		return nil
	}

	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		log.Fatal("DATABASE_URL environment variable is not set")
	}

	dbConfig, err := pgxpool.ParseConfig(dbURL)
	if err != nil {
		log.Printf("Error parsing DATABASE_URL: %v", err)
		return err
	}

	dbConfig.MaxConns = 50
	dbConfig.MinConns = 10
	dbConfig.MaxConnLifetime = time.Hour
	dbConfig.MaxConnIdleTime = 30 * time.Minute
	dbConfig.HealthCheckPeriod = 1 * time.Minute

	log.Println("Attempting to connect to database...")
	newPool, err := pgxpool.NewWithConfig(context.Background(), dbConfig)
	if err != nil {
		log.Printf("Unable to create connection pool: %v", err)
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := newPool.Ping(ctx); err != nil {
		newPool.Close()
		log.Printf("Database ping failed: %v", err)
		return err
	}

	pool = newPool
	queries = migrations.New(pool)

	log.Println("Database connection pool initialized successfully")
	return nil
}

func GetDB() *migrations.Queries {
	poolMu.Lock()
	if pool == nil {
		poolMu.Unlock()
		if err := InitDB(); err != nil {
			log.Printf("Failed to initialize database connection: %v", err)
			return nil
		}
		poolMu.Lock()
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()
	if err := pool.Ping(ctx); err != nil {
		log.Printf("Database connection check failed: %v. Attempting to reconnect...", err)
		if pool != nil {
			pool.Close()
			pool = nil
			queries = nil
		}
		poolMu.Unlock()

		if err := InitDB(); err != nil {
			log.Printf("Failed to reconnect to database: %v", err)
			return nil
		}
		log.Println("Successfully reconnected to the database.")
		poolMu.Lock()
	}

	currentQueries := queries
	poolMu.Unlock()
	return currentQueries
}

func GetPool() *pgxpool.Pool {
	if GetDB() == nil {
		return nil
	}
	poolMu.Lock()
	defer poolMu.Unlock()
	return pool
}

func CloseDB() {
	poolMu.Lock()
	defer poolMu.Unlock()

	if pool != nil {
		pool.Close()
		pool = nil
		queries = nil
		log.Println("Database connection pool closed")
	}
}



================================================
File: pkg/handlers/adminHandler.go
================================================
package handlers

import (
	"database/sql"
	"encoding/json"
	"errors"
	"log"
	"net/http"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
)

type ErrorResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

type SetAdminRequest struct {
	PhoneNumber string `json:"phone_number"`
	IsAdmin     bool   `json:"is_admin"`
}

type SetAdminResponse struct {
	Success bool                `json:"success"`
	Message string              `json:"message"`
	UserID  int32               `json:"user_id"`
	Role    migrations.UserRole `json:"role"`
}

func SetAdminHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		json.NewEncoder(w).Encode(ErrorResponse{Success: false, Message: "Method Not Allowed: Use POST"})
		return
	}

	// --- Decode Body ---
	var req SetAdminRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("SetAdminHandler: Error decoding request body: %v", err)
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(ErrorResponse{Success: false, Message: "Invalid request body format"})
		return
	}
	defer r.Body.Close() // closinbg the body

	if req.PhoneNumber == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(ErrorResponse{Success: false, Message: "Phone number is required"})
		return
	}

	queries := db.GetDB()
	user, err := queries.GetUserByPhone(r.Context(), req.PhoneNumber)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			w.WriteHeader(http.StatusNotFound)
			json.NewEncoder(w).Encode(ErrorResponse{
				Success: false,
				Message: "User with the provided phone number not found",
			})
		} else {
			log.Printf("SetAdminHandler: Error fetching user by phone %s: %v\n", req.PhoneNumber, err)
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(ErrorResponse{Success: false, Message: "Database error retrieving user"})
		}
		return
	}

	var targetRole migrations.UserRole
	if req.IsAdmin {
		targetRole = migrations.UserRoleAdmin
	} else {
		targetRole = migrations.UserRoleUser
	}

	// 3. Update the user's role
	if user.Role == targetRole {
		// Role is already set, maybe return success or a specific message
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(SetAdminResponse{
			Success: true,
			Message: "User role is already set to the desired value",
			UserID:  user.ID,
			Role:    user.Role,
		})
		return
	}

	updateParams := migrations.UpdateUserRoleParams{
		Role: targetRole,
		ID:   user.ID,
	}

	updatedUser, err := queries.UpdateUserRole(r.Context(), updateParams)
	if err != nil {
		log.Printf("SetAdminHandler: Error updating role for user %d: %v\n", user.ID, err)
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(ErrorResponse{Success: false, Message: "Failed to update user role in database"})
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(SetAdminResponse{
		Success: true,
		Message: "User role updated successfully",
		UserID:  updatedUser.ID,
		Role:    updatedUser.Role,
	})
}



================================================
File: pkg/handlers/appOpenHandler.go
================================================
package handlers

import (
	"log"
	"net/http"

	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/arnnvv/peeple-api/pkg/utils"
)

type AppOpenResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

func LogAppOpenHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	if r.Method != http.MethodPost {
		utils.RespondWithJSON(w, http.StatusMethodNotAllowed, AppOpenResponse{
			Success: false, Message: "Method Not Allowed: Use POST",
		})
		return
	}

	claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil || claims.UserID <= 0 {
		utils.RespondWithJSON(w, http.StatusUnauthorized, AppOpenResponse{
			Success: false, Message: "Authentication required",
		})
		return
	}
	userID := int32(claims.UserID)

	log.Printf("LogAppOpenHandler: Logging app open for user %d", userID)
	err := queries.LogAppOpen(ctx, userID)
	if err != nil {
		log.Printf("LogAppOpenHandler: Error logging app open for user %d: %v", userID, err)
		utils.RespondWithJSON(w, http.StatusInternalServerError, AppOpenResponse{
			Success: false, Message: "Database error logging event",
		})
		return
	}
	log.Printf("LogAppOpenHandler: App open successfully logged for user %d", userID)

	utils.RespondWithJSON(w, http.StatusOK, AppOpenResponse{
		Success: true,
		Message: "App open event logged successfully",
	})
}



================================================
File: pkg/handlers/audio.go
================================================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/jackc/pgx/v5/pgtype"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/s3"
)

type AudioFileRequest struct {
	Filename string `json:"filename"`
	Type     string `json:"type"`
	Prompt   string `json:"prompt"`
}

type AudioUploadURL struct {
	Filename string `json:"filename"`
	Type     string `json:"type"`
	URL      string `json:"url"`
	Prompt   string `json:"prompt"`
}

var allowedAudioTypes = map[string]bool{
	"audio/mpeg":           true, // MP3
	"audio/wav":            true, // WAV
	"audio/ogg":            true, // OGG Vorbis/Opus
	"audio/webm":           true, // WebM Audio (often Opus or Vorbis)
	"audio/aac":            true, // AAC
	"audio/x-m4a":          true, // M4A (often AAC) - common Apple format
	"audio/mp4":            true, // MP4 audio (can contain AAC, ALAC, etc.)
	"audio/flac":           true, // FLAC
	"audio/opus":           true, // Opus
	"audio/amr":            true, // AMR (common in mobile)
	"audio/basic":          true, // Basic audio (.au, .snd)
	"audio/midi":           true, // MIDI
	"audio/x-aiff":         true, // AIFF
	"audio/x-pn-realaudio": true, // RealAudio
	"audio/x-tta":          true, // True Audio
	"audio/x-wavpack":      true, // WavPack
	"audio/x-ms-wma":       true, // WMA (use with caution, might need specific header checks)
}

var audioPromptMap map[string]migrations.AudioPrompt

func init() {
	audioPromptMap = map[string]migrations.AudioPrompt{
		"canWeTalkAbout":                  migrations.AudioPromptCanWeTalkAbout,
		"captionThisPhoto":                migrations.AudioPromptCaptionThisPhoto,
		"caughtInTheAct":                  migrations.AudioPromptCaughtInTheAct,
		"changeMyMindAbout":               migrations.AudioPromptChangeMyMindAbout,
		"chooseOurFirstDate":              migrations.AudioPromptChooseOurFirstDate,
		"commentIfYouveBeenHere":          migrations.AudioPromptCommentIfYouveBeenHere,
		"cookWithMe":                      migrations.AudioPromptCookWithMe,
		"datingMeIsLike":                  migrations.AudioPromptDatingMeIsLike,
		"datingMeWillLookLike":            migrations.AudioPromptDatingMeWillLookLike,
		"doYouAgreeOrDisagreeThat":        migrations.AudioPromptDoYouAgreeOrDisagreeThat,
		"dontHateMeIfI":                   migrations.AudioPromptDontHateMeIfI,
		"dontJudgeMe":                     migrations.AudioPromptDontJudgeMe,
		"mondaysAmIRight":                 migrations.AudioPromptMondaysAmIRight,
		"aBoundaryOfMineIs":               migrations.AudioPromptABoundaryOfMineIs,
		"aDailyEssential":                 migrations.AudioPromptADailyEssential,
		"aDreamHomeMustInclude":           migrations.AudioPromptADreamHomeMustInclude,
		"aFavouriteMemoryOfMine":          migrations.AudioPromptAFavouriteMemoryOfMine,
		"aFriendsReviewOfMe":              migrations.AudioPromptAFriendsReviewOfMe,
		"aLifeGoalOfMine":                 migrations.AudioPromptALifeGoalOfMine,
		"aQuickRantAbout":                 migrations.AudioPromptAQuickRantAbout,
		"aRandomFactILoveIs":              migrations.AudioPromptARandomFactILoveIs,
		"aSpecialTalentOfMine":            migrations.AudioPromptASpecialTalentOfMine,
		"aThoughtIRecentlyHadInTheShower": migrations.AudioPromptAThoughtIRecentlyHadInTheShower,
		"allIAskIsThatYou":                migrations.AudioPromptAllIAskIsThatYou,
		"guessWhereThisPhotoWasTaken":     migrations.AudioPromptGuessWhereThisPhotoWasTaken,
		"helpMeIdentifyThisPhotoBomber":   migrations.AudioPromptHelpMeIdentifyThisPhotoBomber,
		"hiFromMeAndMyPet":                migrations.AudioPromptHiFromMeAndMyPet,
		"howIFightTheSundayScaries":       migrations.AudioPromptHowIFightTheSundayScaries,
		"howHistoryWillRememberMe":        migrations.AudioPromptHowHistoryWillRememberMe,
		"howMyFriendsSeeMe":               migrations.AudioPromptHowMyFriendsSeeMe,
		"howToPronounceMyName":            migrations.AudioPromptHowToPronounceMyName,
		"iBeatMyBluesBy":                  migrations.AudioPromptIBeatMyBluesBy,
		"iBetYouCant":                     migrations.AudioPromptIBetYouCant,
		"iCanTeachYouHowTo":               migrations.AudioPromptICanTeachYouHowTo,
		"iFeelFamousWhen":                 migrations.AudioPromptIFeelFamousWhen,
		"iFeelMostSupportedWhen":          migrations.AudioPromptIFeelMostSupportedWhen,
	}
}

func parseMigrationsAudioPrompt(promptStr string) (migrations.AudioPrompt, error) {
	enumValue, ok := audioPromptMap[promptStr]
	if !ok {
		return "", fmt.Errorf("invalid audio prompt value: '%s'", promptStr)
	}
	return enumValue, nil
}

func GenerateAudioPresignedURL(w http.ResponseWriter, r *http.Request) {
	const operation = "handlers.GenerateAudioPresignedURL"
	if r.Method != http.MethodPost {
		respondWithError(w, http.StatusMethodNotAllowed, "Method Not Allowed: Use POST", operation)
		return
	}

	claims, ok := r.Context().Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil || claims.UserID <= 0 {
		respondWithError(w, http.StatusUnauthorized, "Authentication required: Invalid or missing token claims", operation)
		return
	}
	userID := claims.UserID

	awsRegion := os.Getenv("AWS_REGION")
	awsAccessKey := os.Getenv("AWS_ACCESS_KEY_ID")
	awsSecretKey := os.Getenv("AWS_SECRET_ACCESS_KEY")
	s3Bucket := os.Getenv("S3_BUCKET")

	if awsRegion == "" || awsAccessKey == "" || awsSecretKey == "" || s3Bucket == "" {
		log.Printf("[%s] Critical configuration error: Missing one or more AWS environment variables (REGION, ACCESS_KEY_ID, SECRET_ACCESS_KEY, S3_BUCKET)", operation)
		respondWithError(w, http.StatusInternalServerError, "Server configuration error prevents file uploads", operation)
		return
	}

	var requestBody AudioFileRequest
	if err := json.NewDecoder(r.Body).Decode(&requestBody); err != nil {
		log.Printf("[%s] Failed to decode request body: %v", operation, err)
		respondWithError(w, http.StatusBadRequest, "Invalid request body format", operation)
		return
	}
	defer r.Body.Close()

	if requestBody.Filename == "" || requestBody.Type == "" || requestBody.Prompt == "" {
		respondWithError(w, http.StatusBadRequest, "Missing required fields in request: filename, type, or prompt", operation)
		return
	}

	audioPromptEnum, err := parseMigrationsAudioPrompt(requestBody.Prompt)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, err.Error(), operation)
		return
	}

	if !isValidAudioType(requestBody.Type) {
		respondWithError(w, http.StatusBadRequest, fmt.Sprintf("Unsupported audio file type: '%s'", requestBody.Type), operation)
		return
	}

	sess, err := session.NewSession(&aws.Config{
		Region:      aws.String(awsRegion),
		Credentials: credentials.NewStaticCredentials(awsAccessKey, awsSecretKey, ""),
	})
	if err != nil {
		log.Printf("[%s] Failed to initialize AWS session: %v", operation, err)
		respondWithError(w, http.StatusInternalServerError, "Failed to connect to storage service", operation)
		return
	}

	s3Client := s3.New(sess)

	s3Key := generateS3Key(int32(userID), audioPromptEnum, requestBody.Filename)

	presignedPutURL, permanentObjectURL, err := createPresignedURL(s3Client, s3Bucket, s3Key, requestBody.Type)
	if err != nil {
		log.Printf("[%s] Failed to generate presigned URL for key '%s': %v", operation, s3Key, err)
		respondWithError(w, http.StatusInternalServerError, "Failed to prepare file upload URL", operation)
		return
	}

	queries := db.GetDB()

	err = handleDatabaseOperations(r.Context(), queries, int32(userID), permanentObjectURL, audioPromptEnum)
	if err != nil {
		log.Printf("[%s] Failed to update database for user %d with audio URL '%s': %v", operation, userID, permanentObjectURL, err)
		respondWithError(w, http.StatusInternalServerError, "Failed to save audio information", operation)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(AudioUploadURL{
		Filename: requestBody.Filename,
		Type:     requestBody.Type,
		URL:      presignedPutURL,
		Prompt:   requestBody.Prompt,
	})
}

func generateS3Key(userID int32, prompt migrations.AudioPrompt, filename string) string {
	safeFilename := strings.ReplaceAll(filename, "/", "_")
	promptStr := strings.ToLower(string(prompt))

	return fmt.Sprintf("users/%d/audio/%s/%d-%s",
		userID,
		promptStr,
		time.Now().UnixNano(),
		safeFilename,
	)
}

func createPresignedURL(s3Client *s3.S3, bucket, key, fileType string) (string, string, error) {
	req, _ := s3Client.PutObjectRequest(&s3.PutObjectInput{
		Bucket:      aws.String(bucket),
		Key:         aws.String(key),
		ContentType: aws.String(fileType), // Content-Type for the uploaded object.
		// ACL: aws.String("private"), // Default ACL is private. Set "public-read" if needed.
	})

	presignDuration := 15 * time.Minute
	presignedURL, err := req.Presign(presignDuration)
	if err != nil {
		return "", "", fmt.Errorf("failed to presign request for key '%s': %w", key, err)
	}

	region := aws.StringValue(s3Client.Config.Region)
	permanentURL := fmt.Sprintf("https://%s.s3.%s.amazonaws.com/%s",
		bucket,
		region,
		key)

	return presignedURL, permanentURL, nil
}

func handleDatabaseOperations(ctx context.Context, queries *migrations.Queries, userID int32, audioURL string, prompt migrations.AudioPrompt) error {
	params := migrations.UpdateAudioPromptParams{
		AudioPromptQuestion: migrations.NullAudioPrompt{
			AudioPrompt: prompt,
			Valid:       true,
		},
		AudioPromptAnswer: pgtype.Text{
			String: audioURL,
			Valid:  true,
		},
		ID: userID,
	}

	_, err := queries.UpdateAudioPrompt(ctx, params)
	if err != nil {
		return fmt.Errorf("sqlc UpdateUserAudioPrompt failed for user %d: %w", userID, err)
	}

	return nil
}

func respondWithError(w http.ResponseWriter, code int, message string, operation string) {
	log.Printf("[%s] Error %d: %s", operation, code, message)
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Cache-Control", "no-store")
	w.Header().Set("Pragma", "no-cache")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(ErrorResponse{
		Success: false,
		Message: message,
	})
}

func isValidAudioType(mimeType string) bool {
	_, ok := allowedAudioTypes[strings.ToLower(mimeType)]
	return ok
}



================================================
File: pkg/handlers/checkauthstatus.go
================================================
package handlers

import (
	"database/sql"
	"encoding/json"
	"errors"
	"log"
	"net/http"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/arnnvv/peeple-api/pkg/utils"
	"github.com/jackc/pgx/v5"
)

type AuthStatusResponse struct {
	Success bool   `json:"success"`
	Status  string `json:"status"`
	Message string `json:"message,omitempty"`
}

func CheckAuthStatus(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	claims, ok := r.Context().Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil {
		utils.RespondWithJSON(w, http.StatusUnauthorized, AuthStatusResponse{
			Success: false,
			Status:  "login",
			Message: "Invalid or missing token",
		})
		return
	}

	userID := int32(claims.UserID)

	var user migrations.User
	var err error

	queries := db.GetDB()
	user, err = queries.GetUserByID(r.Context(), userID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) || errors.Is(err, pgx.ErrNoRows) {
			log.Printf("[%s] User not found for ID: %d", "handlers.CheckAuthStatus", userID)
			respondAuthStatus(w, http.StatusUnauthorized, AuthStatusResponse{
				Success: false,
				Status:  "login",
				Message: "User account not found",
			})
		} else {
			log.Printf("[%s] Database error fetching user ID %d: %v", "handlers.CheckAuthStatus", userID, err)
			respondAuthStatus(w, http.StatusInternalServerError, AuthStatusResponse{
				Success: false,
				Status:  "login", // generic error status will be btr
				Message: "Error checking user status",
			})
		}
		return
	}

	if !user.Name.Valid || user.Name.String == "" {
		respondAuthStatus(w, http.StatusOK, AuthStatusResponse{
			Success: true,
			Status:  "onboarding",
			Message: "User profile requires completion",
		})
		return
	}

	respondAuthStatus(w, http.StatusOK, AuthStatusResponse{
		Success: true,
		Status:  "home",
		Message: "User authenticated",
	})

}

func respondAuthStatus(w http.ResponseWriter, code int, payload AuthStatusResponse) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	if err := json.NewEncoder(w).Encode(payload); err != nil {
		log.Printf("Error encoding auth status response: %v", err)
	}
}



================================================
File: pkg/handlers/createprofile.go
================================================
package handlers

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log" // Import log package
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db" // Import db package
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	// "github.com/jackc/pgx/v5/pgxpool" // No longer needed here
)

// var dbPool *pgxpool.Pool // REMOVED: Use db.GetDB() and db.GetPool() instead

func respondError(w http.ResponseWriter, msg string, code int) {
	log.Printf("[ERROR %d] %s", code, msg) // Log errors
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(map[string]any{
		"success": false,
		"message": msg,
	})
}

type createProfileRequest struct {
	Name             *string                           `json:"name"`
	LastName         *string                           `json:"last_name"`
	DateOfBirth      *string                           `json:"date_of_birth"`
	Latitude         *float64                          `json:"latitude"`
	Longitude        *float64                          `json:"longitude"`
	Gender           *migrations.GenderEnum            `json:"gender"`
	DatingIntention  *migrations.DatingIntention       `json:"dating_intention"`
	Height           *string                           `json:"height"`
	Hometown         *string                           `json:"hometown"`
	JobTitle         *string                           `json:"job_title"`
	Education        *string                           `json:"education"`
	ReligiousBeliefs *migrations.Religion              `json:"religious_beliefs"`
	DrinkingHabit    *migrations.DrinkingSmokingHabits `json:"drinking_habit"`
	SmokingHabit     *migrations.DrinkingSmokingHabits `json:"smoking_habit"`
	Prompts          []promptRequest                   `json:"prompts"`
}

type promptRequest struct {
	Category string `json:"category"`
	Question string `json:"question"`
	Answer   string `json:"answer"`
}

func CreateProfile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	fmt.Println("\n=== Starting Profile Creation (sqlc) ===")
	defer fmt.Println("=== End Profile Creation (sqlc) ===")

	// Get DB Queries object
	queries := db.GetDB()
	if queries == nil {
		respondError(w, "Database connection is not available", http.StatusInternalServerError)
		return
	}
	// Get the pool for transaction management
	pool := db.GetPool()
	if pool == nil {
		respondError(w, "Database connection pool is not available for transaction", http.StatusInternalServerError)
		return
	}

	claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil {
		respondError(w, "Invalid token claims", http.StatusUnauthorized) // More specific error
		return
	}
	userID := int32(claims.UserID)
	fmt.Printf("[Auth] UserID from token: %d\n", userID)

	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		respondError(w, "Failed to read request body", http.StatusInternalServerError)
		return
	}
	r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes)) // Rewind body for potential re-reads (though not needed here)
	fmt.Printf("[Request] Raw body: %s\n", string(bodyBytes))

	var reqData createProfileRequest
	if err := json.Unmarshal(bodyBytes, &reqData); err != nil {
		fmt.Printf("[Decode Error] %v\n", err)
		respondError(w, fmt.Sprintf("Invalid request format: %v", err), http.StatusBadRequest)
		return
	}

	// Use the obtained queries object
	_, err = queries.GetUserByID(ctx, userID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			fmt.Printf("[Error] User lookup failed: User ID %d not found\n", userID)
			respondError(w, "User not found", http.StatusNotFound)
		} else {
			fmt.Printf("[Error] User lookup failed: %v\n", err)
			respondError(w, "Database error checking user", http.StatusInternalServerError)
		}
		return
	}
	fmt.Printf("[Existing User] Found User ID: %d\n", userID)

	// --- Parameter Preparation ---
	var genderParam migrations.NullGenderEnum
	if reqData.Gender != nil {
		genderParam = migrations.NullGenderEnum{GenderEnum: *reqData.Gender, Valid: true}
	} else {
		genderParam = migrations.NullGenderEnum{Valid: false}
	}

	var datingIntentionParam migrations.NullDatingIntention
	if reqData.DatingIntention != nil {
		datingIntentionParam = migrations.NullDatingIntention{DatingIntention: *reqData.DatingIntention, Valid: true}
	} else {
		datingIntentionParam = migrations.NullDatingIntention{Valid: false}
	}

	var religiousBeliefsParam migrations.NullReligion
	if reqData.ReligiousBeliefs != nil {
		religiousBeliefsParam = migrations.NullReligion{Religion: *reqData.ReligiousBeliefs, Valid: true}
	} else {
		religiousBeliefsParam = migrations.NullReligion{Valid: false}
	}

	var drinkingHabitParam migrations.NullDrinkingSmokingHabits
	if reqData.DrinkingHabit != nil {
		drinkingHabitParam = migrations.NullDrinkingSmokingHabits{DrinkingSmokingHabits: *reqData.DrinkingHabit, Valid: true}
	} else {
		drinkingHabitParam = migrations.NullDrinkingSmokingHabits{Valid: false}
	}

	var smokingHabitParam migrations.NullDrinkingSmokingHabits
	if reqData.SmokingHabit != nil {
		smokingHabitParam = migrations.NullDrinkingSmokingHabits{DrinkingSmokingHabits: *reqData.SmokingHabit, Valid: true}
	} else {
		smokingHabitParam = migrations.NullDrinkingSmokingHabits{Valid: false}
	}

	updateParams := migrations.UpdateUserProfileParams{
		ID:               userID,
		Name:             pgtype.Text{String: derefString(reqData.Name), Valid: reqData.Name != nil && *reqData.Name != ""},
		LastName:         pgtype.Text{String: derefString(reqData.LastName), Valid: reqData.LastName != nil},
		Latitude:         pgtype.Float8{Float64: derefFloat64(reqData.Latitude), Valid: reqData.Latitude != nil},
		Longitude:        pgtype.Float8{Float64: derefFloat64(reqData.Longitude), Valid: reqData.Longitude != nil},
		Gender:           genderParam,
		DatingIntention:  datingIntentionParam,
		Hometown:         pgtype.Text{String: derefString(reqData.Hometown), Valid: reqData.Hometown != nil},
		JobTitle:         pgtype.Text{String: derefString(reqData.JobTitle), Valid: reqData.JobTitle != nil},
		Education:        pgtype.Text{String: derefString(reqData.Education), Valid: reqData.Education != nil},
		ReligiousBeliefs: religiousBeliefsParam,
		DrinkingHabit:    drinkingHabitParam,
		SmokingHabit:     smokingHabitParam,
	}

	if reqData.DateOfBirth != nil && *reqData.DateOfBirth != "" {
		dob, err := time.Parse("2006-01-02", *reqData.DateOfBirth)
		if err != nil {
			respondError(w, "Invalid date_of_birth format. Use YYYY-MM-DD.", http.StatusBadRequest)
			return
		}
		updateParams.DateOfBirth = pgtype.Date{Time: dob, Valid: true}
	} else {
		updateParams.DateOfBirth = pgtype.Date{Valid: false} // Explicitly set Valid to false if DOB is nil or empty
	}

	if reqData.Height != nil && *reqData.Height != "" {
		heightInches, err := parseHeightString(*reqData.Height)
		if err != nil {
			respondError(w, fmt.Sprintf("Invalid height format: %v", err), http.StatusBadRequest)
			return
		}
		updateParams.Height = pgtype.Float8{Float64: heightInches, Valid: true}
	} else {
		updateParams.Height = pgtype.Float8{Valid: false} // Explicitly set Valid to false if Height is nil or empty
	}

	if err := validateProfileSqlc(updateParams, reqData.Prompts); err != nil {
		fmt.Printf("[Validation Failed] %s\n", err)
		respondError(w, err.Error(), http.StatusBadRequest)
		return
	}
	fmt.Println("[Validation] Input data passed validation.")

	fmt.Println("[Database] Starting transaction...")
	// Use the obtained pool to begin transaction
	tx, err := pool.Begin(ctx)
	if err != nil {
		fmt.Printf("[Database Error] Failed to begin transaction: %v\n", err)
		respondError(w, "Database error starting transaction", http.StatusInternalServerError)
		return
	}
	// Ensure rollback happens if commit doesn't
	defer tx.Rollback(ctx) // Rollback is safe to call even after commit

	// Use the original queries object with the transaction
	qtx := queries.WithTx(tx)

	fmt.Println("[Database] Updating user profile...")
	_, err = qtx.UpdateUserProfile(ctx, updateParams)
	if err != nil {
		fmt.Printf("[Database Error] Failed to update user profile: %v\n", err)
		respondError(w, "Failed to update profile", http.StatusInternalServerError)
		return
	}
	fmt.Println("[Database] User profile updated.")

	// --- Prompt Handling within Transaction ---
	fmt.Println("[Database] Deleting existing prompts...")
	if err := qtx.DeleteUserDateVibesPrompts(ctx, userID); err != nil && !errors.Is(err, pgx.ErrNoRows) {
		fmt.Printf("[Database Error] Failed to delete Date Vibes prompts: %v\n", err)
		respondError(w, "Failed to update prompts (delete DV)", http.StatusInternalServerError)
		return // Exit on error
	}
	if err := qtx.DeleteUserGettingPersonalPrompts(ctx, userID); err != nil && !errors.Is(err, pgx.ErrNoRows) {
		fmt.Printf("[Database Error] Failed to delete Getting Personal prompts: %v\n", err)
		respondError(w, "Failed to update prompts (delete GP)", http.StatusInternalServerError)
		return // Exit on error
	}
	if err := qtx.DeleteUserMyTypePrompts(ctx, userID); err != nil && !errors.Is(err, pgx.ErrNoRows) {
		fmt.Printf("[Database Error] Failed to delete My Type prompts: %v\n", err)
		respondError(w, "Failed to update prompts (delete MT)", http.StatusInternalServerError)
		return // Exit on error
	}
	if err := qtx.DeleteUserStoryTimePrompts(ctx, userID); err != nil && !errors.Is(err, pgx.ErrNoRows) {
		fmt.Printf("[Database Error] Failed to delete Story Time prompts: %v\n", err)
		respondError(w, "Failed to update prompts (delete ST)", http.StatusInternalServerError)
		return // Exit on error
	}
	fmt.Println("[Database] Existing prompts deleted.")

	fmt.Printf("[Database] Creating %d new prompts...\n", len(reqData.Prompts))
	for i, p := range reqData.Prompts {
		fmt.Printf("[Database] Processing prompt %d: Category=%s, Question=%s\n", i+1, p.Category, p.Question)
		var promptErr error
		switch p.Category {
		case "dateVibes":
			promptEnum, err := parseDateVibesEnum(p.Question)
			if err != nil {
				promptErr = fmt.Errorf("invalid dateVibes question '%s'", p.Question)
				break
			}
			_, promptErr = qtx.CreateDateVibesPrompt(ctx, migrations.CreateDateVibesPromptParams{
				UserID:   userID,
				Question: promptEnum,
				Answer:   p.Answer,
			})
		case "gettingPersonal":
			promptEnum, err := parseGettingPersonalEnum(p.Question)
			if err != nil {
				promptErr = fmt.Errorf("invalid gettingPersonal question '%s'", p.Question)
				break
			}
			_, promptErr = qtx.CreateGettingPersonalPrompt(ctx, migrations.CreateGettingPersonalPromptParams{
				UserID:   userID,
				Question: promptEnum,
				Answer:   p.Answer,
			})
		case "myType":
			promptEnum, err := parseMyTypeEnum(p.Question)
			if err != nil {
				promptErr = fmt.Errorf("invalid myType question '%s'", p.Question)
				break
			}
			_, promptErr = qtx.CreateMyTypePrompt(ctx, migrations.CreateMyTypePromptParams{
				UserID:   userID,
				Question: promptEnum,
				Answer:   p.Answer,
			})
		case "storyTime":
			promptEnum, err := parseStoryTimeEnum(p.Question)
			if err != nil {
				promptErr = fmt.Errorf("invalid storyTime question '%s'", p.Question)
				break
			}
			_, promptErr = qtx.CreateStoryTimePrompt(ctx, migrations.CreateStoryTimePromptParams{
				UserID:   userID,
				Question: promptEnum,
				Answer:   p.Answer,
			})
		default:
			promptErr = fmt.Errorf("unknown prompt category '%s'", p.Category)
		}

		if promptErr != nil {
			fmt.Printf("[Database Error] Failed to create prompt (Cat: %s, Q: %s): %v\n", p.Category, p.Question, promptErr)
			// No need to rollback here, defer tx.Rollback(ctx) handles it
			respondError(w, fmt.Sprintf("Failed to save prompt: %v", promptErr), http.StatusInternalServerError)
			return // Exit on first prompt error
		}
	}
	fmt.Println("[Database] New prompts created.")

	if err := tx.Commit(ctx); err != nil {
		fmt.Printf("[Database Error] Failed to commit transaction: %v\n", err)
		respondError(w, "Database error saving profile", http.StatusInternalServerError)
		return
	}
	fmt.Println("[Database] Transaction committed successfully.")

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]any{
		"success": true,
		"message": "Profile updated successfully",
	})
	fmt.Println("[Success] Profile update complete.")
}

// --- Helper functions for parsing enums safely ---

func parseDateVibesEnum(s string) (migrations.DateVibesPromptType, error) {
	val := migrations.DateVibesPromptType(s)
	switch val {
	case migrations.DateVibesPromptTypeTogetherWeCould,
		migrations.DateVibesPromptTypeFirstRoundIsOnMeIf,
		migrations.DateVibesPromptTypeWhatIOrderForTheTable,
		migrations.DateVibesPromptTypeBestSpotInTown,
		migrations.DateVibesPromptTypeBestWayToAskMeOut:
		return val, nil
	default:
		return "", fmt.Errorf("invalid DateVibesPromptType: %s", s)
	}
}

func parseGettingPersonalEnum(s string) (migrations.GettingPersonalPromptType, error) {
	val := migrations.GettingPersonalPromptType(s)
	switch val {
	case migrations.GettingPersonalPromptTypeOneThingYouShouldKnow,
		migrations.GettingPersonalPromptTypeLoveLanguage,
		migrations.GettingPersonalPromptTypeDorkiestThing,
		migrations.GettingPersonalPromptTypeDontHateMeIf,
		migrations.GettingPersonalPromptTypeGeekOutOn,
		migrations.GettingPersonalPromptTypeIfLovingThisIsWrong,
		migrations.GettingPersonalPromptTypeKeyToMyHeart,
		migrations.GettingPersonalPromptTypeWontShutUpAbout,
		migrations.GettingPersonalPromptTypeShouldNotGoOutWithMeIf,
		migrations.GettingPersonalPromptTypeWhatIfIToldYouThat:
		return val, nil
	default:
		return "", fmt.Errorf("invalid GettingPersonalPromptType: %s", s)
	}
}

func parseMyTypeEnum(s string) (migrations.MyTypePromptType, error) {
	val := migrations.MyTypePromptType(s)
	switch val {
	case migrations.MyTypePromptTypeNonNegotiable,
		migrations.MyTypePromptTypeHallmarkOfGoodRelationship,
		migrations.MyTypePromptTypeLookingFor,
		migrations.MyTypePromptTypeWeirdlyAttractedTo,
		migrations.MyTypePromptTypeAllIAskIsThatYou,
		migrations.MyTypePromptTypeWellGetAlongIf,
		migrations.MyTypePromptTypeWantSomeoneWho,
		migrations.MyTypePromptTypeGreenFlags,
		migrations.MyTypePromptTypeSameTypeOfWeird,
		migrations.MyTypePromptTypeFallForYouIf,
		migrations.MyTypePromptTypeBragAboutYou:
		return val, nil
	default:
		return "", fmt.Errorf("invalid MyTypePromptType: %s", s)
	}
}

func parseStoryTimeEnum(s string) (migrations.StoryTimePromptType, error) {
	val := migrations.StoryTimePromptType(s)
	switch val {
	case migrations.StoryTimePromptTypeTwoTruthsAndALie,
		migrations.StoryTimePromptTypeWorstIdea,
		migrations.StoryTimePromptTypeBiggestRisk,
		migrations.StoryTimePromptTypeBiggestDateFail,
		migrations.StoryTimePromptTypeNeverHaveIEver,
		migrations.StoryTimePromptTypeBestTravelStory,
		migrations.StoryTimePromptTypeWeirdestGift,
		migrations.StoryTimePromptTypeMostSpontaneous,
		migrations.StoryTimePromptTypeOneThingNeverDoAgain:
		return val, nil
	default:
		return "", fmt.Errorf("invalid StoryTimePromptType: %s", s)
	}
}

// --- Helper functions for dereferencing pointers safely ---

func derefString(s *string) string {
	if s != nil {
		return *s
	}
	return ""
}

func derefFloat64(f *float64) float64 {
	if f != nil {
		return *f
	}
	return 0.0
}

// --- Validation Logic (unchanged, but now uses helpers) ---

var heightRegex = regexp.MustCompile(`^[4-6]'([0-9]|1[0-1])"$`)

func validateProfileSqlc(params migrations.UpdateUserProfileParams, prompts []promptRequest) error {
	fmt.Println("\n=== Starting Profile Validation (sqlc) ===")
	defer fmt.Println("=== End Profile Validation (sqlc) ===\n")

	// Basic Info
	if !params.Name.Valid || len(params.Name.String) == 0 {
		return fmt.Errorf("name is required")
	}
	if len(params.Name.String) > 20 {
		return fmt.Errorf("name must not exceed 20 characters")
	}
	fmt.Printf("[Validation] Name: OK ('%s')\n", params.Name.String)

	if params.LastName.Valid && len(params.LastName.String) > 20 {
		return fmt.Errorf("last name must not exceed 20 characters")
	}
	fmt.Printf("[Validation] LastName: OK (Valid: %t, Value: '%s')\n", params.LastName.Valid, params.LastName.String)

	if !params.DateOfBirth.Valid {
		return fmt.Errorf("date of birth is required")
	}
	if params.DateOfBirth.Time.IsZero() {
		return fmt.Errorf("date of birth appears invalid or was not parsed correctly")
	}
	age := time.Since(params.DateOfBirth.Time).Hours() / 24 / 365.25
	fmt.Printf("[Validation] DOB: OK (%s), Calculated Age: %.2f\n", params.DateOfBirth.Time.Format("2006-01-02"), age)
	if age < 18 {
		return fmt.Errorf("must be at least 18 years old")
	}

	if !params.Latitude.Valid || !params.Longitude.Valid {
		return fmt.Errorf("latitude and longitude are required")
	}
	if params.Latitude.Float64 < -90 || params.Latitude.Float64 > 90 {
		return fmt.Errorf("latitude must be between -90 and 90")
	}
	if params.Longitude.Float64 < -180 || params.Longitude.Float64 > 180 {
		return fmt.Errorf("longitude must be between -180 and 180")
	}
	fmt.Printf("[Validation] Location: OK (Lat: %.6f, Lon: %.6f)\n", params.Latitude.Float64, params.Longitude.Float64)

	// Profile Details
	if !params.Height.Valid {
		return fmt.Errorf("height is required")
	}
	fmt.Printf("[Validation] Height: OK (Value: %.2f inches)\n", params.Height.Float64)

	if !params.Gender.Valid {
		return fmt.Errorf("gender is required")
	}
	fmt.Printf("[Validation] Gender: OK (%s)\n", params.Gender.GenderEnum)

	if !params.DatingIntention.Valid {
		return fmt.Errorf("dating intention is required")
	}
	fmt.Printf("[Validation] Dating Intention: OK (%s)\n", params.DatingIntention.DatingIntention)

	if !params.ReligiousBeliefs.Valid {
		return fmt.Errorf("religious beliefs is required")
	}
	fmt.Printf("[Validation] Religious Beliefs: OK (%s)\n", params.ReligiousBeliefs.Religion)

	if !params.DrinkingHabit.Valid {
		return fmt.Errorf("drinking habit is required")
	}
	fmt.Printf("[Validation] Drinking Habit: OK (%s)\n", params.DrinkingHabit.DrinkingSmokingHabits)

	if !params.SmokingHabit.Valid {
		return fmt.Errorf("smoking habit is required")
	}
	fmt.Printf("[Validation] Smoking Habit: OK (%s)\n", params.SmokingHabit.DrinkingSmokingHabits)

	// Optional Fields Length Checks (LIMITS UPDATED HERE)
	if params.Hometown.Valid && len(params.Hometown.String) > 30 { // Changed 15 to 30
		return fmt.Errorf("hometown must not exceed 30 characters") // Updated message
	}
	fmt.Printf("[Validation] Hometown: OK (Valid: %t, Value: '%s', Limit: 30)\n", params.Hometown.Valid, params.Hometown.String)

	if params.JobTitle.Valid && len(params.JobTitle.String) > 30 { // Changed 15 to 30
		return fmt.Errorf("job title must not exceed 30 characters") // Updated message
	}
	fmt.Printf("[Validation] JobTitle: OK (Valid: %t, Value: '%s', Limit: 30)\n", params.JobTitle.Valid, params.JobTitle.String)

	if params.Education.Valid && len(params.Education.String) > 30 { // Changed 15 to 30
		return fmt.Errorf("education must not exceed 30 characters") // Updated message
	}
	fmt.Printf("[Validation] Education: OK (Valid: %t, Value: '%s', Limit: 30)\n", params.Education.Valid, params.Education.String)

	// Prompt Validation
	fmt.Printf("[Validation] Checking prompts. Count: %d\n", len(prompts))
	if len(prompts) == 0 {
		return fmt.Errorf("at least one prompt is required")
	}
	if len(prompts) > 3 {
		return fmt.Errorf("maximum of 3 prompts allowed")
	}

	promptQuestions := make(map[string]bool)
	for i, p := range prompts {
		fmt.Printf("[Validation] Checking prompt %d: Category=%s, Question=%s\n", i+1, p.Category, p.Question)
		if p.Category == "" {
			return fmt.Errorf("prompt %d: category is required", i+1)
		}
		if p.Question == "" {
			return fmt.Errorf("prompt %d: question is required", i+1)
		}
		if strings.TrimSpace(p.Answer) == "" {
			return fmt.Errorf("prompt %d: answer cannot be empty or just whitespace", i+1)
		}
		if len(p.Answer) > 255 {
			return fmt.Errorf("prompt %d: answer exceeds maximum length (255 chars)", i+1)
		}

		var parseErr error
		switch p.Category {
		case "dateVibes":
			_, parseErr = parseDateVibesEnum(p.Question)
		case "gettingPersonal":
			_, parseErr = parseGettingPersonalEnum(p.Question)
		case "myType":
			_, parseErr = parseMyTypeEnum(p.Question)
		case "storyTime":
			_, parseErr = parseStoryTimeEnum(p.Question)
		default:
			return fmt.Errorf("prompt %d: unknown category '%s'", i+1, p.Category)
		}

		if parseErr != nil {
			return fmt.Errorf("prompt %d: invalid question '%s' for category '%s'", i+1, p.Question, p.Category)
		}

		questionKey := fmt.Sprintf("%s:%s", p.Category, p.Question)
		if promptQuestions[questionKey] {
			return fmt.Errorf("prompt question '%s' under category '%s' cannot be used more than once", p.Question, p.Category)
		}
		promptQuestions[questionKey] = true

		fmt.Printf("[Validation] Prompt %d: OK\n", i+1)
	}

	fmt.Println("[Validation] All checks passed successfully")
	return nil
}

func parseHeightString(heightStr string) (float64, error) {
	if !heightRegex.MatchString(heightStr) {
		return 0, fmt.Errorf("invalid format. Use F'I\" (e.g., 5'10\")")
	}
	// Improved splitting to handle potential extra spaces
	parts := strings.Split(strings.TrimSpace(strings.TrimSuffix(heightStr, "\"")), "'")
	if len(parts) != 2 {
		// Attempt to fix common issue like "5' 10\""
		parts = strings.FieldsFunc(strings.TrimSuffix(heightStr, "\""), func(r rune) bool {
			return r == '\'' || r == ' '
		})
		if len(parts) != 2 {
			return 0, fmt.Errorf("internal parsing error, expected format F'I\"")
		}
	}

	feetStr := strings.TrimSpace(parts[0])
	inchesStr := strings.TrimSpace(parts[1])

	feet, err := strconv.Atoi(feetStr)
	if err != nil {
		return 0, fmt.Errorf("invalid feet value '%s': %w", feetStr, err)
	}
	inches, err := strconv.Atoi(inchesStr)
	if err != nil {
		return 0, fmt.Errorf("invalid inches value '%s': %w", inchesStr, err)
	}

	if feet < 4 || feet > 6 {
		return 0, fmt.Errorf("feet value must be between 4 and 6")
	}
	if inches < 0 || inches > 11 {
		return 0, fmt.Errorf("inches value must be between 0 and 11")
	}

	totalInches := float64(feet*12 + inches)
	return totalInches, nil
}



================================================
File: pkg/handlers/filtersHandler.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/arnnvv/peeple-api/pkg/utils"
	"github.com/jackc/pgx/v5/pgtype"
)

// ApplyFiltersRequest defines the expected structure for the filter request body.
type ApplyFiltersRequest struct {
	WhoYouWantToSee string `json:"whoYouWantToSee"` // Expect "man" or "woman"
	RadiusKm        int    `json:"radius"`          // In kilometers
	ActiveToday     *bool  `json:"activeToday"`     // Optional, defaults to false
	AgeMin          int    `json:"ageMin"`
	AgeMax          int    `json:"ageMax"`
}

// ApplyFiltersResponse defines the structure for the response.
type ApplyFiltersResponse struct {
	Success bool               `json:"success"`
	Message string             `json:"message"`
	Filters *migrations.Filter `json:"filters,omitempty"` // Return the saved filters
}

// ApplyFiltersHandler handles POST requests to save/update user feed filters.
func ApplyFiltersHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	if r.Method != http.MethodPost {
		utils.RespondWithJSON(w, http.StatusMethodNotAllowed, ApplyFiltersResponse{
			Success: false, Message: "Method Not Allowed: Use POST",
		})
		return
	}

	claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil || claims.UserID <= 0 {
		utils.RespondWithJSON(w, http.StatusUnauthorized, ApplyFiltersResponse{
			Success: false, Message: "Authentication required",
		})
		return
	}
	userID := int32(claims.UserID)

	var req ApplyFiltersRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("ApplyFiltersHandler: Error decoding request body for user %d: %v", userID, err)
		utils.RespondWithJSON(w, http.StatusBadRequest, ApplyFiltersResponse{
			Success: false, Message: fmt.Sprintf("Invalid request body format: %v", err),
		})
		return
	}
	defer r.Body.Close()

	// --- Validation ---
	var whoSee migrations.NullGenderEnum
	if req.WhoYouWantToSee == string(migrations.GenderEnumMan) || req.WhoYouWantToSee == string(migrations.GenderEnumWoman) {
		whoSee = migrations.NullGenderEnum{
			GenderEnum: migrations.GenderEnum(req.WhoYouWantToSee),
			Valid:      true,
		}
	} else if req.WhoYouWantToSee == "" {
		utils.RespondWithJSON(w, http.StatusBadRequest, ApplyFiltersResponse{
			Success: false, Message: "Validation Error: 'whoYouWantToSee' must be 'man' or 'woman'",
		})
		return
	} else {
		utils.RespondWithJSON(w, http.StatusBadRequest, ApplyFiltersResponse{
			Success: false, Message: "Validation Error: 'whoYouWantToSee' must be 'man' or 'woman'",
		})
		return
	}

	if req.RadiusKm <= 0 || req.RadiusKm > 500 { // Match DB constraint
		utils.RespondWithJSON(w, http.StatusBadRequest, ApplyFiltersResponse{
			Success: false, Message: "Validation Error: 'radius' must be between 1 and 500 km",
		})
		return
	}

	if req.AgeMin < 18 {
		utils.RespondWithJSON(w, http.StatusBadRequest, ApplyFiltersResponse{
			Success: false, Message: "Validation Error: 'ageMin' must be 18 or greater",
		})
		return
	}

	if req.AgeMax < 18 {
		utils.RespondWithJSON(w, http.StatusBadRequest, ApplyFiltersResponse{
			Success: false, Message: "Validation Error: 'ageMax' must be 18 or greater",
		})
		return
	}

	if req.AgeMax < req.AgeMin {
		utils.RespondWithJSON(w, http.StatusBadRequest, ApplyFiltersResponse{
			Success: false, Message: "Validation Error: 'ageMax' cannot be less than 'ageMin'",
		})
		return
	}

	activeTodayValue := false // Default value
	if req.ActiveToday != nil {
		activeTodayValue = *req.ActiveToday
	}
	// No need for: activeTodayParam := pgtype.Bool{Bool: activeTodayValue, Valid: true}

	// --- Prepare DB Parameters ---
	params := migrations.UpsertUserFiltersParams{
		UserID:          userID,
		WhoYouWantToSee: whoSee, // Use the validated NullGenderEnum
		RadiusKm:        pgtype.Int4{Int32: int32(req.RadiusKm), Valid: true},
		ActiveToday:     activeTodayValue, // <-- CORRECTED: Assign the bool value directly
		AgeMin:          pgtype.Int4{Int32: int32(req.AgeMin), Valid: true},
		AgeMax:          pgtype.Int4{Int32: int32(req.AgeMax), Valid: true},
	}

	// --- Execute Upsert Query ---
	log.Printf("ApplyFiltersHandler: Upserting filters for user %d", userID)
	updatedFilters, err := queries.UpsertUserFilters(ctx, params)
	if err != nil {
		log.Printf("ApplyFiltersHandler: Error upserting filters for user %d: %v", userID, err)
		// Consider more specific error handling for constraint violations if needed
		utils.RespondWithJSON(w, http.StatusInternalServerError, ApplyFiltersResponse{
			Success: false, Message: "Database error saving filters",
		})
		return
	}
	log.Printf("ApplyFiltersHandler: Filters successfully saved/updated for user %d", userID)

	// --- Respond ---
	utils.RespondWithJSON(w, http.StatusOK, ApplyFiltersResponse{
		Success: true,
		Message: "Filters applied successfully",
		Filters: &updatedFilters,
	})
}



================================================
File: pkg/handlers/getPendingVerification.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"log" // Import log package
	"net/http"
	"strings"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db" // Import db package
	// "github.com/jackc/pgx/v5/pgxpool" // No longer needed here
)

// var dbPool *pgxpool.Pool // REMOVED: Use db.GetDB() instead

type VerificationRequest struct {
	UserID          uint   `json:"user_id"`
	Name            string `json:"name"`
	ProfileImageURL string `json:"profile_image_url"` // Use first image from media_urls
	VerificationURL string `json:"verification_url"`
}

func GetPendingVerificationsHandler(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	fmt.Println("\n=== Starting Get Pending Verifications (sqlc) ===")
	defer fmt.Println("=== End Get Pending Verifications (sqlc) ===")

	// Get DB Queries object
	queries := db.GetDB()
	if queries == nil {
		// Use the existing respondError or create one specific to this handler
		log.Println("[Error] Database pool is not initialized in GetPendingVerificationsHandler")
		http.Error(w, "Internal server error: DB not configured", http.StatusInternalServerError) // Keep it simple for now
		return
	}

	if r.Method != http.MethodGet {
		// respondError(w, "Method not allowed", http.StatusMethodNotAllowed)
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed) // Keep it simple
		return
	}

	fmt.Println("[Database] Fetching pending verification users...")
	// Use the obtained queries object
	users, err := queries.GetPendingVerificationUsers(ctx, migrations.VerificationStatusPending)
	if err != nil {
		fmt.Printf("[Database Error] Failed to fetch pending users: %v\n", err)
		// respondError(w, "Failed to fetch verification requests", http.StatusInternalServerError)
		http.Error(w, "Failed to fetch verification requests", http.StatusInternalServerError) // Keep it simple
		return
	}
	fmt.Printf("[Database] Found %d users with pending verification status.\n", len(users))

	var verificationRequests []VerificationRequest
	for _, user := range users {
		// Ensure verification picture exists and is valid
		if !user.VerificationPic.Valid || user.VerificationPic.String == "" {
			fmt.Printf("[Filter] Skipping User ID %d: Missing or empty verification_pic\n", user.ID)
			continue
		}

		// Determine the first profile image URL safely
		var profileImageURL string
		if len(user.MediaUrls) > 0 && user.MediaUrls[0] != "" {
			profileImageURL = user.MediaUrls[0]
			// fmt.Printf("[Data] User ID %d: Profile Image URL: %s\n", user.ID, profileImageURL)
		} else {
			// fmt.Printf("[Data] User ID %d: No profile image URL found in media_urls\n", user.ID)
		}

		// Build name safely
		var nameBuilder strings.Builder
		if user.Name.Valid && user.Name.String != "" {
			nameBuilder.WriteString(user.Name.String)
		}
		if user.LastName.Valid && user.LastName.String != "" {
			if nameBuilder.Len() > 0 {
				nameBuilder.WriteString(" ") // Add space only if first name exists
			}
			nameBuilder.WriteString(user.LastName.String)
		}
		name := nameBuilder.String()
		// if name == "" {
		// 	fmt.Printf("[Data] User ID %d: Both name and last name are missing or empty.\n", user.ID)
		// }

		verificationRequests = append(verificationRequests, VerificationRequest{
			UserID:          uint(user.ID),
			Name:            name, // Will be empty if both name/lastname are null/empty
			ProfileImageURL: profileImageURL,
			VerificationURL: user.VerificationPic.String,
		})
		// fmt.Printf("[Result] Added verification request for User ID %d\n", user.ID)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	responsePayload := map[string]any{
		"success":               true,
		"verification_requests": verificationRequests,
		"count":                 len(verificationRequests),
	}
	err = json.NewEncoder(w).Encode(responsePayload)
	if err != nil {
		// Log the error, but the header/status is already sent
		fmt.Printf("[Error] Failed to encode response in GetPendingVerificationsHandler: %v\n", err)
	}
	fmt.Printf("[Success] Responded with %d verification requests.\n", len(verificationRequests))
}

// Note: The respondError function used in createprofile.go is not defined here.
// If needed, you can copy it or use http.Error directly as shown in the modified code above.



================================================
File: pkg/handlers/homeFeedHandler.go
================================================
package handlers

import (
	"errors"
	"log"
	"net/http"
	// "strconv" // No longer needed for page parsing
	"time"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/arnnvv/peeple-api/pkg/utils"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

// const defaultPageSize = 15 // Keep this for the LIMIT
const feedBatchSize = 15 // Renamed constant for clarity
const defaultAgeRange = 4
const minFilterAge = 18

// HomeFeedResponse defines the structure for the home feed response (no pagination).
type HomeFeedResponse struct {
	Success  bool                        `json:"success"`
	Message  string                      `json:"message,omitempty"`
	Profiles []migrations.GetHomeFeedRow `json:"profiles,omitempty"`
	// Page     int                         `json:"page,omitempty"` // REMOVED
	HasMore bool `json:"has_more"` // Indicates if more un-actioned profiles might exist
}

// GetHomeFeedHandler handles GET requests to retrieve the user's home feed.
// Fetches a batch of profiles excluding previously liked/disliked ones. No pagination params.
func GetHomeFeedHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	if r.Method != http.MethodGet {
		utils.RespondWithJSON(w, http.StatusMethodNotAllowed, HomeFeedResponse{
			Success: false, Message: "Method Not Allowed: Use GET",
		})
		return
	}

	claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil || claims.UserID <= 0 {
		utils.RespondWithJSON(w, http.StatusUnauthorized, HomeFeedResponse{
			Success: false, Message: "Authentication required",
		})
		return
	}
	requestingUserID := int32(claims.UserID)

	// --- Get Requesting User's necessary info (Location, Gender, DOB) ---
	requestingUser, err := queries.GetUserByID(ctx, requestingUserID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("GetHomeFeedHandler: Requesting user %d not found", requestingUserID)
			utils.RespondWithJSON(w, http.StatusNotFound, HomeFeedResponse{
				Success: false, Message: "Requesting user not found.",
			})
			return
		}
		log.Printf("GetHomeFeedHandler: Error fetching requesting user %d: %v", requestingUserID, err)
		utils.RespondWithJSON(w, http.StatusInternalServerError, HomeFeedResponse{
			Success: false, Message: "Error retrieving user data.",
		})
		return
	}

	// Check if user has location set (required for distance calc)
	if !requestingUser.Latitude.Valid || !requestingUser.Longitude.Valid {
		log.Printf("GetHomeFeedHandler: Requesting user %d missing location data.", requestingUserID)
		utils.RespondWithJSON(w, http.StatusBadRequest, HomeFeedResponse{
			Success: false, Message: "Please set your location in your profile to use the feed.",
		})
		return
	}

	// --- Check if user has filters set, create defaults if not ---
	_, err = queries.GetUserFilters(ctx, requestingUserID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			// Filters don't exist, create defaults
			log.Printf("GetHomeFeedHandler: No filters found for user %d. Creating defaults.", requestingUserID)

			// Calculate Default Filters (Logic remains the same)
			defaultWhoSee := migrations.NullGenderEnum{Valid: false}
			if requestingUser.Gender.Valid {
				if requestingUser.Gender.GenderEnum == migrations.GenderEnumMan {
					defaultWhoSee = migrations.NullGenderEnum{GenderEnum: migrations.GenderEnumWoman, Valid: true}
				} else if requestingUser.Gender.GenderEnum == migrations.GenderEnumWoman {
					defaultWhoSee = migrations.NullGenderEnum{GenderEnum: migrations.GenderEnumMan, Valid: true}
				}
			}
			defaultAgeMin := pgtype.Int4{Valid: false}
			defaultAgeMax := pgtype.Int4{Valid: false}
			if requestingUser.DateOfBirth.Valid && !requestingUser.DateOfBirth.Time.IsZero() {
				age := int(time.Since(requestingUser.DateOfBirth.Time).Hours() / 24 / 365.25)
				if age >= minFilterAge {
					calcAgeMin := age - defaultAgeRange
					if calcAgeMin < minFilterAge {
						calcAgeMin = minFilterAge
					}
					defaultAgeMin = pgtype.Int4{Int32: int32(calcAgeMin), Valid: true}

					calcAgeMax := age + defaultAgeRange
					if calcAgeMax < calcAgeMin {
						calcAgeMax = calcAgeMin
					}
					if calcAgeMax < minFilterAge {
						calcAgeMax = minFilterAge
					}
					defaultAgeMax = pgtype.Int4{Int32: int32(calcAgeMax), Valid: true}
				}
			}
			defaultParams := migrations.UpsertUserFiltersParams{
				UserID:          requestingUserID,
				WhoYouWantToSee: defaultWhoSee,
				AgeMin:          defaultAgeMin,
				AgeMax:          defaultAgeMax,
				ActiveToday:     false,
				RadiusKm:        pgtype.Int4{Valid: false},
			}

			// Insert the defaults
			_, upsertErr := queries.UpsertUserFilters(ctx, defaultParams)
			if upsertErr != nil {
				log.Printf("GetHomeFeedHandler: Failed to insert default filters for user %d: %v", requestingUserID, upsertErr)
				utils.RespondWithJSON(w, http.StatusInternalServerError, HomeFeedResponse{
					Success: false, Message: "Failed to initialize user filters.",
				})
				return
			}
			log.Printf("GetHomeFeedHandler: Default filters created successfully for user %d.", requestingUserID)

		} else {
			// Handle other potential errors fetching filters
			log.Printf("GetHomeFeedHandler: Error fetching filters for user %d: %v", requestingUserID, err)
			utils.RespondWithJSON(w, http.StatusInternalServerError, HomeFeedResponse{
				Success: false, Message: "Error retrieving user filters.",
			})
			return
		}
	}
	// Filters now exist (either pre-existing or default)

	// --- REMOVED Pagination Logic ---
	// pageStr := r.URL.Query().Get("page") ...
	// offset := (page - 1) * feedBatchSize

	// --- Execute Feed Query ---
	log.Printf("GetHomeFeedHandler: Fetching feed batch (limit %d) for user %d", feedBatchSize, requestingUserID)
	// The GetHomeFeedParams struct generated by sqlc should now only have ID and Limit
	feedParams := migrations.GetHomeFeedParams{
		ID:    requestingUserID,
		Limit: int32(feedBatchSize), // Use the batch size constant
		// Offset field removed from params struct by sqlc regenerate
	}

	profiles, err := queries.GetHomeFeed(ctx, feedParams)
	if err != nil && !errors.Is(err, pgx.ErrNoRows) {
		log.Printf("GetHomeFeedHandler: Database error fetching feed for user %d: %v", requestingUserID, err)
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) {
			log.Printf("DB Error Details: Code=%s, Message=%s", pgErr.Code, pgErr.Message)
			if pgErr.Code == "42883" {
				utils.RespondWithJSON(w, http.StatusInternalServerError, HomeFeedResponse{
					Success: false, Message: "Server configuration error (missing distance function).",
				})
				return
			}
		}
		utils.RespondWithJSON(w, http.StatusInternalServerError, HomeFeedResponse{
			Success: false, Message: "Error retrieving home feed.",
		})
		return
	}

	if profiles == nil {
		profiles = []migrations.GetHomeFeedRow{}
	}
	log.Printf("GetHomeFeedHandler: Found %d profiles for user %d", len(profiles), requestingUserID)

	// --- Determine if more pages exist (still relevant) ---
	// If we got exactly the batch size, assume there might be more un-actioned profiles available.
	hasMore := len(profiles) == feedBatchSize

	// --- Respond ---
	utils.RespondWithJSON(w, http.StatusOK, HomeFeedResponse{
		Success:  true,
		Profiles: profiles,
		// Page:     page, // REMOVED
		HasMore: hasMore,
	})
}



================================================
File: pkg/handlers/imagehandler.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/jackc/pgx/v5"
)

type FileRequest struct {
	Filename string `json:"filename"`
	Type     string `json:"type"`
}

type UploadURL struct {
	Filename string `json:"filename"`
	Type     string `json:"type"`
	URL      string `json:"url"`
}

var allowedMimeTypes = map[string]bool{
	"image/jpeg":      true,
	"image/png":       true,
	"image/gif":       true,
	"image/webp":      true,
	"image/tiff":      true,
	"image/svg+xml":   true,
	"video/mp4":       true,
	"video/mpeg":      true,
	"video/ogg":       true,
	"video/webm":      true,
	"video/x-msvideo": true,
	"video/quicktime": true,
}

func isAllowedFileType(mimeType string) bool {
	return allowedMimeTypes[strings.ToLower(mimeType)]
}

func GeneratePresignedURLs(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	claims, ok := r.Context().Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil {
		http.Error(w, "Invalid authentication", http.StatusUnauthorized)
		return
	}

	userID := int32(claims.UserID)
	ctx := r.Context()

	queries := db.GetDB()

	_, err := queries.GetUserByID(ctx, userID)
	if err != nil {
		if err == pgx.ErrNoRows {
			http.Error(w, "User not found", http.StatusNotFound)
		} else {
			http.Error(w, fmt.Sprintf("Failed to retrieve user: %v", err), http.StatusInternalServerError)
		}
		return
	}

	err = queries.ClearUserMediaURLs(ctx, userID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to clear existing media URLs: %v", err), http.StatusInternalServerError)
		return
	}

	awsRegion := os.Getenv("AWS_REGION")
	awsAccessKey := os.Getenv("AWS_ACCESS_KEY_ID")
	awsSecretKey := os.Getenv("AWS_SECRET_ACCESS_KEY")
	s3Bucket := os.Getenv("S3_BUCKET")

	if awsRegion == "" || awsAccessKey == "" || awsSecretKey == "" || s3Bucket == "" {
		http.Error(w, "Missing AWS configuration", http.StatusInternalServerError)
		return
	}

	var requestBody struct {
		Files []FileRequest `json:"files"`
	}

	err = json.NewDecoder(r.Body).Decode(&requestBody)
	if err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	fileCount := len(requestBody.Files)
	if fileCount < 3 {
		http.Error(w, "Requires minimum 3 files", http.StatusBadRequest)
		return
	}
	if fileCount > 6 {
		http.Error(w, "Requires maximum 6 files", http.StatusBadRequest)
		return
	}

	sess := session.Must(session.NewSession(&aws.Config{
		Region:      aws.String(awsRegion),
		Credentials: credentials.NewStaticCredentials(awsAccessKey, awsSecretKey, ""),
	}))
	svc := s3.New(sess)
	var uploadURLs []UploadURL
	var permanentURLs []string
	datePrefix := time.Now().Format("2006-01-02")

	for _, file := range requestBody.Files {
		if file.Filename == "" || file.Type == "" {
			http.Error(w, "Filename and type are required for all files", http.StatusBadRequest)
			return
		}

		if !isAllowedFileType(file.Type) {
			http.Error(w, fmt.Sprintf("File type %s is not allowed", file.Type), http.StatusBadRequest)
			return
		}

		key := fmt.Sprintf("uploads/%s/%s", datePrefix, file.Filename)

		req, _ := svc.PutObjectRequest(&s3.PutObjectInput{
			Bucket:      aws.String(s3Bucket),
			Key:         aws.String(key),
			ContentType: aws.String(file.Type),
		})

		url, err := req.Presign(15 * time.Minute)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to generate URL for %s: %v", file.Filename, err), http.StatusInternalServerError)
			return
		}

		uploadURLs = append(uploadURLs, UploadURL{
			Filename: file.Filename,
			Type:     file.Type,
			URL:      url,
		})

		publicURL := fmt.Sprintf("https://%s.s3.%s.amazonaws.com/%s", s3Bucket, awsRegion, key)
		permanentURLs = append(permanentURLs, publicURL)
	}

	updateParams := migrations.UpdateUserMediaURLsParams{
		MediaUrls: permanentURLs,
		ID:        userID,
	}
	err = queries.UpdateUserMediaURLs(ctx, updateParams)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to store media URLs in database: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string][]UploadURL{
		"uploads": uploadURLs,
	})
}



================================================
File: pkg/handlers/newuser.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"unicode"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/jackc/pgx/v5"
)

type createUserRequest struct {
	PhoneNumber string `json:"phoneNumber"`
	Gender      string `json:"gender"` // Expect "man", "woman", "gay", "lesbian", "bisexual"
}

type CreateUserResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

func isValidGender(gender string) bool {
	switch migrations.GenderEnum(gender) {
	case migrations.GenderEnumMan,
		migrations.GenderEnumWoman,
		migrations.GenderEnumGay,
		migrations.GenderEnumLesbian,
		migrations.GenderEnumBisexual:
		return true
	default:
		return false
	}
}

func CreateNewUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Only POST method allowed",
		})
		return
	}

	var req createUserRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Invalid request body",
		})
		return
	}

	if req.PhoneNumber == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Phone number is required",
		})
		return
	}

	if len(req.PhoneNumber) != 10 {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Phone number must be exactly 10 digits",
		})
		return
	}

	for _, c := range req.PhoneNumber {
		if !unicode.IsDigit(c) {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(CreateUserResponse{
				Success: false,
				Message: "Phone number must contain only digits",
			})
			return
		}
	}

	if req.Gender == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Gender is required",
		})
		return
	}

	if !isValidGender(req.Gender) {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: fmt.Sprintf("Invalid gender provided. Allowed values: %s, %s, %s, %s, %s",
				migrations.GenderEnumMan, migrations.GenderEnumWoman, migrations.GenderEnumGay, migrations.GenderEnumLesbian, migrations.GenderEnumBisexual),
		})
		return
	}

	_, err := queries.GetUserByPhone(ctx, req.PhoneNumber)
	if err == nil {
		w.WriteHeader(http.StatusConflict)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Phone number already exists",
		})
		return
	} else if err != pgx.ErrNoRows {
		// An unexpected database error occurred during lookup
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Database error checking user existence",
		})
		return
	}
	// If err is pgx.ErrNoRows, proceed to create user

	params := migrations.CreateUserMinimalParams{
		PhoneNumber: req.PhoneNumber,
		Gender:      migrations.NullGenderEnum{GenderEnum: migrations.GenderEnum(req.Gender), Valid: true},
	}

	_, createErr := queries.CreateUserMinimal(ctx, params)
	if createErr != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(CreateUserResponse{
			Success: false,
			Message: "Error creating user in database",
		})
		return
	}

	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(CreateUserResponse{
		Success: true,
		Message: "User created successfully",
	})
}



================================================
File: pkg/handlers/profileHandler.go
================================================
package handlers

import (
	"encoding/json"
	"log"
	"net/http"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/jackc/pgx/v5"
)

type UserProfileData struct {
	migrations.User
	DateVibesPrompts       []migrations.DateVibesPrompt       `json:"dateVibesPrompts,omitempty"`
	GettingPersonalPrompts []migrations.GettingPersonalPrompt `json:"gettingPersonalPrompts,omitempty"`
	MyTypePrompts          []migrations.MyTypePrompt          `json:"myTypePrompts,omitempty"`
	StoryTimePrompts       []migrations.StoryTimePrompt       `json:"storyTimePrompts,omitempty"`
	// AudioPrompt is already included in migrations.User (AudioPromptQuestion, AudioPromptAnswer)
}

type ProfileResponse struct {
	Success bool             `json:"success"`
	User    *UserProfileData `json:"user,omitempty"`
	Error   string           `json:"error,omitempty"`
}

func ProfileHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	resp := ProfileResponse{}
	ctx := r.Context()
	queries := db.GetDB()

	claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil {
		w.WriteHeader(http.StatusUnauthorized)
		json.NewEncoder(w).Encode(ProfileResponse{Success: false, Error: "Unauthorized"})
		return
	}
	userID := int32(claims.UserID)

	user, err := queries.GetUserByID(ctx, userID)
	if err != nil {
		if err == pgx.ErrNoRows {
			resp.Success = false
			resp.Error = "User not found"
			w.WriteHeader(http.StatusNotFound)
		} else {
			resp.Success = false
			resp.Error = "Database error fetching user data"
			w.WriteHeader(http.StatusInternalServerError)
		}
		json.NewEncoder(w).Encode(resp)
		return
	}

	var profileData UserProfileData
	profileData.User = user

	dateVibesPrompts, err := queries.GetUserDateVibesPrompts(ctx, userID)
	if err != nil && err != pgx.ErrNoRows {
		log.Printf("Error fetching DateVibes prompts for user %d: %v", userID, err)
	}
	profileData.DateVibesPrompts = dateVibesPrompts

	gettingPersonalPrompts, err := queries.GetUserGettingPersonalPrompts(ctx, userID)
	if err != nil && err != pgx.ErrNoRows {
		log.Printf("Error fetching GettingPersonal prompts for user %d: %v", userID, err)
	}
	profileData.GettingPersonalPrompts = gettingPersonalPrompts

	myTypePrompts, err := queries.GetUserMyTypePrompts(ctx, userID)
	if err != nil && err != pgx.ErrNoRows {
		log.Printf("Error fetching MyType prompts for user %d: %v", userID, err)
	}
	profileData.MyTypePrompts = myTypePrompts

	storyTimePrompts, err := queries.GetUserStoryTimePrompts(ctx, userID)
	if err != nil && err != pgx.ErrNoRows {
		log.Printf("Error fetching StoryTime prompts for user %d: %v", userID, err)
	}
	profileData.StoryTimePrompts = storyTimePrompts

	resp.Success = true
	resp.User = &profileData
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(resp)
}



================================================
File: pkg/handlers/protectedHandler.go
================================================
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/arnnvv/peeple-api/pkg/token"
)

func ProtectedHandler(w http.ResponseWriter, r *http.Request) {
	claims, ok := r.Context().Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{
			"error": "Failed to retrieve token claims",
		})
		return
	}

	response := map[string]any{
		"user_id": claims.UserID,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}



================================================
File: pkg/handlers/sendotp.go
================================================
package handlers

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"runtime/debug"
	"time"
	"unicode"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/utils"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type SendOTPRequest struct {
	PhoneNumber string `json:"phoneNumber"`
}

type SendOTPResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

func SendOTP(w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()
	log.Printf("[DEBUG] Handler started: method=%s, path=%s", r.Method, r.URL.Path)
	defer func() {
		log.Printf("[DEBUG] Handler completed in %v", time.Since(startTime))
	}()

	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	log.Printf("[DEBUG] Method check: received method=%s", r.Method)
	if r.Method != http.MethodPost {
		log.Printf("[WARN] Invalid method attempted: method=%s", r.Method)
		utils.RespondWithJSON(w, http.StatusMethodNotAllowed, SendOTPResponse{
			Success: false,
			Message: "Only POST method allowed",
		})
		return
	}

	var req SendOTPRequest
	log.Printf("[DEBUG] Decoding request body for phone number")
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		log.Printf("[ERROR] JSON decode failed: error=%v, stack=%s", err, debug.Stack())
		utils.RespondWithJSON(w, http.StatusBadRequest, SendOTPResponse{
			Success: false,
			Message: "Invalid request body",
		})
		return
	}
	log.Printf("[DEBUG] Request decoded successfully: phone=%s", req.PhoneNumber)

	log.Printf("[DEBUG] Validating phone number: %s", req.PhoneNumber)
	if err := validatePhoneNumber(req.PhoneNumber); err != nil {
		log.Printf("[VALIDATION ERROR] Phone validation failed: phone=%s, error=%v", req.PhoneNumber, err)
		utils.RespondWithJSON(w, http.StatusBadRequest, SendOTPResponse{
			Success: false,
			Message: err.Error(),
		})
		return
	}
	log.Printf("[DEBUG] Phone number validation passed")

	log.Printf("[DEBUG] Starting user lookup: phone=%s", req.PhoneNumber)
	user, err := queries.GetUserByPhone(ctx, req.PhoneNumber)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			log.Printf("[INFO] User not found, creating new user: phone=%s", req.PhoneNumber)
			newUser, err := queries.AddPhoneNumberInUsers(ctx, req.PhoneNumber)

			if err != nil {
				log.Printf("[CRITICAL] User creation failed: phone=%s, error=%v, stack=%s",
					req.PhoneNumber, err, debug.Stack())

				var pgErr *pgconn.PgError
				if errors.As(err, &pgErr) {
					log.Printf("[DB ERROR] PostgreSQL error: code=%s, message=%s, detail=%s",
						pgErr.Code, pgErr.Message, pgErr.Detail)
				}

				utils.RespondWithJSON(w, http.StatusInternalServerError, SendOTPResponse{
					Success: false,
					Message: "Failed to create user account",
				})
				return
			}

			log.Printf("[INFO] New user created: user_id=%d, phone=%s", newUser.ID, newUser.PhoneNumber)
			user = newUser
		} else {
			log.Printf("[DATABASE ERROR] User lookup failed: phone=%s, error_type=%T, error=%v, stack=%s",
				req.PhoneNumber, err, err, debug.Stack())

			var pgErr *pgconn.PgError
			if errors.As(err, &pgErr) {
				log.Printf("[DB DETAIL] PostgreSQL error: code=%s, message=%s, query=%s, hint=%s",
					pgErr.Code, pgErr.Message, pgErr.Where, pgErr.Hint)
			}

			utils.RespondWithJSON(w, http.StatusInternalServerError, SendOTPResponse{
				Success: false,
				Message: "Database error checking user",
			})
			return
		}
	} else {
		log.Printf("[DEBUG] Existing user found: user_id=%d", user.ID)
	}

	log.Printf("[DEBUG] Deleting existing OTPs for user: user_id=%d", user.ID)
	if err := queries.DeleteOTPByUser(ctx, user.ID); err != nil {
		log.Printf("[WARN] OTP cleanup failed: user_id=%d, error=%v", user.ID, err)
	}

	otpCode := generateOTP()
	log.Printf("[DEBUG] Generated OTP: code=%s (THIS SHOULD BE REMOVED IN PRODUCTION)", otpCode)

	log.Printf("[DEBUG] Storing new OTP: user_id=%d", user.ID)
	otpParams := migrations.CreateOTPParams{
		UserID:  user.ID,
		OtpCode: otpCode,
	}

	_, err = queries.CreateOTP(ctx, otpParams)
	if err != nil {
		log.Printf("[CRITICAL] OTP creation failed: user_id=%d, error=%v, stack=%s",
			user.ID, err, debug.Stack())

		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) {
			log.Printf("[DB ERROR] PostgreSQL error during OTP creation: code=%s, detail=%s",
				pgErr.Code, pgErr.Detail)
		}

		utils.RespondWithJSON(w, http.StatusInternalServerError, SendOTPResponse{
			Success: false,
			Message: "Failed to store OTP",
		})
		return
	}
	log.Printf("[INFO] OTP stored successfully: user_id=%d", user.ID)

	log.Printf("[DEBUG] Initiating SMS delivery: phone=%s", req.PhoneNumber)
	sendOTPViaSMS(req.PhoneNumber, otpCode)
	log.Printf("[INFO] SMS delivery simulated: phone=%s", req.PhoneNumber)

	log.Printf("[SUCCESS] OTP process completed: phone=%s, user_id=%d", req.PhoneNumber, user.ID)
	utils.RespondWithJSON(w, http.StatusOK, SendOTPResponse{
		Success: true,
		Message: "OTP sent successfully",
	})
}

func validatePhoneNumber(phoneNumber string) error {
	log.Printf("[DEBUG] Validating phone number structure: %s", phoneNumber)

	if phoneNumber == "" {
		return fmt.Errorf("phone number is required")
	}

	if len(phoneNumber) != 10 {
		return fmt.Errorf("phone number must be exactly 10 digits")
	}

	for _, c := range phoneNumber {
		if !unicode.IsDigit(c) {
			return fmt.Errorf("phone number must contain only digits")
		}
	}

	return nil
}

func generateOTP() string {
	return fmt.Sprintf("%06d", rand.Intn(1000000))
}

func sendOTPViaSMS(phoneNumber, otpCode string) {
	fmt.Printf("Sending OTP %s to %s\n", otpCode, phoneNumber)
}



================================================
File: pkg/handlers/testHandler.go
================================================
package handlers

import (
	"net/http"
)

func TestHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("testing"))
}



================================================
File: pkg/handlers/updateVerificationStatus.go
================================================
package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/jackc/pgx/v5"
)

type VerificationActionRequest struct {
	UserID  int32 `json:"user_id"`
	Approve bool  `json:"approve"`
}

func UpdateVerificationStatusHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	// claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	// if !ok || claims == nil || claims.Role != string(migrations.UserRoleAdmin) {
	// 	http.Error(w, "Forbidden: Admin privileges required", http.StatusForbidden)
	// 	return
	// }

	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req VerificationActionRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if req.UserID <= 0 {
		http.Error(w, "valid user_id is required", http.StatusBadRequest)
		return
	}

	user, err := queries.GetUserByID(ctx, req.UserID)
	if err != nil {
		if err == pgx.ErrNoRows {
			http.Error(w, fmt.Sprintf("User not found with ID: %d", req.UserID), http.StatusNotFound)
		} else {
			http.Error(w, "Database error fetching user", http.StatusInternalServerError)
		}
		return
	}

	if user.VerificationStatus != migrations.VerificationStatusPending {
		http.Error(w, "User does not have a pending verification request", http.StatusBadRequest)
		return
	}

	var newStatus migrations.VerificationStatus
	if req.Approve {
		newStatus = migrations.VerificationStatusTrue
	} else {
		newStatus = migrations.VerificationStatusFalse
	}

	updateParams := migrations.UpdateUserVerificationStatusParams{
		ID:                 req.UserID,
		VerificationStatus: newStatus,
	}

	_, err = queries.UpdateUserVerificationStatus(ctx, updateParams)
	if err != nil {
		http.Error(w, "Failed to update verification status in database", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]any{
		"success": true,
		"message": "Verification status updated successfully",
		"user_id": req.UserID,
		"status":  string(newStatus),
	})
}



================================================
File: pkg/handlers/verifyProfileHandler.go
================================================
package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/credentials"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

func GenerateVerificationPresignedURL(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	authHeader := r.Header.Get("Authorization")
	targetURL := os.Getenv("TARGET_URL")

	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	claims, ok := ctx.Value(token.ClaimsContextKey).(*token.Claims)
	if !ok || claims == nil {
		http.Error(w, "Invalid authentication", http.StatusUnauthorized)
		return
	}
	userID := int32(claims.UserID)

	_, err := queries.GetUserByID(ctx, userID)
	if err != nil {
		if err == pgx.ErrNoRows {
			http.Error(w, "User not found", http.StatusNotFound)
		} else {
			http.Error(w, "Database error checking user", http.StatusInternalServerError)
		}
		return
	}

	awsRegion := os.Getenv("AWS_REGION")
	awsAccessKey := os.Getenv("AWS_ACCESS_KEY_ID")
	awsSecretKey := os.Getenv("AWS_SECRET_ACCESS_KEY")
	s3Bucket := os.Getenv("S3_BUCKET")
	if awsRegion == "" || awsAccessKey == "" || awsSecretKey == "" || s3Bucket == "" {
		log.Println("Missing AWS configuration")
		http.Error(w, "Missing server configuration", http.StatusInternalServerError)
		return
	}

	var fileReq FileRequest
	if err := json.NewDecoder(r.Body).Decode(&fileReq); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if fileReq.Filename == "" || fileReq.Type == "" {
		http.Error(w, "Filename and type are required", http.StatusBadRequest)
		return
	}
	if !isImageType(fileReq.Type) {
		http.Error(w, "Only image file types are allowed for verification", http.StatusBadRequest)
		return
	}

	timestamp := time.Now().Format("20060102-150405")
	key := fmt.Sprintf("verification/%d/%s-%s",
		userID,
		timestamp,
		sanitizeFilename(fileReq.Filename))

	sess := session.Must(session.NewSession(&aws.Config{
		Region:      aws.String(awsRegion),
		Credentials: credentials.NewStaticCredentials(awsAccessKey, awsSecretKey, ""),
	}))
	svc := s3.New(sess)

	req, _ := svc.PutObjectRequest(&s3.PutObjectInput{
		Bucket:      aws.String(s3Bucket),
		Key:         aws.String(key),
		ContentType: aws.String(fileReq.Type),
		// ACL: aws.String("public-read"), // If the final URL needs to be public directly
	})

	presignedURL, err := req.Presign(15 * time.Minute)
	if err != nil {
		http.Error(w, "Failed to generate upload URL", http.StatusInternalServerError)
		return
	}

	publicURL := fmt.Sprintf("https://%s.s3.%s.amazonaws.com/%s", s3Bucket, awsRegion, key)

	updateParams := migrations.UpdateUserVerificationDetailsParams{
		ID: userID,
		VerificationPic: pgtype.Text{
			String: publicURL,
			Valid:  true,
		},
		VerificationStatus: migrations.VerificationStatusPending,
	}

	_, err = queries.UpdateUserVerificationDetails(ctx, updateParams)
	if err != nil {
		log.Printf("Failed to store verification URL for user %d: %v", userID, err)
		http.Error(w, "Failed to update verification details in database", http.StatusInternalServerError)
		return
	}

	if targetURL != "" {
		go func() {
			webhookReq, err := http.NewRequestWithContext(context.Background(), http.MethodGet, targetURL, nil)
			if err != nil {
				fmt.Printf("Error creating webhook request: %v\n", err)
				return
			}
			webhookReq.Header.Set("Authorization", authHeader)
			// webhookReq.Header.Set("X-User-ID", fmt.Sprintf("%d", userID))
			// webhookReq.Header.Set("X-Event-Type", "verification_pending")

			client := &http.Client{Timeout: 15 * time.Second}
			resp, err := client.Do(webhookReq)
			if err != nil {
				fmt.Printf("Error sending verification webhook for user %d: %v\n", userID, err)
			} else {
				defer resp.Body.Close()
				if resp.StatusCode < 200 || resp.StatusCode >= 300 {
					fmt.Printf("Webhook for user %d returned non-2xx status: %d\n", userID, resp.StatusCode)
					// bodyBytes, _ := io.ReadAll(resp.Body)
					// fmt.Printf("Webhook response body: %s\n", string(bodyBytes))
				} else {
					fmt.Printf("Webhook notification sent successfully for user %d.\n", userID)
				}
			}
		}()
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{
		"upload_url": presignedURL,
	})
}

func sanitizeFilename(filename string) string {
	name := filepath.Base(filename)
	name = strings.ReplaceAll(name, " ", "_")
	return name
}

func isImageType(mimeType string) bool {
	imageTypes := map[string]bool{
		"image/jpeg":    true,
		"image/png":     true,
		"image/gif":     true,
		"image/webp":    true,
		"image/tiff":    true,
		"image/svg+xml": true,
	}
	return imageTypes[strings.ToLower(mimeType)]
}



================================================
File: pkg/handlers/verifyotp.go
================================================
package handlers

import (
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/arnnvv/peeple-api/pkg/token"
	"github.com/arnnvv/peeple-api/pkg/utils"
	"github.com/jackc/pgx/v5"
)

type VerifyOTPRequest struct {
	PhoneNumber string `json:"phoneNumber"`
	OTPCode     string `json:"otpCode"`
}

type VerifyOTPResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
	Token   string `json:"token,omitempty"`
}

func VerifyOTP(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	queries := db.GetDB()

	if r.Method != http.MethodPost {
		utils.RespondWithJSON(w, http.StatusMethodNotAllowed, VerifyOTPResponse{
			Success: false,
			Message: "Only POST method allowed",
		})
		return
	}

	var req VerifyOTPRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		utils.RespondWithJSON(w, http.StatusBadRequest, VerifyOTPResponse{
			Success: false,
			Message: "Invalid request body",
		})
		return
	}

	if err := validatePhoneNumber(req.PhoneNumber); err != nil {
		utils.RespondWithJSON(w, http.StatusBadRequest, VerifyOTPResponse{
			Success: false,
			Message: err.Error(),
		})
		return
	}

	if req.OTPCode == "" {
		utils.RespondWithJSON(w, http.StatusBadRequest, VerifyOTPResponse{
			Success: false,
			Message: "OTP code is required",
		})
		return
	}

	user, err := queries.GetUserByPhone(ctx, req.PhoneNumber)
	if err != nil {
		if err == pgx.ErrNoRows {
			utils.RespondWithJSON(w, http.StatusUnauthorized, VerifyOTPResponse{
				Success: false,
				Message: "User not found or invalid phone number.",
			})
		} else {
			log.Printf("Error finding user by phone %s during OTP verify: %v", req.PhoneNumber, err)
			utils.RespondWithJSON(w, http.StatusInternalServerError, VerifyOTPResponse{
				Success: false,
				Message: "Database error verifying user",
			})
		}
		return
	}
	userID := user.ID // user's ID (int32)

	storedOtp, err := queries.GetOTPByUser(ctx, userID)
	if err != nil {
		if err == pgx.ErrNoRows {
			utils.RespondWithJSON(w, http.StatusUnauthorized, VerifyOTPResponse{
				Success: false,
				Message: "Invalid or expired OTP.",
			})
		} else {
			log.Printf("Error fetching OTP for user %d: %v", userID, err)
			utils.RespondWithJSON(w, http.StatusInternalServerError, VerifyOTPResponse{
				Success: false,
				Message: "Database error fetching OTP",
			})
		}
		return
	}

	if storedOtp.OtpCode != req.OTPCode {
		utils.RespondWithJSON(w, http.StatusUnauthorized, VerifyOTPResponse{
			Success: false,
			Message: "Invalid or expired OTP.",
		})
		return
	}

	if !storedOtp.ExpiresAt.Valid || time.Now().After(storedOtp.ExpiresAt.Time) {
		_ = queries.DeleteOTPByID(ctx, storedOtp.ID)
		utils.RespondWithJSON(w, http.StatusUnauthorized, VerifyOTPResponse{
			Success: false,
			Message: "Invalid or expired OTP.",
		})
		return
	}

	err = queries.DeleteOTPByID(ctx, storedOtp.ID)
	if err != nil {
		log.Printf("Warning: Failed to delete OTP ID %d for user %d after successful verification: %v", storedOtp.ID, userID, err)
	}

	tokenString, err := token.GenerateToken(userID)
	if err != nil {
		log.Printf("Failed to generate token for user %d: %v", userID, err)
		utils.RespondWithJSON(w, http.StatusInternalServerError, VerifyOTPResponse{
			Success: false,
			Message: "Failed to generate authentication token",
		})
		return
	}

	utils.RespondWithJSON(w, http.StatusOK, VerifyOTPResponse{
		Success: true,
		Message: "OTP verified successfully",
		Token:   tokenString,
	})
}



================================================
File: pkg/token/adminAuthMiddleware.go
================================================
package token

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"log"
	"net/http"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
)

var (
	errAdminRequired = ErrorResponse{
		Success: false,
		Message: "Admin access required",
	}
	errUserNotFound = ErrorResponse{
		Success: false,
		Message: "User associated with token not found",
	}
	errInternalServer = ErrorResponse{
		Success: false,
		Message: "Internal server error",
	}
)

func AdminAuthMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return AuthMiddleware(func(w http.ResponseWriter, r *http.Request) {
		claims, ok := r.Context().Value(ClaimsContextKey).(*Claims)
		if !ok || claims == nil {
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(errInvalidToken)
			return
		}

		q := db.GetDB()

		var user migrations.User
		var err error

		user, err = q.GetUserByID(context.Background(), int32(claims.UserID))
		if err != nil {
			w.Header().Set("Content-Type", "application/json")
			if errors.Is(err, sql.ErrNoRows) {
				w.WriteHeader(http.StatusNotFound)
				json.NewEncoder(w).Encode(errUserNotFound)
			} else {
				log.Printf("AdminAuthMiddleware: Error fetching user %d: %v\n", claims.UserID, err)
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(errInternalServer)
			}
			return
		}

		if user.Role != migrations.UserRoleAdmin {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusForbidden)
			json.NewEncoder(w).Encode(errAdminRequired)
			return
		}

		next.ServeHTTP(w, r)
	})
}



================================================
File: pkg/token/claims.go
================================================
package token

import (
	"github.com/golang-jwt/jwt/v5"
)

type Claims struct {
	UserID uint `json:"user_id"`
	jwt.RegisteredClaims
}

func (c *Claims) Valid() error {
	return nil
}



================================================
File: pkg/token/generate.go
================================================
package token

import (
	"database/sql"
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"os"
	"sync"
	"unicode"

	"github.com/arnnvv/peeple-api/migrations"
	"github.com/arnnvv/peeple-api/pkg/db"
	"github.com/golang-jwt/jwt/v5"
)

type TokenResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

var (
	jwtSecret     []byte
	jwtSecretOnce sync.Once
)

func getSecret() []byte {
	jwtSecretOnce.Do(func() {
		jwtSecret = []byte(os.Getenv("JWT_SECRET"))
	})
	return jwtSecret
}

func GenerateToken(userID int32) (string, error) {
	// may add expiration time to claims when needed
	claims := &Claims{
		UserID: uint(userID),
		// RegisteredClaims: jwt.RegisteredClaims{
		//  ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)), // Example: 24h expiry
		//  IssuedAt:  jwt.NewNumericDate(time.Now()),
		//  NotBefore: jwt.NewNumericDate(time.Now()),
		// },
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err := token.SignedString(getSecret())
	if err != nil {
		return "", err
	}

	return tokenString, nil
}

func GenerateTokenHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if r.Method != http.MethodGet {
		w.WriteHeader(http.StatusMethodNotAllowed)
		json.NewEncoder(w).Encode(TokenResponse{
			Success: false,
			Message: "Only GET method allowed",
		})
		return
	}

	phone := r.URL.Query().Get("phone")
	if phone == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(TokenResponse{
			Success: false,
			Message: "Phone number is required",
		})
		return
	}

	if len(phone) != 10 {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(TokenResponse{
			Success: false,
			Message: "Phone number must be exactly 10 digits",
		})
		return
	}

	for _, c := range phone {
		if !unicode.IsDigit(c) {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(TokenResponse{
				Success: false,
				Message: "Phone number must contain only digits",
			})
			return
		}
	}

	queries := db.GetDB()

	var user migrations.User
	var err error

	user, err = queries.GetUserByPhone(r.Context(), phone)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			// User not found for the given phone number
			w.WriteHeader(http.StatusNotFound)
			json.NewEncoder(w).Encode(ErrorResponse{
				Success: false,
				Message: "User with the provided phone number not found",
			})
		} else {
			log.Printf("GenerateTokenHandler: Error fetching user by phone %s: %v\n", phone, err)
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(ErrorResponse{
				Success: false,
				Message: "Internal server error while retrieving user data",
			})
		}
		return
	}

	token, err := GenerateToken(user.ID)

	if err != nil {
		log.Printf("GenerateTokenHandler: Error generating token for user %d: %v\n", user.ID, err)
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(ErrorResponse{
			Success: false,
			Message: "Failed to generate authentication token",
		})
		return
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(TokenResponse{
		Success: true,
		Message: token,
	})
}



================================================
File: pkg/token/keys.go
================================================
package token

type contextKey string

const (
	ClaimsContextKey contextKey = "claims"
)



================================================
File: pkg/token/middleware.go
================================================
package token

import (
	"context"
	"encoding/json"
	"net/http"
	"strings"

	"github.com/golang-jwt/jwt/v5"
)

type ErrorResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

var (
	errInvalidHeader = ErrorResponse{
		Success: false,
		Message: "Invalid Authorization header format",
	}
	errInvalidToken = ErrorResponse{
		Success: false,
		Message: "Invalid token",
	}
)

func AuthMiddleware(next http.HandlerFunc) http.HandlerFunc {
	parser := jwt.NewParser(
		jwt.WithoutClaimsValidation(),
		jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Alg()}),
	)
	secret := getSecret()

	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		authHeader := r.Header.Get("Authorization")
		prefix, tokenString, ok := strings.Cut(authHeader, " ")
		if !ok || !strings.EqualFold(prefix, "Bearer") {
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(errInvalidHeader)
			return
		}

		claims := &Claims{}
		token, err := parser.ParseWithClaims(tokenString, claims, func(t *jwt.Token) (any, error) {
			return secret, nil
		})

		if err != nil || !token.Valid {
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(errInvalidToken)
			return
		}

		if claims.UserID == 0 {
			w.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(w).Encode(errInvalidToken)
			return
		}

		ctx := context.WithValue(r.Context(), ClaimsContextKey, claims)
		next.ServeHTTP(w, r.WithContext(ctx))
	}
}



================================================
File: pkg/utils/utils.go
================================================
package utils

import (
	"encoding/json"
	"net/http"
)

func RespondWithJSON(w http.ResponseWriter, code int, payload any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(payload)
}



================================================
File: .github/workflows/deploy.yml
================================================
name: Deploy

on:
  push:
    branches: [master]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Podman
        run: |
          sudo apt-get update
          sudo apt-get install -y podman

      - name: Log in to GHCR
        run: |
          echo "${{ secrets.GHCR_TOKEN }}" | podman login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build and push image
        run: |
          IMAGE_TAG="ghcr.io/${{ github.repository }}:${{ github.sha }}"
          LATEST_TAG="ghcr.io/${{ github.repository }}:latest"

          echo "Building image: ${IMAGE_TAG}"
          podman build -t ${IMAGE_TAG} -t ${LATEST_TAG} .

          echo "Pushing image: ${IMAGE_TAG}"
          podman push ${IMAGE_TAG}

          echo "Pushing image: ${LATEST_TAG}"
          podman push ${LATEST_TAG}

      - name: Setup SSH key
        env:
          VM_SSH_KEY: ${{ secrets.VM_SSH_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "${VM_SSH_KEY}" | tr -d '\r' > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          ssh-keygen -y -f ~/.ssh/ec2_key > /dev/null || (echo "Invalid private key format provided in VM_SSH_KEY secret" && exit 1)

      - name: Deploy to VM
        env:
          VM_HOST: ${{ secrets.VM_HOST }}
          VM_USER: ${{ secrets.VM_USER }}
          ENV_FILE_CONTENTS: ${{ secrets.ENV_FILE_CONTENTS }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          IMAGE_NAME: "ghcr.io/${{ github.repository }}:latest"
          CONTAINER_NAME: "${{ github.event.repository.name }}_container"
        run: |
          echo "Connecting to ${VM_USER}@${VM_HOST}..."
          ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${VM_USER}@${VM_HOST} /bin/bash <<EOF
            set -e

            echo "--> Setting up environment on VM..."
            CONFIG_DIR="\$HOME/.config/${CONTAINER_NAME}"
            SYSTEMD_USER_DIR="\$HOME/.config/systemd/user"
            ENV_FILE_PATH="\${CONFIG_DIR}/.env"

            mkdir -p "\${CONFIG_DIR}"
            mkdir -p "\${SYSTEMD_USER_DIR}"

            echo "${ENV_FILE_CONTENTS}" > "\${ENV_FILE_PATH}"

            echo "--> Verifying env file exists at: \${ENV_FILE_PATH}"
            ls -l "\${ENV_FILE_PATH}"
            echo "--- Env file contents: ---"
            cat "\${ENV_FILE_PATH}" || echo "Warning: Could not cat env file (might be empty)"
            echo "--------------------------"

            echo "--> Extracting PORT from \${ENV_FILE_PATH}..."
            VM_PORT=\$(grep '^PORT=' "\${ENV_FILE_PATH}" | cut -d '=' -f 2-)

            if [ -z "\${VM_PORT}" ]; then
              echo "ERROR: PORT variable not found or empty in \${ENV_FILE_PATH}"
              echo "Ensure your ENV_FILE_CONTENTS secret contains a line like 'PORT=8080'"
              exit 1
            fi
            echo "PORT extracted: \${VM_PORT}"

            echo "--> Logging into GHCR on VM..."
            echo "${GHCR_TOKEN}" | podman login ghcr.io -u ${{ github.actor }} --password-stdin

            echo "--> Pulling latest image: ${IMAGE_NAME}"
            podman pull ${IMAGE_NAME}

            SERVICE_NAME="${CONTAINER_NAME}.service"
            SYSTEMD_UNIT_PATH="\${SYSTEMD_USER_DIR}/\${SERVICE_NAME}"

            echo "--> Stopping and removing existing container (if any)..."
            if systemctl --user is-active --quiet "\${SERVICE_NAME}"; then
              echo "Stopping running systemd service: \${SERVICE_NAME}"
              systemctl --user stop "\${SERVICE_NAME}"
            else
              echo "Systemd service \${SERVICE_NAME} not active, attempting podman stop..."
              podman stop ${CONTAINER_NAME} || true
            fi

            podman rm ${CONTAINER_NAME} || true

            echo "--> Creating new container definition: ${CONTAINER_NAME}"
            podman create \
              -p "\${VM_PORT}:\${VM_PORT}" \
              --env-file "\${ENV_FILE_PATH}" \
              --name ${CONTAINER_NAME} \
              ${IMAGE_NAME}

            if [ \$? -ne 0 ]; then
                echo "ERROR: Failed to create container ${CONTAINER_NAME}"
                exit 1
            fi

            echo "--> Generating systemd unit file using redirection: \${SYSTEMD_UNIT_PATH}"
            podman generate systemd --new --name ${CONTAINER_NAME} > "\${SYSTEMD_UNIT_PATH}"

            if [ \$? -ne 0 ] || [ ! -f "\${SYSTEMD_UNIT_PATH}" ]; then
                echo "ERROR: Failed to generate systemd unit file at \${SYSTEMD_UNIT_PATH} using redirection."
                echo "Listing contents of \${SYSTEMD_USER_DIR}:"
                ls -la "\${SYSTEMD_USER_DIR}" || echo "Could not list directory."
                exit 1
            fi
            echo "Systemd unit file generated successfully."

            echo "--> Reloading systemd user daemon..."
            systemctl --user daemon-reload

            echo "--> Enabling and starting systemd service: \${SERVICE_NAME}"
            systemctl --user enable --now "\${SERVICE_NAME}"

            echo "--> Checking service status:"
            systemctl --user status "\${SERVICE_NAME}" --no-pager || echo "Warning: Service status check command failed, but deployment might still be okay."

            echo "--> Cleaning up GHCR login token..."
            podman logout ghcr.io || true

            echo "--> Deployment successful!"
          EOF

          SSH_EXIT_CODE=$?
          if [ ${SSH_EXIT_CODE} -ne 0 ]; then
            echo "Deployment script failed on remote host with exit code ${SSH_EXIT_CODE}."
            exit 1
          fi


